# QUIC : 基于UDP的多路复用安全传输

## 摘要
本文描述了QUIC传输协议的核心部分，附件文档中描述QUIC的丢包检测，拥塞控制，以及TLS密钥使用。   


## 读者须知   

本草案在QUIC工作组的邮件列表中讨论，邮件见https://mailarchive.ietf.org/arch/search/?email_list=quic   
工作组信息见https://github.com/quicwg   
本草案的源码和问题列表见https://github.com/quicwg/base-drafts/labels/-transport   


## 目录

## 1.简介
QUIC是一种多路复用和安全的通信协议   
它提供以下特性：   
+ 流的复用   
+ 连接级别的流量控制   
+ 低延迟的建连耗时   
+ 连接迁移和NAT重新绑定的弹性   
+ 验证和加密的头部信息和负载  
    
QUIC底层使用UDP以避免客户端操作系统和通信中间设备的改动。QUIC认证所有的头部信息，加密传输的大部分数据，包括它的控制信号，以避免对通信的中间设备产生依赖。     
### 1.1文档结构
本文描述了QUIC协议的核心部分，本文结构如下：   
+ Stream是QUIC提供的基础服务抽象
  - 第2节 描述与Stream相关的核心概念
  - 第3节 提供Stream状态的参考模型
  - 第4节 概述了流量控制的操作
+ 连接是QUIC端点通信过程中的实体
  - 第5节 描述了连接相关的核心概念   
  - 第6节 描述了版本协商过程   
  - 第7节 是关于连接建立过程的细节   
  - 第8节 指点关键的服务拒绝环节机制   
  - 第9节 描述了端点如何将连接迁移到另一个新的网络环境中   
  - 第10节 列出了中断连接时的所有选项   
  - 第11节 提供对错误处理的一般指导   
+ 包和帧是QUIC通信的基本单元
  - 第12节 描述了关于包和帧的关键概念   
  - 第13节 定义了传输，重传和确认的模型   
  - 第14节 定义了包大小管理的规则   
+ 最后，展示了一些QUIC编码的细节
  - 第15节 版本   
  - 第16节 整型编码   
  - 第17节 包头   
  - 第18节 传输参数   
  - 第19节 传输帧   
  - 第20节 错误定义    
附录文件描述了本文未尽的一些QUIC细节，包括[拥塞控制](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)，以及[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)。   

### 1.2 术语和定义
关键字 "**一定**", "**禁止**", "**要求**", "**应该**", "**不应**", "**推荐**", "**不推荐**", "**可以**", "**可选**"的使用与[BCP14](https://tools.ietf.org/html/bcp14) [RFC2119](https://tools.ietf.org/html/rfc2119) [RFC8174](https://tools.ietf.org/html/rfc8174)相同。   
本文常用的术语定义如下：    
QUIC：本文描述的传输协议，QUIC只是一个名字，而不是一个缩略词。    
QUIC包：QUIC可以封装进UDP数据包的完整处理单元，多个QUIC包可以被放到一个UDP数据包中。   
ACK引发包：除了ACK，PADDING，CONNECTING外，其他包都包含的一种QUIC包，它使得接受方发送接受确认。    
乱序包：一种数据包，它的编号并不是接受方最大编号加一，当包传输延迟或者该包之前的包延迟或丢失，都可能造成包的乱序到达。   
Endpoint：QUIC连接中生成，接收，处理QUIC包的实体。QUIC中只有客户端和服务器两种Endpoint。   
客户端：主动建立连接的Endpoint。    
服务器：接收连接请求的Endpoint。     
Address：ip版本，ip 地址，UDP协议，和UDP端口的元组代表了网络通信的一个终端。    
连接ID：在EndPoint中用一个唯一的ID来标识一个连接，每个EndPoint发送包到对端的时候都会将这个值写入包内。   
Stream：在QUIC连接之上，传输有序数据的单向或双向通道，一个QUIC连接可以同时携带多个Stream。   
应用：使用QUIC发送和接收数据的实体。   
   
### 1.3 符号约定   
本文使用的包和帧的格式定义类似Section 3.1 of [RFC2360](https://tools.ietf.org/html/rfc2360#section-3.1)，约定如下：   
[x]：表示x是可选的   
x (A): 表示x长度为A bits   
x (A/B/C): 表示x的长度为A，B或C bits   
x (i)…：表示x使用变长编码   
x (*): 表示x是变长的   

## 2 Streams   
Stream 是QUIC提供给应用的轻量级有序数据传输的功能抽象。Stream 可以是单向的也可以是双向的，QUIC单向流的另一种观点是几乎无限长的“消息”抽象。   
Streams可以被创建用来发送数据，与Streams管理相关的其他过程(结束，取消，管理流控)，都是为了施加最小的开销而设计的。比如，一个Stream帧可以创建，关闭Streams或者携带数据。Streams也可以是长存的，直到QUIC连接结束。   
Steams可以被任意一端EndPoint创建，可以交替着和其他Streams一起发送数据，也可以被取消。QUIC没有提供任何实际的机制来保证不同Streams的数据传输有序。不同Streams间的数据是乱序传输的。   
QUIC允许操作任意数量的Streams，在任意一个Streams上发送任意数量的数据，这取决于流控和流量限制。   
### 2.1 Steam的类型和ID
Streams可以是单向或双向的，单向的Streams只能往一个方向发送数据：从Stream的发起方到对端。双向的Stream可以在两个方向上发送数据。   
在一个连接内，一个数字值作为Stream ID来标识一个Stream，Stream ID是一个62Bit长度的整数，它在一个连接内是独特唯一的。Stream ID按照变长整数进行编码，QUIC EndPoint **禁止**在一个连接内复用 Stream ID。   
Stream ID的最后一个bit位用来标识发起方，客户端发起的Stream，设置为0，服务器发起的Stream，设置为1。   
Stream ID的倒数第二个bit位用来标识Stream数据发送方向，双向时为0，单向时为1。   
Stream ID最后两位的bit组合共有四种类型，定义如下：   
| Bits | Stream Type      |
| :--: | :--------------: |
| 0x0  | 客户端发起, 双向 |
| 0x1  | 服务端发起, 双向 |
| 0x2  | 客户端发起, 单向 |
| 0x3  | 服务端发起, 单向 |
   
在每种类型中，Stream ID都是递增创建的，无序使用的流ID会导致该类型的所有流同时打开编号较低的流ID(存疑)。    
客户端打开的第一个双向流的Stream ID为0。     
    
### 2.2 发送和接收数据    
Stream帧封装应用发送的数据，一个EndPoint使用Stream ID和偏移量字段来使数据有序。    
EndPoint一定保证将Stream 数据有序的传输给上层应用，这就需要EndPoint缓存无序到达的数据，直到流量控制的上限。     
QUIC对Stream乱序传输的数据并没有特别的考虑，但是，在实现上也可以将乱序的数据透传给上层应用。   
一个EndPoint可能会在一个Stream上接收到多次相同偏移的数据，其中一些早已经接受过的数据可以丢弃掉，当数据发生重传时，它的偏移量**禁止**被修改。当一个EndPoint在一个Stream上相同偏移接收到不同数据时，会视为连接错误：PROTOCOL_VIOLATION。   
对QUIC而言，Stream是独立的有序传输数据的抽象，当数据被传输、丢包后重新传输或传送到应用程序时，Stream帧边界不期望被持有。   
EndPoint**禁止**在任何还没有被对端设置流控限制的Stream上发送数据，流控的详细内容见第四节。   
    
### 2.3 Stream优先级
如果分配给流的资源的优先级正确，Stream 复用可以对应用程序性能产生显著影响。    
QUIC并没有自己的信息优先级机制，它依赖使用QUIC的上层应用来设置不同的优先级。    
QUIC的实现**应该**提供一种方式来使上层应用可以设置Stream的优先级，并且**应当**使用应用层的信息来设置不同Stream的传输优先级。

### 2.4 Stream所需操作
应用层在使用QUIC Stream时，**一定**要执行某些操作，本文并没有定义具体的API，但是这个版本的QUIC任何实现都应该提供本节中描述的Stream操作。   
在Stream发送部分，应用层应该能够：   
+ 写数据，了解何时流控信息被设置然后开始发送写入的数据。   
+ 结束Stream(完整的终止)，将发送设置了FIN标识的Stream帧。   
+ 重置Stream(突然终止)，当Stream尚未处于终端状态时，发送RESET_STREAM帧。   
   
在接收端。应用程序能够：   
+ 读取数据。   
+ 终止读取并且请求关闭，可能会发送STOP_SENDING帧。   
   
Stream的状态改变需要通知到应用层，包括：   
- 对端打开或关闭了一个Stream
- 对端终止读取一个Stream
- 新的数据可读
- 流控引起的数据可写或不可写 

## 3 Stream状态
本节讲述Stream的发送或接收组件。有两种状态机：   
+ 数据发送端
+ 数据接收端
  
单向的流直接使用合适的状态机，但是双向的Stream每个端都有两种状态机。在大多数情况下，单向或双向Stream对状态机的使用都是相同的。双向Stream的打开要复杂一些，因为不论是接收端还是发送端，都需要打开两个方向的数据传输。   
一个EndPoint**必须**在一个Stream type上递增的创建Stream ID。   
注意： 这些状态的信息量很大，本文使用Stream状态来描述何时以及如何发送不同类型的帧的规则，以及接收到不同类型帧时预期的反应。理解了这些状态机对实现QUIC非常有用。实现时可以定义不同的状态机，只要其实现与本文定义一致。   

### 3.1 Stream的发送状态
下图展示了Stream发送数据到对端的部分状态： 
```
    o    
    | 创建 Stream (Sending)    
    | 对端创建双向Stream    
    v    
+-------+    
| Ready | Send RESET_STREAM    
|       |-----------------------.    
+-------+                       |    
    |                           |       
    | Send STREAM /             |    
    | STREAM_DATA_BLOCKED       |    
    |                           |    
    | Peer Creates              |    
    | Bidirectional Stream      |    
    v                           |    
+-------+                       |    
| Send  | Send RESET_STREAM     |    
|       |---------------------->|    
+-------+                       |    
    |                           |    
    | Send STREAM + FIN         |    
    v                           v    
+-------+                   +-------+
| Data  | Send RESET_STREAM | Reset |
| Sent  |------------------>| Sent  |
+-------+                   +-------+
    |                           |
    | Recv All ACKs             | Recv ACK
    v                           v
+-------+                   +-------+
| Data  |                   | Reset |
| Recvd |                   | Recvd |
+-------+                   +-------+
```
在发送端Endpoint启动(客户端类型为0和2，服务端类型为1和3)由应用层打开的Stream，"Ready"状态标识新创建的Stream已经可以接收应用层的数据，这时将数据进行缓存以等待发送。   
发送第一个**STREAM**或**STREAM_DATA_BLOCKED**帧时Stream会进入"Send"状态。 实现上可以将设置Stream ID延后知道Stream发送了第一个STREAM帧进入了"Send"状态，这样可以更好的确认Stream的优先级。   
由对端方发起的双向Stream接收状态机创建后，发送状态机以"Ready"状态开始。   
在"Send"状态，EndPoint通过**STREAM**帧发送或重传数据，EndPoint发送过程遵守由对端创建的流量限制，并一直接收和处理对端的**MAX_STREAM_DATA**帧。如果被连接或Stream的流控限制(见4.1节)导致阻塞数据发送，"Send"状态的EndPoint将发送**STREAM_DATA_BLOCKED**帧。  
当应用层的数据被全部发送完并且发送了**FIN**的**STREAM**帧，Stream的发送端进入"Data Sent"状态，之后EndPoint只会做一些必要的数据重传不再接收新的应用层数据。在这个状态，EndPoint不用检查流控限制或者发送**STREAM_DATA_BLOCKED**帧，但是还是可能会接收到**MAX_STREAM_DATA**帧，直到对端接收到最终的Stream数据，不过此时可以安全的忽略对端发送的**MAX_STREAM_DATA**帧。   
一旦所有的数据都被确认，Stream发送端进入"Data Recvd"状态，这是一个终端状体。   
在"Ready","Send"或"Data Sent"状态，应用层都可以终止Stream的数据发送。或者，EndPoint可能接收到对端的**STOP_SENDING**帧。无论哪种情况，EndPoint都会发送一个**RESET_STREAM**帧，之后进入"Reset Sent"状态。   
EndPoint可能会在Stream上第一次就发送**RESET_STREAM**帧，这将导致Stream打开发送部分并直接进入"Reset Sent"状态。   
一旦**RESET_STREAM**帧被确认，Stream的发送端会进入"Reset Recvd"的终端状态。
### 3.2 Stream的接收状态
下图展示了从对端接收数据的部分状态：
```
    o
    | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
    | Create Bidirectional Stream (Sending)
    | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
    | Create Higher-Numbered Stream
    v
+-------+
|  Recv | Recv RESET_STREAM
|       |-----------------------.
+-------+                       |
    |                           |  
    | Recv STREAM + FIN         |
    v                           |
+-------+                       |
| Size  |   Recv RESET_STREAM   |
| Known |---------------------->|
+-------+                       |
    |                           |
    |Recv All Data              |
    v                           v
+-------+ Recv RESET_STREAM +-------+
| Data  |--- (optional) --->| Reset |
| Recvd |   Recv All Data   | Recvd |
+-------+<-- (optional) ----+-------+
    |                           |
    | App Read All Data         | App Read RST
    v                           v
+-------+                   +-------+
| Data  |                   | Reset |
| Read  |                   | Read  |
+-------+                   +-------+
```
Stream接收部分不跟踪发送部分无法观测的状态，如"Ready"状态。Stream的接收部分跟踪向应用程序传递的数据。   
当接收到对端发送的第一个**STREAM**，**STREAM_DATA_BLOCKED**或**RESET_STREAM**帧(客户端类型为0和2，服务端类型为1和3)时，创建Stream的接收部分。当接收到对端发送的**MAX_STREAM_DATA**，**STOP_SENDING**帧时也会创建Stream的发送部分。Stream发送部分的起始状态是"Recv"。    
当EndPoint创建双向发送Stream的发送部分进入"Ready"时，Stream的接收部分进入"Recv"状态。
当接收到对端发送的**MAX_STREAM_DATA**，**STOP_SENDING**EndPoint打开一个双向Stream。一个未打开的Stream接收到**MAX_STREAM_DATA**表示对端已经打开了Stream并且提供了流控设置。一个未打开的Stream接收到**STOP_SENDING**表示对端希望从这个Stream接收数据。当发送丢包或重传时，这两种包都可能比**STREAM**和**STREAM_DATA_BLOCKED**先到达。    
在Stream创建之前，相同类型的Stream较小Stream ID**一定**被创建过。这样确保Stream的创建顺序在两个EndPoint上是一致的。   
在"Recv"状态，EndPoint接收**STREAM**和**STREAM_DATA_BLOCKED**帧，缓存接收的数据，组合排序然后传输给应用。当数据交付给应用时，可以复用缓存。EndPoint发送**MAX_STREAM_DATA**帧通知对端发送更多的数据。   
当接收到设置了**FIN**的**STREAM**帧时，就获知了Stream的最终大小。Stream的接收部分进入"Size Known"状态。在此状态，EndPoint不再发送**MAX_STREAM_DATA**给对端，只是接收数据。    
一旦Stream接收到了所有的数据，接收部分就进入了"Data Recvd"状态，这可能与接收到**FIN**的**STREAM**进入"Size Known"是同一帧。这之后，任何**STREAM**帧和**STREAM_DATA_BLOCKED**帧都可以被丢弃。    
"Data Recvd"状态维持到应用接收完所有的数据，当所有数据都交付完成时，Stream进入"Data Read"状态，这是一个终端状态。    
在"Recv"或"Size Know"状态接收到**RESET_STREAM**帧，Stream会进入"Reset Recvd"状态，这可能会导致中断向应用交付数据的过程。    
可能在所有数据都接收完成时收到**RESET_STREAM**帧(在"Data Recvd"状态)，同样，也可能在接收到**RESET_STREAM**帧之后又接收到剩余的数据携带帧(在"Reset Recvd"状态)，这时实现可以自己选择处理方式。    
发送**RESET_STREAM**表示EndPoint不再发送数据，然后并没有要求接收到**RESET_STREAM**后中断数据接收。一种实现可能会切断Stream的数据接收过程然后丢弃掉所有已经接收缓存的数据，然后发送**RESET_STREAM**信号(通知上层)。当所有的数据都已经接收并缓存以等待应用读取时，**RESET_STREAM**也可能被忽略，这时Stream的接收部分依然处于"Data Recvd"状态。    
一旦应用接收到Stream重置的信号，Stream的接收部分进入"Reset Read"的终端状态。    
### 3.3 Stream的帧类型
Stream的发送方只会发送三种类型的帧，他们影响着发送端和接收端Stream的状态：   
+ STREAM(见19.8节)
+ STREAM_DATA_BLOCKED(见19.13节)
+ RESET_STREAM(见19.4节)

Stream在终端状态时(“Data Recvd”或“Reset Recvd”)，**禁止**发送任何携带上述类型的帧。一个发送者在发送了**RESET_STREAM**之后，**禁止**再发送**STREAM**或**STREAM_DATA_BLOCKED**帧。因为，在终端状态或者“Reset Sent”状态，由于可能出现的延迟到达，接收端在任何状态都会接收这三种类型的帧。   

Stream的接收端发送:    
+ MAX_STREAM_DATA
+ STOP_SENDING   

Stream的接收端在”Recv”状态时只发送**MAX_STREAM_DATA**帧，接收端在未收到**RESET_STREAM**时，在任何状态都可以发送**STOP_SENDING**帧，也就是除了”Reset Recvd”,”Reset Read”状态。然而，在”Data Recvd”状态发送**STOP_SENDING**并没有什么意义，因为所有的数据都已经被接收。因为包的延迟到达，Stream的发送端在任何时候都有可能收到这两种帧。
### 3.4 双向Stream状态
一个双向的Stream由发送和接收两部分组成，实现上可以将发送和接送部分的状态组合为双向Stream的状态。最简单的模型，当发送和接收部分都不处于终端状态时，Stream处于”Open”状态，当发送和接收都处于终端状态时，Stream处于”Closed”状态。    
下图展示了一种更为复杂的组合Stream状态，其近似于HTTP/2。由Stream的发送和接收部分的多个状态映射为一个复合状态。注意，这只是这种映射的一种可能；这种映射要求在转换到“closed”或“half closed”状态之前确认所有数据。
```
+----------------------+----------------------+-----------------+
| 发送部分状态           |  接收部分状态          |  复合状态        |
+======================+======================+=================+
| No Stream/Ready      | No Stream/Recv *1    | idle            |
+----------------------+----------------------+-----------------+
| Ready/Send/Data Sent | Recv/Size Known      | open            |
+----------------------+----------------------+-----------------+
| Ready/Send/Data Sent | Data Recvd/Data Read | half-closed     |
|                      |                      | (remote)        |
+----------------------+----------------------+-----------------+
| Ready/Send/Data Sent | Reset Recvd/Reset    | half-closed     |
|                      | Read                 | (remote)        |
+----------------------+----------------------+-----------------+
| Data Recvd           | Recv/Size Known      | half-closed     |
|                      |                      | (local)         |
+----------------------+----------------------+-----------------+
| Reset Sent/Reset     | Recv/Size Known      | half-closed     |
| Recvd                |                      | (local)         |
+----------------------+----------------------+-----------------+
| Reset Sent/Reset     | Data Recvd/Data Read | closed          |
| Recvd                |                      |                 |
+----------------------+----------------------+-----------------+
| Reset Sent/Reset     | Reset Recvd/Reset    | closed          |
| Recvd                | Read                 |                 |
+----------------------+----------------------+-----------------+
| Data Recvd           | Data Recvd/Data Read | closed          |
+----------------------+----------------------+-----------------+
| Data Recvd           | Reset Recvd/Reset    | closed          |
|                      | Read                 |                 |
+----------------------+----------------------+-----------------+
```
注(*1):    
如果Stream没有创建，或者Stream的接收状态处于"Recv"而没有接收到任何帧，则视为"idle"状态。
### 3.5 请求的状态转换
如果一个应用不再对Stream接收的数据感兴趣，可以终止Stream的读取然后设置一个应用的error code。如果Stream处于"Recv"或"Size Known"状态，传输应该通过发送**STOP_SENDING**帧来提示对端关闭Stream的发送部分。这表示接收端的应用不再读取之后接收到的数据，但并不代表会忽略掉已经接收到的数据。    
在发送**STOP_SENDING**后接收到的**STREAM**帧依然会计入连接和流量控制中，即使这些帧可能会被丢弃。    
一个**STOP_SENDING**帧要求接收端返回一个**RESET_STREAM**帧，如果Stream处于"Ready"或"Send"状态，在接收到**STOP_SENDING**帧后**一定**要发送一个**RESET_STREAM**帧做为反馈。如果Stream处于"Data Sent"状态并且未传输的数据被申明为丢弃，EndPoint**应该**发送一个**RESET_STREAM**帧来代替重传。    
如果Stream在接收到**STOP_SENDING**的时候已经处于"Data Sent"状态，EndPoint如果想要终止先前发送的**STREAM**帧的重传，则要先发送一个**RESET_STREAM**帧。    
**STOP_SENDING** **应该**只能被没有被对端重置的Stream发送，**STOP_SENDING**对处于"Recv"或"Size Known"状态的Stream是非常有效的。    
如果前一个**STOP_SENDING**丢失，则EndPoint需要重传另一个**STOP_SENDING**，然而，一旦Stream接收到了所有数据或接收到了**RESET_STREAM**，也就是说，Stream已经不处于"Recv"或"Size Known"状态，就没有必要再发送**STOP_SENDING**帧了。    
如果EndPoint希望终止双向Stream两个方向上的数据传输，可以发送一个**RESET_STREAM**来终止通知对端自己不再发送，然后再发送一个**STOP_SENDING**来通知对端不要再向自己发送。    

## 4 流量控制
非常有必要来限制数据的数量以使接收端可以有效缓存，一是防止一个快速的发送端压垮一个较慢的接收端，二是防止恶意的发送端发送大量数据以占用接收端过量的内存。为了使接收端能够控制连接使用的内存以压缩发送端的发送数据量，Stram的流控既有单独的控制也有聚合的控制。一个QUIC的接收端在任何时候都控制着发送端最大数据量的发送限制。详细描述见4.1节和4.2节。    
同样，为了控制一个连接上的并发，QUIC的EndPoint控制着对端可以启动的最大Stream数量限制。详细描述见4.5节。    
**CRYPTO**帧数据的发送与Stream的流控方式不同，QUIC依赖加密协议的实现来避免数据的过度缓存(见[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-tls-27))。实现上QUIC应该提供一种接口来告知其缓存上限，这样就不会在多层上存在冗余缓存。    

### 4.1 数据流控制
QUIC采用了一种类似于HTTP/2的基于信用的流控制方案，接收端会公布它在Stream和对应连接上准备好接收的字节数，这就导致QUIC有两层的流量控制：    
+ Stream层的流控，它通过限制在任意Stream上发送的数据量来避免一个单个的Stream消耗连接上过多的缓存。
+ 连接层的流控，通过限制所有Streams的**STREAM**帧的数据量来避免发送端发送的数据超出连接的整个缓存大小。    

接收端在握手(见7.3节)的时候通过发送传输参数来设置所有Stream的初始流量控制信息，通过发送**MAX_STREAM_DATA**帧(见19.10节)或**MAX_DATA**帧(见19.9节)到对端去调整流量限制。    
Stream的接收端通过发送设置了适当Stream ID的**MAX_STREAM_DATA**帧来通知对端流量控制信息，一个**MAX_STREAM_DATA**帧携带了Stream的所允许的绝对最大数据偏移，接收端可以使用当前所消耗的数据偏移来确定流量控制的偏移量。接收端**可能**会在多个包上发送**MAX_STREAM_DATA**帧来确保接收端在超出流控限制之前接收到了流控通知，即使其中的一些包丢失。    
接收端通过发送**MAX_DATA**帧来调整连接的流量控制信息，它携带所有Stream绝对偏移量之和。接收端维护累计所有Stream已经接收数据量的和，以用来检测是否超出了流量限制。接收端可以使用所有Stream上消耗的字节总数来确定要公布的流量限制。    
接收端通过发送**MAX_STREAM_DATA**帧和**MAX_DATA**帧来通告一个更大的偏移值。如果发布了没有增加偏移的偏移值，也没有影响。发送端**必须**忽略偏移量未增加的**MAX_STREAM_DATA**帧和**MAX_DATA**帧。
如果发送端违反了连接层或Stream层的流量限制，接收端**一定**会使用**FLOW_CONTROL_ERROR**错误来终止连接。    
如果发送端消耗完了对端通知的流量限制偏移，那么就无法再发送数据而进入阻塞状态，这时**应该**发送**STREAM_DATA_BLOCKED**帧或**DATA_BLOCKED**帧来通知对端还有数据未发送但是被流量限制阻塞了。如果阻塞的时间超过了设置的空闲超时时间(见10.2节)，那么连接就可能会关闭，即使还有数据没有发送完。为了防止连接关闭，受流量限制的发送端**应该**在没有未确认的在途数据的时候定期发送**STREAM_DATA_BLOCKED**或**DATA_BLOCKED**帧。    

### 4.2 流量限制增加
实现要决定何时通过**MAX_STREAM_DATA**和**MAX_DATA**发送多少偏移限制，本节提供一些考虑因素。    
为了避免阻塞发送端，接收端可以在一个交互回合中多次发送或尽早发送**MAX_STREAM_DATA**和**MAX_DATA**以便从丢包中快速恢复。    
控制帧会增加连接的开销，因此，极小的变动就频繁的发送**MAX_STREAM_DATA**和**MAX_DATA**帧是不明智的。另一方面，如果更新的频次较低，需要发送更大的限制偏移来避免发送端阻塞。在确定公布的流量限制偏移有多大时，应该在资源开销和传输开销之间有一个权衡。    
接收端可以基于包的往返时间和接收端消耗数据的速率来自动调整发送的偏移限制和频率，类似与常见的TCP实现。作为一种优化，EndPoint可以在有其他包要发送或者对端已经被流量限制阻塞时发送相关的**MAX_STREAM_DATA**和**MAX_DATA**帧，以确保流控不会导致发送额外的控制包。    
被阻塞的发送端并不强制要求发送**STREAM_DATA_BLOCKED**和**DATA_BLOCKED**帧，因此，接收端在发送**MAX_STREAM_DATA**和**MAX_DATA**帧之前**禁止**等待**MAX_STREAM_DATA**和**MAX_DATA**帧。因为这样做的话可能会阻塞连接上的其他发送端，另外，就算发送端发送了这些帧，等待这些帧也会导致发送端最少阻塞一个RTT周期。    
如果一个阻塞了的发送端接收到了新的偏移通告，则可能在响应中发送大量的数据，导致短期的拥塞。在6.9节有如何避免这种拥塞的相关讨论。

### 4.3 处理Stream的取消
EndPoints应该在Stream取消时就流量限制的偏移量达成一致，以避免超出流量限制和死锁。    
在接收**RESET_STREAM**的过程中，EndPoint会终止对应Stream的状态并忽略Stream上新达到的数据。如果**RESET_STREAM**帧不携带偏移量，两个EndPoint可能会在计算连接流量控制的偏移上产生不一致。为了解决这个问题，**RESET_STREAM**帧包含了Stream最终发送数据的数量。在接收**RESET_STREAM**的过程中，接受端可以确切的知道在**RESET_STREAM**之前已经接收了多少数据，发送端**必须**使用Stream的最终偏移大小来计算整个连接层流量控制的偏移大小。    
**RESET_STREAM**帧会突然终止Stream的一个方向，对于一个双向的Stream来说，**RESET_STREAM**对另一个方向的流量控制没有影响。两端都必须保持在未终止方向上的流量控制，直到该方进入终端状态或者其中一个EndPoint发送了**CONNECTION_CLOSE**。

### 4.4 Stream最终大小
最终大小是Stream消耗流量控制偏移的数量。如果每个相邻的byte都被只发送了一次，那么最终大小就是发送byte的数量。通常，最终大小比Stream上已经发送的最大偏移高一个。如果还没有数据发送，则是0。    
对于一个已经被重置的Stream，最终大小在**RESET_STREAM**中携带，或者，最终大小是偏移量加上用FIN标志标记的Stream帧的长度。如果是单向Stream的接收端，则为0。

当接受端的Stream在进入”Size Known”或”Reset Recvd”状态时，会知晓最终的大小。EndPoint**禁止**发送超过最终大小的数据。    
一旦Stream的最终大小被确定，就不能再修改。如果接收到了**RESET_STREAM**或**STREAM**帧导致最终大小发生变化，则EndPoint**应该**发送一个**FINAL_SIZE_ERROR**错误作为响应(见11节)。接收端**应该**将超过最终大小的数据视为**FINAL_SIZE_ERROR**错误，即使在Stream关闭之后。生成这些错误并不是强制性的，而是因为EndPoint生成这些错误也意味着EndPoint需要为关闭Stream保持最终大小状态，这是重要的状态承诺。

### 4.5 控制并发
Endpoint限制着对端打开Stream的并发数据。只有Stream ID比(max_stream * 4 + initial_stream_id_for_type)小的Stream可以被打开。初始的限制在在握手时通过传输参数设置，之后的限制通过**MAX_STREAMS**帧来调整。单独的限制适用于单向流和双向流。    
如果通过握手时的传输参数或者**MAX_STREAMS**帧接收到的最大Stream数量超过了2^60，这将导致最大的Stream ID不能按照变长整数编码(见16节)。一旦接受到这样的数字，则连接**一定**要立马关闭连接并返回**STREAM_LIMIT_ERROR**错误(见10.3节)。   
EndPoint**禁止**超过他们对端设置的限制。一旦收到帧携带的Stream ID超过了限制，则**一定**要视为连接错误并返回**STREAM_LIMIT_ERROR**。    
一旦接受端通过**MAX_STREAMS**接收到了一个Stream数量限制，则再接收到小于这个的限制会被忽略。接收端**一定**要忽略任何不会将限制增大的**MAX_STREAMS**帧。    
与Stream和连接的流量控制一样，实现中要自己定义什么时候通过**MAX_STREAMS**帧限制多少Stream并发到对端。实现可能会选择在Stream ID接近限制时增加限制，以保持对等方可用的流的数量大致一致。    
如果EndPoint由于对端的限制不能再打开新的Stream，则**应该**发送**STREAMS_BLOCKED**帧(见9.14节)，这对程序调试非常有用。EndPoint**一定不要**等待**STREAMS_BLOCKED**帧之后再调整对端Stream数量限制，如果这样做的话意味着对端至少要阻塞一个RTT周期，如果对端选择不发送**STREAMS_BLOCKED**帧，则可能会阻塞更长时间。    

## 5 连接
QUIC的连接建立过程结合了版本协商和加密传输握手以减少连接建立时的延迟，这将在第七节讲述。一旦连接建立，则可以迁移到任何一个不同ip和端口的EndPoint上，这将在第九节讲述。最后，第十节将说明连接的中断过程。

### 5.1 连接ID
每个连接都有一组连接标识或者连接ID，以用来标识一个连接。连接ID由EndPoint独立选择，每个EndPoint选择对端使用的连接ID。连接ID的主要作用是确保下层协议(UDP,IP)协议的地址变更不会导致QUIC连接的数据传输到错误的EndPoint上。每个EndPoint都使用一个特定于实现(或特定于部署的)方式来选择连接ID。    
相同的连接ID不能在同一连接上多次发出。    
具有长数据头的包包含源连接ID和目的连接ID字段，这些字段被用来为新的连接设置连接ID，具体细节在7.2节介绍。    
具有短数据头的包(17.3节)只包括目的地连接ID，而忽略显式长度。目的连接ID字段的长度应该被对端所知道。EndPoint使用一种基于路由的负载均衡器来就连接ID的长度或编码方案达成一致，固定部分可以编码一个显式的长度，这允许整个连接ID的长度不同，并且仍然由负载平衡器使用。
一个版本协商包(17.2.1节)原路返回客户端选择的连接ID，以保证包可以正常路由到客户端，且客户端可识别该包。    
当不需要连接ID路由到正确的端点时，可以使用长度为零的连接ID。然而，相同IP和端口上的多路复用连接使用零长度的连接ID时会导致连接迁移失效。NAT的重新绑定和客户端的端口重用都会导致此问题产生，因此，除非确认这些协议的功能没有启动，否则不要使用长度为零的连接ID。     
当一个EndedPoint使用一个非零长度的连接ID时，它需要确认对端有一个可以选择的连接ID来发送数据。这些连接ID由EndPoint使用**NEW_CONNECTION_ID**帧来提供。    

### 5.1.1 发布连接ID
每个连接ID都有一个关联的序列号用来消除重复消息。在握手阶段，EndPoint发出的初始连接ID在长数据包头(见17.2节)的Source Connection ID字段中，初始连接ID的序列号为0，如果发送了preferred_address参数，则提供的连接ID为1。    
之后附加的连接ID通过**NEW_CONNECTION_ID**帧发送给对端。每个新发布的连接ID**必须**加1。客户端在初始包中随机选择的连接ID和重试包提供的任何连接ID都不会被分配序列号，除非服务器选择将它们保留为初始连接ID。   
当一个EndPoint发出了一个连接ID，则在连接期间它**必须** **接收**携带这个连接ID的包直到对端通过**RETIRE_CONNECTION_ID**帧宣布这个ID失效。已经发出而且没有失效的连接ID时活跃的，任何活动的连接ID在任何时候都是有效的，可以在任何包类型中使用，这包括服务器通过preferred_address参数发出的连接ID。    
EndPoint应该确保它的对端有足够数量可用和未使用的连接ID，EndPoint存储接收到的连接ID以供将来使用，并在活跃的连接上通过active_connection_id_limit参数来宣布愿意存储的活跃ID数量。EndPoint**一定不要**提供过多的连接ID超过对端的限制，当EndPoint接收到超过通过active_connection_id_limit参数宣布的ID限制的连接ID时，**必须**用**CONNECTION_ID_LIMIT_ERROR**错误关闭这个连接。    
当对端退出一个连接ID时，EndPoint必须提供一个新的连接ID，如果一个EndPoint提供的连接ID少于对端的活动连接ID限制，那么当它接收到一个带有以前未使用的连接ID的数据包时，它**可能**会提供一个新的连接ID。EndPoint可以限制为每个连接发出的连接ID的频率或总数，以避免连接ID用完的风险(请参阅第10.4.2节)。    
启动连接迁移并需要non-zero-length连接ID的EndPoint应确保其对端可用的连接ID池允许在迁移时使用新的连接ID，因为如果池耗尽，对端将关闭连接。   

### 5.1.2 使用和注销连接ID
EndPoint在连接存在的任何时间都可以修改它使用的连接ID，EndPoint使用连接ID响应对端的迁移。(9.5节)    
EndPoint维护着一组从对端接收到的连接ID，其中的任何一个连接ID都可以在发送包时使用。当EndPoint希望从使用的连接ID中删除一个的时候，需要发送**RETIRE_CONNECTION_ID**帧到对端。发送**RETIRE_CONNECTION_ID**通知对端某个连接ID不再使用，对端需要通过**NEW_CONNECTION_ID**回复一个新的连接ID来替代。    
如9.5节的讨论，每个连接ID都只能用于一个IP地址发送数据，如果EndPoint发生迁移不再使用之前的IP地址，则要将之前所有的连接ID都注销掉。    
EndPoint可以通过发送一个带有递增Retire Prior To字段的**NEW_CONNECTION_ID**帧来使对端注销一个连接ID，收到后，对端**一定要**立马通过反馈**RETIRE_CONNECTION_ID**帧来注销一个连接ID并将新提供的连接ID放到活跃连接ID列表内。如果无法在大约一个PTO内注销连接ID，可能会导致包的延迟，丢失，或者发送端的EndPoint会使用不能再正确到达目的地址的连接ID发送无状态的重置反馈。    
如果这个连接ID在小于三个PTO时间内已经被要求注销，EndPoint可能会丢弃**NEW_CONNECTION_ID**确认的连接ID。在此之前，端点应该准备好接收包含它所请求的连接ID的数据包，使用该连接ID的后续传入数据包可以使用相应的无状态重置令牌引发响应。    
### 5.2 将数据包与连接匹配
接受时需要对数据包进行分类，以关联到一个现有的连接上，或者，对于服务端，可能会新建一个连接。    
EndPoint尝试将数据包与现有的连接进行关联，如果这个包携带了非零长度的目的连接ID关联现有的某个连接，QUIC则使用该连接处理该包。注意，一个连接可以与多个连接ID相关联，见5.1节。    
如果包的目的连接ID是零长度的并且地址信息匹配到了EndPoint使用的某个零长度的连接ID的地址，则QUIC使用此连接处理该包。EndPoint可以只使用目的IP和端口或同时使用源地址和目标地址进行标识，尽管这会使连接变得脆弱，如第5.1节所述。    
对与那些不能关联到任何连接的包，EndPoint可以发送反馈一个无状态的重置。一个无状态的连接重置可以使对端快速识别连接不可用。    
如果与现有连接匹配的数据包与该连接的状态不一致，则丢弃这些数据包。比如，如果某个包携带的协议版本与匹配的连接不同则会被丢弃，或者一旦预期的密钥可用，则删除数据包保护失败。    
没有数据包保护的包(例如初始化，重试或版本协商)可能会被丢弃，如果EndPoint在发现错误之前提交了状态变更，则**一定要**生成连接错误。    

### 5.2.1 客户端包处理
客户端发出的有效数据包通常会携带一个客户端选择的目的连接ID，那些选择零长连接ID的客户端可以使用本地的地址和端口来标识一个连接，不匹配任何连接的数据包会被丢弃。    
由于数据包重新排序或丢失，客户机可能会接收到使用尚未计算的密钥加密的连接的数据包。客户端可能会丢弃这些数据包或缓存这些数据包，以备之后的数据包计算其所用密钥。    
如果客户端接收到的数据包版本不受支持，则**必须**丢弃该数据包。    

### 5.2.2 服务端包处理
如果服务端接收到的包拥有不支持的版本，但是该包足够长能够支持服务端创建任何版本的新连接，则发送一个版本协商包(6.1节)。服务端可以对这些版本协商的包进行速率控制以避免发送太多。     
不支持的版本的第一个数据包可以对任何特定于版本的字段使用不同的语义和编码。特别是不同的保护密钥可能被用于不同的版本。如果服务器不支持某个版本，也不大可能能解密该版本的加密内容。    
具有某个支持版本的或者没有版本字段的包，被通过连接ID匹配到某个连接，或者零长度连接的包被通过本地IP和端口匹配到某个连接。如果包不能匹配到任何一个已经存在的连接，则继续执行以下操作：    
+ 如果使完全复合规范的初始包，则服务端继续进行握手过程(见7节)。这意味着服务端提交客户端选择的版本。    
+ 如果当前不服务接收任何新连接，则反馈一个**CONNECTION_CLOSE**的初始包并携带**SERVER_BUSY**的错误码。    
+ 如果是0-RTT包，服务端**可以**缓存一定数量的这些包以等待延迟到达的初始包。客户端无法在收到服务响应之前发送握手包，所以服务**应该**忽略这些包。    
+ 在所有其他情况下，服务器必须丢弃传入的数据包。  

## 5.3 QUIC连接的生命周期
QUIC连接是服务端和客户端之间有状态的互动，其最主要的作用是通过一种应用层协议来进行数据交换。Stream(第2节)是应用层数据交换的最主要手段。    
每个连接都开始与握手阶段，在此阶段客户端和服务端使用加密握手协议建立加密密钥，协商应用层的控制协议。握手(第7节)确认双端都愿意建立通信连接(8.1节)，并建立连接的参数(7.3节)。    
应用协议也可以通过有限的方式控制握手过程，0-RTT允许客户端发送应用层数据而不用接收到任何服务端数据。然而，0—RTT缺少一定的密钥安全保证。特别是，在0-RTT中没有针对重传攻击的保护，见[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-tls-27)。另外，服务器还可以在接收到客户端最终的加密握手信息(以确认客户端的的身份和活跃)之前，向客户端发送应用层数据。这些功能允许应用程序协议提供选择，以换取一些安全保证以减少延迟。     
连接ID的使用允许连接迁移到一个新的网络路径，即可以由EndPoint直接选择迁移，或者是因为中间设备改变而被迫迁移。第9节描述了与迁移相关的安全和隐私问题的缓解措施。    
对于不在需要的连接，有几种方式供客户端和服务器来关闭一个连接(见第10节)。

## 5.4 连接所需操作
在与QUIC传输交互时，应用程序必须能够执行某些操作。本文没有声明具体的API，但是这个版本的QUIC的任何实现都必须提供在QUIC连接上执行本节中描述的操作的能力。    
在客户端，QUIC的实现应该能够：    
+ 打开一个连接，开始第7节所述的交换。    
+ 当0-RTT可用时启用。    
+ 当0-RTT被服务器接受或拒绝时，通知上层。    

在服务端：    
+ 监听传入的连接，这为第7节中描述的交换做准备。    
+ 如果支持**Early Data**，则将应用程序控制的数据嵌入发送到客户端的TLS恢复票证中。    
+ 如果支持**Early Data**，则从客户端的恢复票证中检索应用程序控制的数据，并允许基于该信息拒绝早期数据。    

在双端：   
+ 为每种类型的允许Stream的初始数量配置最小值，如传输参数中所述(7.3节)。    
+ 控制各种类型的资源分配，包括流控制和每种类型的允许Stream的数量。     
+ 确定握手已经完成还是仍在进行。    
+ 通过生成**PING**帧(第19.2节)，或请求传输在空闲超时过期之前发送额外的帧(第10.2节)，防止连接静默关闭。    
+ 立即关闭(第10.3节)连接。

## 6 版本协商
版本协商确保客户机和服务器同意一个相互支持的QUIC版本。服务器发送一个版本协商包，以响应每个可能启动新连接的包；有关详细信息，请参阅第5.2节。    
客户端发送的第一个包的大小将决定服务器是否发送版本协商包。支持多个QUIC版本的客户端应该尽可能的(包的大小限制)将支持的所有版本信息都填充到一个发送的包中。这样可以确保服务器在存在相互支持的版本时做出响应。    

### 6.1 发送版本协商包
如果客户端选择的版本不被服务器接受，服务器将用版本协商包进行响应(见第17.2.1节)，这个包包括一个服务器支持版本的列表。EndPoint在收到版本协商包后**禁止**再以版本协商包作为响应。    
此系统允许服务器处理不支持版本的数据包而不保留状态。由于初始包和版本协商包都有可能丢失，客户端可以在未接收到成功的确认响应时发送新的包，或者放弃连接的尝试，如果这样，客户端将丢弃连接的所有状态，并且不再在连接上发送任何数据包。   
服务端可以限制发送版本协商包的数量，例如，能够识别包为0-RTT的服务器可能选择不发送版本协商包而发送0-RTT包，然后等待客户端的初始包。    

### 6.2 处理版本协商包
当客户端接收到版本协商数据包时，它必须放弃当前的连接尝试。QUIC的版本协商过程是向前兼容的。将来版本的QUIC可能会改变之前版本数据协商包的处理过程，如何进行版本协商是QUIC未来版本定义的未来工作，特别是，未来的工作将需要确保对版本降级攻击的健壮性；见21.10节。    

### 6.2.1 草案版本之间的版本协商
当实现接收到版本协商包时，它可以使用尝试使用包中列出的某个版本来尝试建立新连接，而不是放弃当前的连接尝试；见第6.2节。    
客户端必须检查接收到的目标和源连接ID字段是否与自己发送的数据包中的源和目标连接ID字段匹配，如果检查失败则**必须**丢弃。    
一旦确定服务器发送的版本协商包是有效的，客户端会选择一个自己支持的服务器提供的协议版本，之后尝试使用这个版本来建立新的连接，新连接必须使用一个新的随机目标连接ID，而不是以前发送的ID。   
请注意，此机制不能防止降级攻击，并且不能在草稿实现之外使用。    

### 6.3 使用保留版本
为了使服务器将来使用新版本，客户端需要正确处理不受支持的版本。为此，当生成版本协商包时，服务端应该包括保留用于强制版本协商的版本(如15节定义)。    
版本协商的设计允许服务器避免维护以这种方式拒绝的数据包的状态，客户端可以使用为强制版本协商而保留的版本发送数据包，这可用于从服务器请求受支持版本的列表。    

## 7 加密和传输握手
QUIC依赖于密码和传输握手的组合，以最小化连接建立延迟。QUIC使用第19.6节描述的**CRYPTO**帧来进行加密握手，QUIC的0x00000001版本使用TLS(如[QUIC-TLS]中所述).不同的QUIC版本号可能表示正在使用不同的加密握手协议。
QUIC提供可靠、有序的加密握手数据传递,QUIC将握手的数据包尽可能的进行加密。加密的握手过程必须支持以下属性：    
+ 进行密钥交换，当：    
    - 服务器总是经过身份验证
    - 客户端可选的进行身份验证
    - 每个连接都会产生不同和不相关的键
    - 密钥可以用于0-RTT和1-RTT包的保护
    - 1-RTT密钥具有前向保密性
+ 验证双端的传输参数，以及服务器传输参数的加密(7.3节)。
+ 应用协议的协商。    

端点可以在它发送的第一个数据包中验证对显式拥塞通知(ECN)的支持，如第13.4.2节所述。    
**CRYPTO**帧可以在不同的包编号空间发送。**CRYPTO**帧用于确保加密握手数据的有序传递的序列号在每个包编号空间中都是从零开始。    
EndPoint必须协商应用层协议，以避免使用的协议出现分歧。    
## 7.1 握手流程示例
这里只提供一些实例，详细的TLS如何与QUIC集成在[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-tls-27)。第8.1.2节显示了支持客户端地址验证的扩展。    
一旦交换地址验证完成，就可以使用加密握手来商定加密的密钥，加密握手数据被初始包(17.2.2节)和握手包(17.2.4节)携带。    
图3提供了1-RTT握手的概述，每行显示一个QUIC包，首先显示包类型和包编号，然后是通常包含在这些包中的帧。因此，例如，第一个包是Initial类型，包编号为0，并且包含一个携带ClientHello的**CRYPTO**帧。    
注意，多个QUIC数据包——即使是不同的加密级别——也可以合并成一个单独的UDP数据报(见第12.2节)，因此，这种握手可能只包含4个UDP数据报，或者更多。例如，服务器的第一次发送的数据包包含来自初始加密级别(模糊化)、握手级别的数据包，以及来自服务器的1-RTT加密级别的"0.5-RTT数据"。
```
Client                                                             Server
Initial[0]: CRYPTO[CH] ->
                                            Initial[0]: CRYPTO[SH] ACK[0]
                                  Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                            <- 1-RTT[0]: STREAM[1, "..."]
Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] ->
                                       1-RTT[1]: STREAM[3, "..."], ACK[0]
                                                  <- Handshake[1]: ACK[0]
                          图3: 1-RTT 握手示例
```
图4展示了一个具有0-RTT握手和一个0-RTT数据包的连接示例，请注意，如第12.3节所述，服务器在1-RTT加密级别确认0-RTT数据，而客户端在相同的包编号空间中发送1-RTT包。    
```
Client                                                             Server
Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0, "..."] ->
                                            Initial[0]: CRYPTO[SH] ACK[0]
                                             Handshake[0] CRYPTO[EE, FIN]
                                     <- 1-RTT[0]: STREAM[1, "..."] ACK[0]
Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[1]: STREAM[0, "..."] ACK[0] ->
                                       1-RTT[1]: STREAM[3, "..."], ACK[1]
                                                  <- Handshake[1]: ACK[0]
                          图4: 0-RTT 握手示例
```

## 7.2 协商连接ID
连接ID被用来确保数据包的路由目标，这在5.1节有述。长数据包头包含两个连接ID：       
+ 目的连接ID，由数据接收端选择的，用来标识路由目标
+ 源连接ID，接收端发包时用来设置包目的连接ID    

在握手阶段，长数据包头的包用来确定双端使用的连接ID。每个EndPoint都使用接收到的包的源连接ID来标示自己接收使用的目的连接ID，在接收到包之后，EndPoint使用接收到的源连接ID来设置发送数据包的目的连接ID。    
当客户端在接收到服务的初始包或者重试包前，就发送初始化包，那么目的连接ID的值很可能是未知的，但是长度必须至少为8字节。在从服务器接收到数据包之前，客户端必须使用相同的值来发送数据包，除非它放弃连当前的连接尝试并开始新的连接尝试。初始包的目的地连接ID用于确定初始包保护密钥。    
客户机使用其选择的值填充源连接ID字段，并设置SCID Len字段以指示长度。    
第一个发送的0-RTT包使用与客户端初始包相同的目的连接ID和源连接ID。    
一旦从服务器接收到初始或重试数据包，客户端使用服务器提供的源连接ID作为后续数据包(包括任何后续的0-RTT数据包)的目标连接ID。这意味着客户端在建立连接期间可能会更改两次目标连接ID，一次在响应重试时，一次在响应来自服务器的第一个初始数据包时。一旦客户机从服务器接收到初始数据包，它必须丢弃它接收到的具有不同源连接ID的任何数据包。    
客户端只能在响应接收到服务器的第一个初始包或者重试包时，修改目的连接ID的值。而服务器必须根据初始化包设置目的连接ID，任何额外的修改都是不允许的。如果这些类型的后续数据包包含不同的源连接ID，则必须丢弃它们。这避免了无状态处理建立连接ID时，出现多个初始数据包可能出现的问题。
连接ID可以在连接的生存周期内修改，但是只针对连接迁移(第九节)，详情请看5.1.1节。
## 7.3 传输参数
在连接建立确认期间，双端进行传输参数的设定。这些声明是由每个EndPoint单方面作出的，EndPoints需要遵守这些参数所隐含的限制；每个参数的描述都包括处理它的规则。    
关于传输参数的编码细节见18节。     
QUIC在加密握手中包含编码的传输参数 ，一旦握手完成，对端声明的传输参数是可用的。每个EndPoint都验证对端声明的传输参数的值。    
第18.2节中包含了每个传输参数的定义。    
EndPoint必须将接收到无效的传输参数视为**TRANSPORT_PARAMETER_ERROR**连接错误。    
EndPoint禁止多次发送传输参数，EndPoint应将接收到的重复传输参数视为**TRANSPORT_PARAMETER_ERROR**连接错误。
如第17.2.5节所述，如果服务器发送了一个重试包以启用重试验证，则必须包含**original_connection_id**传输参数(第18.2节)。
### 7.3.1 0-RTT的传输参数
EndPoints需要存储服务器设置的传输参数的值，并将其设置到后续连接中发送到对端的任何0-RTT包中，但是设置了显示排除的参数除外。记录的传输参数将应用于新连接，直到握手完成客户端开始发送1-RTT包。一旦握手完成，客户端将使用握手中建立的传输参数。    
定义一个新的传输参数(7.3.2节)时**一定要**指定其必须，可以，或者禁止应用于0-RTT包。客户端不需要存储其不能处理的参数参数。    
客户端**禁止**存储以下参数：**original_connection_id**, **preferred_address**, **stateless_reset_token**,
**ack_delay_exponent**，和**active_connection_id_limit**，客户端一定要使用握手中设置的最新传输参数的值，如果服务端没有指定，则只用默认值。    
客户端尝试发送0-RTT包时**一定**要记录所有的服务器使用的传输参数，服务器可以记住这些传输参数，或者在上下文中存储完整的副本，并在接受0-RTT数据时恢复信息，服务器使用传输参数来确定是否接受0-RTT数据。    
如果服务端接受0-RTT数据包，则服务端**禁止**减少限制或修改任何和客户端0-RTT包中冲突的参数值。特别是，接受0-RTT数据的服务器缩减以下参数值(见18.2节)：    
+ **initial_max_data**
+ **initial_max_stream_data_bidi_local**
+ **initial_max_stream_data_bidi_remote**
+ **initial_max_stream_data_uni**
+ **initial_max_streams_bidi**
+ **initial_max_streams_uni**    

忽略或设置某些传输参数的为零会导致虽然启用0-RTT数据，但不可用。部分保证应用层数据发送的传输参数**应该**在0-RTT包中设置为非0值，这包括：    
+ **initial_max_data**
+ **initial_max_streams_bidi**
+ **initial_max_stream_data_bidi_remote**
+ **initial_max_streams_uni**
+ **initial_max_stream_data_uni**

如果传输参数的值不受支持，服务器必须拒绝0-RTT数据或中止握手。    
当使用0-RTT发送帧时，客户端**应该**只使用记录的传输参数，特别是，不要使用从接收到1-RTT包中获取到的新的传输参数值。来自握手的传输参数的更新值仅适用于1-RTT数据包。例如，存储的传输参数的流控制限制(旧的值)适用于所有0-RTT包，即使这些值通过握手或在1-RTT包中增加。服务器可能会将0-RTT中更新的传输参数的使用视为**PROTOCOL_VIOLATION**类型的连接错误。

### 7.3.2 新的传输参数
新的传输参数可以用来协商新的协议行为，EndPoint必须忽略那些它不支持的传输参数。因此，缺少传输参数将禁用使用该参数协商的任何可选协议的功能。如18.1节所述，为了保证必须的协议功能，保留了一些强制的传输参数。    
可根据第22.2节中的规则注册新的传输参数。    
## 7.4 加密消息缓冲
实现上需要维护一个缓存存储失序接收的**CRYPTO**数据。由于**CRYPTO**帧没有流量控制，对端可能会要求缓存无限量的数据。    
实现必须支持缓存至少4096 bytes的无序**CRYPTO**帧数据，EndPoint可能在握手阶段允许缓存更多的数据。握手过程中的更大限制可能允许交换更大的密钥或凭据。EndPoint的缓冲区大小不需要在连接的生命周期内保持不变。    
在握手阶段无法缓存**CRYPTO**会导致连接失败。如果在握手过程中数据超过了EndPoint的缓存大小，则可以临时扩展其缓存区以完成握手。如果EndPoint不选择扩大其缓存区，则要以**CRYPTO_BUFFER_EXCEEDED**终止此连接过程。    
一旦握手完成，如果EndPoint无法缓存**CRYPTO**帧中的所有数据，它可能会丢弃该帧和将来接收到的所有**CRYPTO**帧，或者使用CRYPTO_BUFFER_EXCEEDED错误码关闭此连接。必须回复ACK确定包含**CRYPTO**帧的数据包，因为即使将其丢弃，也算被中断接收和处理过。   

## 8 地址验证
QUIC使用地址验证来避免被流量放大攻击，在这种攻击中，发送到服务器的包具有受害者的伪造地址信息，如果服务器响应了很多或者较大的数据包，则攻击者可以发送更多的数据到受害主机上。针对放大攻击的主要防御措施是验证EndPoint是否能够在其声明的传输地址处接收数据包。地址验证在连接建立期间(见第8.1节)和连接迁移期间(见第8.2节)进行。

## 8.1 连接建立期间的地址验证
连接建立隐式地为两个端点提供地址验证。特别是由握手密钥保护的包和客户端接收到服务器的初始化包。一旦服务器成功地处理了来自客户端的握手包，它就可以认为客户端地址已经过验证。    
在验证客户端地址之前，服务器发送的字节数**不得**超过其接收bytes数的三倍。这限制了使用欺骗源地址伪装的放大攻击的规模。在计算此限制时，服务器只计算成功处理的数据包的大小。    
客户端必须确保包含初始数据包的UDP数据报的UDP有效负载至少为1200 bytes，根据需要填充数据报中的数据。发送填充数据报可以确保服务器不受放大限制的过度限制。   
数据包丢失，特别是来自服务器的握手包的丢失，可能导致客户端没有数据需要发送而服务器达到上述限制而无法发送数据的情况。为了避免这种握手死锁产生，客户端**必须**在超时时发送数据包，详情见[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)。如果客户端没有要重新传输的数据，也没有握手密钥，它**必须**以至少1200字节的UDP数据报重新发送初始数据包。如果客户端有握手密钥，则**应该**发送一个握手包。 
服务器可能希望在加密握手之前验证客户端的地址。QUIC在初始数据包中使用token在完成握手之前提供地址验证。此token在连接建立期间通过重试数据包(见第8.1.2节)或在以前的连接中使用新的**NEW_TOKEN**帧(第8.1.3节)传递给客户端。    
除了在地址验证之前设置的发送限制之外，服务器还受到拥塞控制设置的限制，以限制了可以发送的内容。客户端仅受拥塞控制的约束。

### 8.1.1 Token构造
在**NEW_TOKEN**帧或重试包中发送的令牌的构造必须允许服务器标识它是如何提供给客户端的。这些token在同一字段中携带，但需要在服务器中进行不同的处理。    

### 8.1.2 使用重试包地址验证
在接收到客户端的初始数据包后，服务器可以通过发送包含token的重试包(第17.2.5节)来请求地址验证，客户端在接收到该重试数据包后，必须在该连接之后发送的所有初始数据包中携带此token。服务器在对包含token的初始化包处理时，可以选择终止连接或者继续处理。    
只要攻击者不能够为自己的地址生成一个有效的令牌(见8.1.4节)，并且正常客户端能够返回该令牌，那就向服务器证明了它收到了token。    
服务器还可以使用重试包来延迟建立连接的状态和处理开销。比如提供一个不同的连接ID，以及强制使用第18.2节中定义的**original_connection_id**传输参数，或者从客户端接收原始的初始数据包。提供一个不同的连接ID还可以让服务器控制后续数据包的路由方式。这可用于将连接定向到其他服务器实例。    
如果服务器接收到一个不被保护的初始包携带了无效的重试token，它知道客户端不会再接受另一个充实token，服务器可以丢弃这样的数据包，从而导致客户端超时检测握手失败，这可能会对客户端造成很大的延迟。服务器**可以**在不验证token的情况下继续进行连接，但服务器**不能**将客户端地址视为已验证。如果一个服务器选择终止继续握手过曾，它应该立即以**INVALID_TOKEN**错误关闭连接(第10.3节)。请注意，此时服务器尚未为连接建立任何状态，因此不会进入关闭期。  
图5显示了使用重试包的流程:

```
Client                                                               Server
Initial[0]: CRYPTO[CH] ->
                                                             <- Retry+Token
Initial+Token[1]: CRYPTO[CH] ->
                                              Initial[0]: CRYPTO[SH] ACK[1]
                                    Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                              <- 1-RTT[0]: STREAM[1, "..."]
                           图 5: 重试握手示例
```

### 8.1.3 未来连接的地址验证
服务器**可以**在一个连接中给客户端一个地址验证token，以用于之后的连接。地址验证对于0-RTT尤其重要，因为服务器可能会向客户端发送大量数据以响应0-RTT数据。    
服务端通过**NEW_TOKEN**帧(19.7节)发送给客户端token，该token可用于将来的地址验证。客户端通过在初始化包中携带此token以提供未来连接的地址验证能力。客户端**必须**在它发送的所有初始数据包中包含令牌，除非服务端的重试包将令牌替换为新的令牌。客户端不得将重试包中提供的token用于将来的连接。服务器**可以**丢弃任何不携带预期token的初始包。    
与立即使用的重试数据包创建的token不同，在**NEW_TOKEN**帧中发送的令牌可能会在经过一段时间后使用。因此，令牌应该有一个过期时间，可以是显式的过期时间，也可以是可用于动态计算过期的时间戳。服务器可以存储过期时间，也可以在令牌中以加密的形式包含它。    
发送token的**NEW_TOKEN**的帧**禁止**携带任何关于本机的连接信息以防止链路上的网络阶段截取，除非它是加密的。例如，它不能包含以前的连接ID或地址信息。服务器必须确保它发送的每一个**NEW_TOKEN**帧在所有客户端中都是唯一的，除了那些被发送来修复先前发送的**NEW_TOKEN**帧丢失的客户端。    
两个不同连接上的客户机端口号不太可能相同；因此验证端口不太可能成功。    
从**NEW_TOKEN**接收到的token适用于被认为是授权连接的任何服务器(例如，证书中包含的服务器名称)。当持有一个可用而未使用的token连接服务器时，应该在它发送的初始包中携带该token。包含toekn可以让服务器进行地址验证而不必额外的交互往返。客户端**禁止**使用不适用于某服务器的token去创建连接，除非客户端知道发出token的服务器和客户端连接的目标服务器正在共同管理令牌。客户端可以使用以前连接到该服务器的令牌。     
想要中断与服务器的身份连续性验证的客户端可以丢弃使用**NEW_TOKEN**帧提供的令牌。相比之下，在重试数据包中获得的token必须在连接尝试期间立即使用，并且不能在随后的连接尝试中使用。    
客户端不应在不同的连接尝试中重复使用**NEW_TOKEN**令牌。复用token在连接迁移中使用，见9.5节。    
客户端可能会从一个连接上接收到多个token，除非被显示阻止，任何token都可以被用到任何连接尝试中，服务器可以发送额外的token去开启多个连接尝试的地址验证，或者替换将要失效的token。这对客户端而言，发送最近收到的未使用的token最有可能生效。虽然保存和使用旧的token没有负面影响，但是客户端可以认为旧的token对地址验证是不起作用的。    
当服务器接收到一个携带token的初始包时，**必须**对token进行验证，除非服务器已经完成了地址验证。如果token无效，则服务器应像客户端没有经过地址验证一样继续操作，包括可能发送重试包。如果token验证通过，则服务器**应该**继续握手流程。    
注意：将客户端视为未验证而不是丢弃数据包的原因是，客户端可能已经在前一个连接的**NEW_TOKEN**帧接收到了新的token，如果服务器丢失了状态，则可能无法验证该token，如果直接丢包，则可能导致未来的连接失败。服务器应该以不同的方式对带有token的**NEW_TOKEN**帧和重试包进行编码，并对后者进行更严格的验证。    
在无状态设计中，服务器可以使用加密的和经过身份验证的token将信息传递给客户机，服务器稍后可以恢复这些信息并使用这些token验证客户端地址。token没有集成到加密握手中，因此它们没有经过身份验证。例如，客户端可能会重用一个token，为了避免因此而被攻击，服务器可以将token的使用限制为仅持有验证客户端地址所需的信息。    
在相同版本时，客户端可能使用从一个连接上获取到的token以用于之后任何的连接尝试。当选择了一个token时，客户端不需要考虑任何其他的连接属性，包括可能的应用程序协议，会话或其他的连接属性选择。    
攻击者可以重放token，将服务器用作DDoS攻击的放大器。为了防止此类攻击，服务器应确保在重试包中发送的token仅在较短时间内被接受。在**NEW_TOKEN**帧(见19.7节)中提供的令牌需要更长的有效期，但不应在短时间内多次接受。如果可能，鼓励服务器所有令牌只使用一次。    

### 8.1.4 地址验证token完整性
地址验证的token一定要非常难被猜到。在token中应该包括足够多的随机值，但这取决于服务器能否记住发送给客户端的该值。   
基于token的方案允许服务器将与验证相关的任何状态放到客户端。为了使这个设计有效，token必须保证完整性，以防止被客户端伪造和篡改。如果没有完整性保护，恶意的客户端可以生成或猜测服务器将接受token值。只有服务器需要访问token的完整性保护密钥。    
并不需要为token定义明确的格式，因为只有生成它的服务器使用它。token可以包括有关所声明的客户端地址(IP和端口)信息、时间戳以及服务器将来验证token所需的任何其他补充信息。    

## 8.2 路径验证
EndPoint的地址迁移期间使用路径验证(参见第9节和第9.6节)，从新的地址验证对等机的可访问性。在路径验证中，EndPoint测试特定本地地址和特定对等地址之间的可达性，其中地址是IP地址和端口的两元组。    
路径验证测试包(Path_CHALLENGE)可以发送到路径上的对等方，也可以从路径上的对等方接收(PATH_RESPONSE)。重要的是，它验证从迁移端点接收的数据包是否携带伪造的源地址。    
任何EndPoint都可以随时使用路径验证。例如，EndPoint可能会检查对端在一段静止时间之后是否仍然拥有它的地址。    
路径验证不是作为NAT遍历机制设计的。尽管这里描述的机制对于创建支持NAT遍历的NAT绑定可能是有效的, 但是有效的NAT遍历需要额外的同步机制，这里没有提供这些机制。    
端点可以将用于路径验证的**PATH_CHALLENGE**和**PATH_RESPONSE**帧与其他帧捆绑在一起。具体地说，端点可以使PMTU发现填充包携带**PATH_CHALLENGE**，或者端点可以将**PATH_RESPONSE**与自己的**PATH_CHALLENGE**捆绑在一起。

当探测新路径时，端点可能希望确保它的对端具有可用于响应的未使用的连接ID。Endpoint可以在相同的包中发送**NEW_CONNECTION_ID**，**PATH_CHALLENGE**帧，以确保对端有可使用的连接ID。
## 8.3 启动路径验证 
要启动路径验证，端点将发送一个**PATH_CHALLENGE**帧，其中包含要验证的路径上的随机负载。Endpoint可能要发送多个**PATH_CHALLENGE**帧来避免包丢失，但是Endpoint不应该将多个**PATH_CHALLENGE**帧放到同一个包中。Endpoint不发送**PATH_CHALLENGE**的频次不能比初始化包高，以确保连接迁移在新路径上的负载不会超过建立新连接的负载。    
端点**必须**在每个**PATH_CHALLENGE**帧中使用不可预测的数据，以便它可以将对等方的响应与相应的**PATH_CHALLENGE**相关联。

## 8.4 路径验证响应
在接收到**PATH_CHALLENGE**帧时，Endpoint必须用**PATH_CHALLENGE**帧中的数据以**PATH_RESPONSE**帧响应。Endpoint在响应**PATH_CHALLENGE**帧时**不能**发送多个**PATH_RESPONSE**帧(见13.3节)。对端应根据需要发送更多的**PATH_CHALLENGE**帧，以引发额外的**PATH_RESPONSE**帧。    

## 8.5 路径验证成功
当接收到包含在上一个**PATH_RESPONSE**中发送的数据的**PATH_CHALLENGE**时，新地址被视为有效。收到包含**PATH_CHALLENGE**帧包确认地址验证是不充分的，因为对端可能会恶意的伪造。    
注意，不同本地地址的接收不会导致路径验证失败，因为这可能是转发包(见第9.3.3节)或错误路由的结果。将来可能会收到有效的**PATH_RESPONSE**响应。

## 8.6 地址验证失败
只有当尝试验证路径的Endpoint放尝试时，路径验证才会失败。    
Endpoint不应该基于定时器进行路径验证。一旦设置了定时器，实现时新路径的往返时间就可能会比源路径更长。推荐使用[QUIC-RECOVERY]中定义的当前探测超时(PTO)或初始超时(即2*KINITALRTT)的三倍值，其定义为：     
validation_timeout = max(3*PTO, 6*kInitialRtt)    

请注意，Endpoint可能会接收到包含新路径上其他帧的数据包，但成功的路径验证需要具有适当数据的**PATH_RESPONSE**帧。    
当Endpoint放弃路径验证时，它确定路径不可用。但这并不一定意味着连接失败，Endpoint可以根据需要继续通过其他路径发送数据包。如果没有路径可用，Endpoint可以等待一个新的有效路径或者关闭这个连接。    
除了失败之外，路径验证可能会因为其他原因而被放弃。主要是，如果在旧路径上进行路径验证时启动到新路径的连接迁移，就会发生这种情况。    

## 9 连接迁移
连接ID的使用允许连接迁移到其他地址，例如Endpint迁移到新的网络。本节描述Endpoint迁移到新地址的过程。   
QUIC的设计依赖于Endpoint在握手期间保持一个稳定的地址，Endpoint**禁止**在握手完成之前进行连接迁移，见4.1.2节。    
如果对端在握手期间发送了**disable_active_migration**传输参数，则本地Endpoint禁止在其他地址上发送数据和主动启动连接迁移。而发送了这个传输参数的Endpoint如果检测到对端已迁移到另一个网络，则必须在不生成无状态重置的情况下丢弃该路径上的传入数据包，或者继续进行路径验证并允许该对端进行迁移。生成无状态重置或关闭连接将允许网络中的第三方通过欺骗或以其他方式操纵观察到的流量来关闭连接。    
并非所有对端地址的更改都是有意或主动的迁移。对端可能会经历NAT重新绑定: 由于中间设备(通常是NAT)而导致的地址更改，为流分配新的传出端口甚至新的传出IP地址。如果端点检测到对等地址的任何更改，则必须执行路径验证(第8.2节)，除非它以前验证过该地址。    
当Endpoint没有可用于发送数据包的已验证路径时，它**可能**会放弃连接状态。能够进行连接迁移的Endpoint可能会等待新路径变为可用，然后才放弃连接状态。    
本文档限制了连接到新客户端地址的迁移，但第9.6节中所述的情况除外。客户端负责启动所有迁移。服务器不会向客户端地址发送非探测数据包(见第9.1节)，除非它们看到来自该地址的非探测数据包。如果客户端从未知服务器地址接收数据包，则该客户端必须丢弃这些数据包。

## 9.1 检测新路径
在将连接迁移到新的地址之前，端点可以使用路径验证(第8.2节)从新的地址探测对端的可达性。路径验证失败仅仅意味着新路径不能用于此连接。除非没有有效的替代路径，否则验证路径失败不会导致连接结束。  
Endpoint使用一个新的连接ID来处理从新的本地地址发送的探测(见9.5节的讨论)，因此当Endpoint使用一个新的本地地址时需要确定对端至少有一个可以使用的连接ID，这可以通过在探测中发送包含**NEW_CONNECTION_ID**帧来确认。     
从对端接收到**PATH_CHALLENGE**帧表示该对端正在探测路径上的可达性。此时应该以**PATH_RESPONSE**作为响应(8.2节)。    
**PATH_CHALLENGE**, **PATH_RESPONSE**, **NEW_CONNECTION_ID**, 和**PADDING**都是探测帧，而其他类型的帧都是非探测帧。只包含探测帧的包是“探测包”，而包含任何其他帧的包是“非探测包”。   

## 9.2 启动连接迁移
Endpoint可以通过从其他本地地址发送非探测帧而降连接迁移到新的地址。在连接建立期间，没有Endpoint都验证其对端的地址。因此，迁移的Endpoint可以知道对端在哪个地址上等待接收。所以Endpoint可以迁移到一个新的地址而不用首次旧验证对端的地址。    
当连接迁移时，新的路径可能不支持Endpoint当前的发送速度，因此，Endpoint会重置它的拥塞控制，见9.4节。    
新的网络路径可能没有相同的ECN能力，因此，端点验证ECN能力，如第13.4节所述。    
接收在新路径上发送的数据的确认可以作为对端迁移到新地址的证据。由于确认包可以在任何路径上被接收，新路径上的访问可达性时不确定的。为了在新路径上建立访问可达性，端点可以同时在新路径上启动路径验证(第8.2节)。    

## 9.3 响应地址迁移
从对端新的地址上接收到包含非探测帧的包，表明对端已经迁移到了一个新的地址。    
在这种包的响应中，端点**必须**开始向新的对等地址发送后续数据包，并且**必须**启动路径验证(第8.2节)，以验证对端对未验证地址的所有权。    
端点可以将数据发送到未经验证的对端地址，但必须按照第9.3.1节和第9.3.2节中的描述防止潜在攻击。如果地址最近被验证过，则可以跳过对端地址的验证过程。特别是，如果Endpoint在检测到某种形式的伪迁移后返回到先前验证的路径，则跳过地址验证并恢复丢失检测和拥塞状态可以减少此类恶意攻击对性能的影响。    
端点只改变它发送数据包的地址，以响应编号最高的非探测数据包。这可以确保Endpoint在接收到重新排序的数据包的情况下不会将数据包发送到旧的对等地址。    
一旦迁移到了发送非探测包的地址，Endpoint可以放弃对其他地址的任何路径验证。    
从新的对端地址接收数据包可能是在对端重新绑定NAT的导致的。    
在验证一个新的客户端地址之后，服务器应该向客户机发送新的地址验证token(第8节)。

### 9.3.1 对端地址欺骗
有可能是对端端欺骗其源地址，导致Endpoint向主机发送过多的非期望数据。   
如果正常的Endpoint需要发送的数据比欺骗迁移的Endpoint更多，则连接迁移可能被用来进行流量放大攻击。    
如第9.3节所述，Endpoint需要验证对端的新地址，以确认端方拥有新地址，确实产生了连接迁移。在对端的地址被认为有效之前，Endpoint必须限制它向该地址发送数据的速率。Endpoint在每个评估的往返时间(kMinimumWindow，如[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)中定义)发送的数据不得超过最小拥塞窗口值。在没有这个限制的情况下，Endpoint有可能被用来对不知情的受害者进行拒绝服务攻击。注意，由于Endpoint不会有任何到该地址的往返时间测量值，所以估计值应该是默认的初始值（请参见[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27))。    
另外，如果Endpoint跳过了对对端地址的路径验证，那就不需要再限制发送速率。    
### 9.3.2 路径地址欺骗
在路径上的攻击者可以通过复制和转发具有欺骗地址的数据包，在原始数据包之前到达，从而导致虚假的连接迁移。具有欺骗地址的数据包将被视为来自迁移的新连接，而原始数据包将被视为重复数据并被丢弃。在假迁移之后，地址的验证将失败，因为虚假地址处的实体没有必要的加密密钥来读取或响应发送给它的**PATH_CHALLENGE**帧(即使它愿意)。     
为了防止连接因这种错误的迁移而失败，当验证新的对端地址失败时，端点必须恢复为使用最后验证的对端地址。    
如果Endpoint没有关于最后验证的对端地址的状态，它必须通过放弃所有连接状态来静默地关闭连接。这会导致连接上的新数据包被一般性地处理，例如，Endpoint可以发送无状态重置以响应任何进一步的传入包。    
请注意，从合法对等地址接收具有更高数据包编号的数据包将触发另一个连接迁移。这个将导致错误迁移地址的验证被放弃。    

### 9.3.3 非路径包转发
能够观察到数据包的位于传输路径上的攻击者可能会将真实数据包的副本转发到端点。如果复制的数据包在真正的数据包之前到达，这将被认为是NAT重新绑定。真正的数据包会被认为是副本而被丢弃。如果攻击者可以持续的抓发数据包，则可能导致连接迁移到攻击者的路径上。这将使位于传输路径上的攻击者可以观察或丢弃所有后续的数据包。    
与9.3.2节描述的攻击不同，这里的攻击者可以确保新的路径被验证。    
这种类型的攻击依赖于攻击者使用的路径大约与端点之间的直接路径传输一样快或者更快。如果发送的数据较少或者丢包与尝试攻击同时发生，则这类的攻击可能会更容易生效。    
如果在源路径上接收到非探测数据包使得接收数据包编号增大，则会导致连接迁移回源路径。在该路径上增加数据包交换会减少被攻击的可能性。因此，减轻这种攻击依赖于触发包的交换。   
在明显迁移的响应中，端点必须使用**PATH_CHALLENGE**帧验证先前活动的路径。这会导致在该路径上发送新的数据包。如果该路径不再有效，则验证尝试会超时和失败。如果该路径依然有效但是不再被使用，则验证会成功，但是该路径只会发送探测数据包。    
在活动路径上的Endpoint接收到**PATH_CHALLENGE**应该发送非探测数据包作为响应。如果非探测数据包在攻击者复制的数据包之前到达，则会导致连接迁移回活动的源路径上。任何后续迁移到其他路径的尝试都会重新启动这个过程。    
这种机制是不完美的，但这不是一个严重的问题。如果尽管多次尝试使用源路径，但是攻击者路径依然比源路径传输数据快，则无法区分这是攻击还是路由改进。    
端点还可以使用启发的方式来提高对这种攻击的检测。例如，如果最近在旧路径上接收到数据包，则不可能是NAT重新绑定，类似地，在IPv6路径上很少会进行重新绑定。端点也可以查找重复的数据包。而且，连接ID的更改更可能表示有意的连接迁移，而不是攻击。

## 9.4 丢失检测和拥塞控制
