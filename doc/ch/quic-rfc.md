# QUIC : 基于UDP的多路复用安全传输

## 摘要
本文描述了QUIC传输协议的核心部分，附件文档中描述QUIC的丢包检测，拥塞控制，以及TLS密钥使用。   


## 读者须知   

本草案在QUIC工作组的邮件列表中讨论，邮件见https://mailarchive.ietf.org/arch/search/?email_list=quic   
工作组信息见https://github.com/quicwg   
本草案的源码和问题列表见https://github.com/quicwg/base-drafts/labels/-transport   


## 目录

## 1.简介
QUIC是一种多路复用和安全的通信协议   
它提供以下特性：   
+ 流的复用   
+ 连接级别的流量控制   
+ 低延迟的建连耗时   
+ 连接迁移和NAT重新绑定的弹性   
+ 验证和加密的头部信息和负载  
    
QUIC底层使用UDP以避免客户端操作系统和通信中间设备的改动。QUIC认证所有的头部信息，加密传输的大部分数据，包括它的控制信号，以避免对通信的中间设备产生依赖。     
### 1.1文档结构
本文描述了QUIC协议的核心部分，本文结构如下：   
+ Stream是QUIC提供的基础服务抽象
  - 第2节 描述与Stream相关的核心概念
  - 第3节 提供Stream状态的参考模型
  - 第4节 概述了流量控制的操作
+ 连接是QUICEndpoint通信过程中的实体
  - 第5节 描述了连接相关的核心概念   
  - 第6节 描述了版本协商过程   
  - 第7节 是关于连接建立过程的细节   
  - 第8节 指点关键的服务拒绝环节机制   
  - 第9节 描述了Endpoint如何将连接迁移到另一个新的网络环境中   
  - 第10节 列出了中断连接时的所有选项   
  - 第11节 提供对错误处理的一般指导   
+ 包和帧是QUIC通信的基本单元
  - 第12节 描述了关于包和帧的关键概念   
  - 第13节 定义了传输，重传和确认的模型   
  - 第14节 定义了包大小管理的规则   
+ 最后，展示了一些QUIC编码的细节
  - 第15节 版本   
  - 第16节 整型编码   
  - 第17节 包头   
  - 第18节 传输参数   
  - 第19节 传输帧   
  - 第20节 错误定义    
附录文件描述了本文未尽的一些QUIC细节，包括[拥塞控制](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)，以及[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)。   

### 1.2 术语和定义
关键字 "**一定**", "**禁止**", "**要求**", "**应该**", "**不应**", "**推荐**", "**不推荐**", "**可以**", "**可选**"的使用与[BCP14](https://tools.ietf.org/html/bcp14) [RFC2119](https://tools.ietf.org/html/rfc2119) [RFC8174](https://tools.ietf.org/html/rfc8174)相同。   
本文常用的术语定义如下：    
QUIC：本文描述的传输协议，QUIC只是一个名字，而不是一个缩略词。    
QUIC包：QUIC可以封装进UDP数据包的完整处理单元，多个QUIC包可以被放到一个UDP数据包中。   
ACK引发包：除了ACK，PADDING，CONNECTING外，其他包都包含的一种QUIC包，它使得接受方发送接受确认。    
乱序包：一种数据包，它的编号并不是接受方最大编号加一，当包传输延迟或者该包之前的包延迟或丢失，都可能造成包的乱序到达。   
Endpoint：QUIC连接中生成，接收，处理QUIC包的实体。QUIC中只有客户端和服务器两种Endpoint。   
客户端：主动建立连接的Endpoint。    
服务器：接收连接请求的Endpoint。     
Address：ip版本，ip 地址，UDP协议，和UDP端口的元组代表了网络通信的一个终端。    
连接ID：在EndPoint中用一个唯一的ID来标识一个连接，每个EndPoint发送包到对端的时候都会将这个值写入包内。   
Stream：在QUIC连接之上，传输有序数据的单向或双向通道，一个QUIC连接可以同时携带多个Stream。   
应用：使用QUIC发送和接收数据的实体。   
   
### 1.3 符号约定   
本文使用的包和帧的格式定义类似Section 3.1 of [RFC2360](https://tools.ietf.org/html/rfc2360#section-3.1)，约定如下：   
[x]：表示x是可选的   
x (A): 表示x长度为A bits   
x (A/B/C): 表示x的长度为A，B或C bits   
x (i)…：表示x使用变长编码   
x (*): 表示x是变长的   

## 2 Streams   
Stream 是QUIC提供给应用的轻量级有序数据传输的功能抽象。Stream 可以是单向的也可以是双向的，QUIC单向流的另一种观点是几乎无限长的“消息”抽象。   
Streams可以被创建用来发送数据，与Streams管理相关的其他过程(结束，取消，管理流控)，都是为了施加最小的开销而设计的。比如，一个Stream帧可以创建，关闭Streams或者携带数据。Streams也可以是长存的，直到QUIC连接结束。   
Steams可以被任意一端EndPoint创建，可以交替着和其他Streams一起发送数据，也可以被取消。QUIC没有提供任何实际的机制来保证不同Streams的数据传输有序。不同Streams间的数据是乱序传输的。   
QUIC允许操作任意数量的Streams，在任意一个Streams上发送任意数量的数据，这取决于流控和流量限制。   
### 2.1 Steam的类型和ID
Streams可以是单向或双向的，单向的Streams只能往一个方向发送数据：从Stream的发起方到对端。双向的Stream可以在两个方向上发送数据。   
在一个连接内，一个数字值作为Stream ID来标识一个Stream，Stream ID是一个62Bit长度的整数，它在一个连接内是独特唯一的。Stream ID按照变长整数进行编码，QUIC EndPoint **禁止**在一个连接内复用 Stream ID。   
Stream ID的最后一个bit位用来标识发起方，客户端发起的Stream，设置为0，服务器发起的Stream，设置为1。   
Stream ID的倒数第二个bit位用来标识Stream数据发送方向，双向时为0，单向时为1。   
Stream ID最后两位的bit组合共有四种类型，定义如下：   
| Bits | Stream Type      |
| :--: | :--------------: |
| 0x0  | 客户端发起, 双向 |
| 0x1  | 服务端发起, 双向 |
| 0x2  | 客户端发起, 单向 |
| 0x3  | 服务端发起, 单向 |
   
在每种类型中，Stream ID都是递增创建的，无序使用的流ID会导致该类型的所有流同时打开编号较低的流ID(存疑)。    
客户端打开的第一个双向流的Stream ID为0。     
    
### 2.2 发送和接收数据    
Stream帧封装应用发送的数据，一个EndPoint使用Stream ID和偏移量字段来使数据有序。    
EndPoint一定保证将Stream 数据有序的传输给上层应用，这就需要EndPoint缓存无序到达的数据，直到流量控制的上限。     
QUIC对Stream乱序传输的数据并没有特别的考虑，但是，在实现上也可以将乱序的数据透传给上层应用。   
一个EndPoint可能会在一个Stream上接收到多次相同偏移的数据，其中一些早已经接受过的数据可以丢弃掉，当数据发生重传时，它的偏移量**禁止**被修改。当一个EndPoint在一个Stream上相同偏移接收到不同数据时，会视为连接错误：PROTOCOL_VIOLATION。   
对QUIC而言，Stream是独立的有序传输数据的抽象，当数据被传输、丢包后重新传输或传送到应用程序时，Stream帧边界不期望被持有。   
EndPoint**禁止**在任何还没有被对端设置流控限制的Stream上发送数据，流控的详细内容见第四节。   
    
### 2.3 Stream优先级
如果分配给流的资源的优先级正确，Stream 复用可以对应用程序性能产生显著影响。    
QUIC并没有自己的信息优先级机制，它依赖使用QUIC的上层应用来设置不同的优先级。    
QUIC的实现**应该**提供一种方式来使上层应用可以设置Stream的优先级，并且**应当**使用应用层的信息来设置不同Stream的传输优先级。

### 2.4 Stream所需操作
应用层在使用QUIC Stream时，**一定**要执行某些操作，本文并没有定义具体的API，但是这个版本的QUIC任何实现都应该提供本节中描述的Stream操作。   
在Stream发送部分，应用层应该能够：   
+ 写数据，了解何时流控信息被设置然后开始发送写入的数据。   
+ 结束Stream(完整的终止)，将发送设置了FIN标识的Stream帧。   
+ 重置Stream(突然终止)，当Stream尚未处于终端状态时，发送RESET_STREAM帧。   
   
在接收端。应用程序能够：   
+ 读取数据。   
+ 终止读取并且请求关闭，可能会发送STOP_SENDING帧。   
   
Stream的状态改变需要通知到应用层，包括：   
- 对端打开或关闭了一个Stream
- 对端终止读取一个Stream
- 新的数据可读
- 流控引起的数据可写或不可写 

## 3 Stream状态
本节讲述Stream的发送或接收组件。有两种状态机：   
+ 数据发送端
+ 数据接收端
  
单向的流直接使用合适的状态机，但是双向的Stream每个端都有两种状态机。在大多数情况下，单向或双向Stream对状态机的使用都是相同的。双向Stream的打开要复杂一些，因为不论是接收端还是发送端，都需要打开两个方向的数据传输。   
一个EndPoint**必须**在一个Stream type上递增的创建Stream ID。   
注意： 这些状态的信息量很大，本文使用Stream状态来描述何时以及如何发送不同类型的帧的规则，以及接收到不同类型帧时预期的反应。理解了这些状态机对实现QUIC非常有用。实现时可以定义不同的状态机，只要其实现与本文定义一致。   

### 3.1 Stream的发送状态
下图展示了Stream发送数据到对端的部分状态： 
```
    o    
    | 创建 Stream (Sending)    
    | 对端创建双向Stream    
    v    
+-------+    
| Ready | Send RESET_STREAM    
|       |-----------------------.    
+-------+                       |    
    |                           |       
    | Send STREAM /             |    
    | STREAM_DATA_BLOCKED       |    
    |                           |    
    | Peer Creates              |    
    | Bidirectional Stream      |    
    v                           |    
+-------+                       |    
| Send  | Send RESET_STREAM     |    
|       |---------------------->|    
+-------+                       |    
    |                           |    
    | Send STREAM + FIN         |    
    v                           v    
+-------+                   +-------+
| Data  | Send RESET_STREAM | Reset |
| Sent  |------------------>| Sent  |
+-------+                   +-------+
    |                           |
    | Recv All ACKs             | Recv ACK
    v                           v
+-------+                   +-------+
| Data  |                   | Reset |
| Recvd |                   | Recvd |
+-------+                   +-------+
```
在发送端Endpoint启动(客户端类型为0和2，服务端类型为1和3)由应用层打开的Stream，"Ready"状态标识新创建的Stream已经可以接收应用层的数据，这时将数据进行缓存以等待发送。   
发送第一个**STREAM**或**STREAM_DATA_BLOCKED**帧时Stream会进入"Send"状态。 实现上可以将设置Stream ID延后知道Stream发送了第一个STREAM帧进入了"Send"状态，这样可以更好的确认Stream的优先级。   
由对端方发起的双向Stream接收状态机创建后，发送状态机以"Ready"状态开始。   
在"Send"状态，EndPoint通过**STREAM**帧发送或重传数据，EndPoint发送过程遵守由对端创建的流量限制，并一直接收和处理对端的**MAX_STREAM_DATA**帧。如果被连接或Stream的流控限制(见4.1节)导致阻塞数据发送，"Send"状态的EndPoint将发送**STREAM_DATA_BLOCKED**帧。  
当应用层的数据被全部发送完并且发送了**FIN**的**STREAM**帧，Stream的发送端进入"Data Sent"状态，之后EndPoint只会做一些必要的数据重传不再接收新的应用层数据。在这个状态，EndPoint不用检查流控限制或者发送**STREAM_DATA_BLOCKED**帧，但是还是可能会接收到**MAX_STREAM_DATA**帧，直到对端接收到最终的Stream数据，不过此时可以安全的忽略对端发送的**MAX_STREAM_DATA**帧。   
一旦所有的数据都被确认，Stream发送端进入"Data Recvd"状态，这是一个终端状体。   
在"Ready","Send"或"Data Sent"状态，应用层都可以终止Stream的数据发送。或者，EndPoint可能接收到对端的**STOP_SENDING**帧。无论哪种情况，EndPoint都会发送一个**RESET_STREAM**帧，之后进入"Reset Sent"状态。   
EndPoint可能会在Stream上第一次就发送**RESET_STREAM**帧，这将导致Stream打开发送部分并直接进入"Reset Sent"状态。   
一旦**RESET_STREAM**帧被确认，Stream的发送端会进入"Reset Recvd"的终端状态。
### 3.2 Stream的接收状态
下图展示了从对端接收数据的部分状态：
```
    o
    | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
    | Create Bidirectional Stream (Sending)
    | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
    | Create Higher-Numbered Stream
    v
+-------+
|  Recv | Recv RESET_STREAM
|       |-----------------------.
+-------+                       |
    |                           |  
    | Recv STREAM + FIN         |
    v                           |
+-------+                       |
| Size  |   Recv RESET_STREAM   |
| Known |---------------------->|
+-------+                       |
    |                           |
    |Recv All Data              |
    v                           v
+-------+ Recv RESET_STREAM +-------+
| Data  |--- (optional) --->| Reset |
| Recvd |   Recv All Data   | Recvd |
+-------+<-- (optional) ----+-------+
    |                           |
    | App Read All Data         | App Read RST
    v                           v
+-------+                   +-------+
| Data  |                   | Reset |
| Read  |                   | Read  |
+-------+                   +-------+
```
Stream接收部分不跟踪发送部分无法观测的状态，如"Ready"状态。Stream的接收部分跟踪向应用程序传递的数据。   
当接收到对端发送的第一个**STREAM**，**STREAM_DATA_BLOCKED**或**RESET_STREAM**帧(客户端类型为0和2，服务端类型为1和3)时，创建Stream的接收部分。当接收到对端发送的**MAX_STREAM_DATA**，**STOP_SENDING**帧时也会创建Stream的发送部分。Stream发送部分的起始状态是"Recv"。    
当EndPoint创建双向发送Stream的发送部分进入"Ready"时，Stream的接收部分进入"Recv"状态。
当接收到对端发送的**MAX_STREAM_DATA**，**STOP_SENDING**EndPoint打开一个双向Stream。一个未打开的Stream接收到**MAX_STREAM_DATA**表示对端已经打开了Stream并且提供了流控设置。一个未打开的Stream接收到**STOP_SENDING**表示对端希望从这个Stream接收数据。当发送丢包或重传时，这两种包都可能比**STREAM**和**STREAM_DATA_BLOCKED**先到达。    
在Stream创建之前，相同类型的Stream较小Stream ID**一定**被创建过。这样确保Stream的创建顺序在两个EndPoint上是一致的。   
在"Recv"状态，EndPoint接收**STREAM**和**STREAM_DATA_BLOCKED**帧，缓存接收的数据，组合排序然后传输给应用。当数据交付给应用时，可以复用缓存。EndPoint发送**MAX_STREAM_DATA**帧通知对端发送更多的数据。   
当接收到设置了**FIN**的**STREAM**帧时，就获知了Stream的最终大小。Stream的接收部分进入"Size Known"状态。在此状态，EndPoint不再发送**MAX_STREAM_DATA**给对端，只是接收数据。    
一旦Stream接收到了所有的数据，接收部分就进入了"Data Recvd"状态，这可能与接收到**FIN**的**STREAM**进入"Size Known"是同一帧。这之后，任何**STREAM**帧和**STREAM_DATA_BLOCKED**帧都可以被丢弃。    
"Data Recvd"状态维持到应用接收完所有的数据，当所有数据都交付完成时，Stream进入"Data Read"状态，这是一个终端状态。    
在"Recv"或"Size Know"状态接收到**RESET_STREAM**帧，Stream会进入"Reset Recvd"状态，这可能会导致中断向应用交付数据的过程。    
可能在所有数据都接收完成时收到**RESET_STREAM**帧(在"Data Recvd"状态)，同样，也可能在接收到**RESET_STREAM**帧之后又接收到剩余的数据携带帧(在"Reset Recvd"状态)，这时实现可以自己选择处理方式。    
发送**RESET_STREAM**表示EndPoint不再发送数据，然后并没有要求接收到**RESET_STREAM**后中断数据接收。一种实现可能会切断Stream的数据接收过程然后丢弃掉所有已经接收缓存的数据，然后发送**RESET_STREAM**信号(通知上层)。当所有的数据都已经接收并缓存以等待应用读取时，**RESET_STREAM**也可能被忽略，这时Stream的接收部分依然处于"Data Recvd"状态。    
一旦应用接收到Stream重置的信号，Stream的接收部分进入"Reset Read"的终端状态。    
### 3.3 Stream的帧类型
Stream的发送方只会发送三种类型的帧，他们影响着发送端和接收端Stream的状态：   
+ STREAM(见19.8节)
+ STREAM_DATA_BLOCKED(见19.13节)
+ RESET_STREAM(见19.4节)

Stream在终端状态时(“Data Recvd”或“Reset Recvd”)，**禁止**发送任何携带上述类型的帧。一个发送者在发送了**RESET_STREAM**之后，**禁止**再发送**STREAM**或**STREAM_DATA_BLOCKED**帧。因为，在终端状态或者“Reset Sent”状态，由于可能出现的延迟到达，接收端在任何状态都会接收这三种类型的帧。   

Stream的接收端发送:    
+ MAX_STREAM_DATA
+ STOP_SENDING   

Stream的接收端在”Recv”状态时只发送**MAX_STREAM_DATA**帧，接收端在未收到**RESET_STREAM**时，在任何状态都可以发送**STOP_SENDING**帧，也就是除了”Reset Recvd”,”Reset Read”状态。然而，在”Data Recvd”状态发送**STOP_SENDING**并没有什么意义，因为所有的数据都已经被接收。因为包的延迟到达，Stream的发送端在任何时候都有可能收到这两种帧。
### 3.4 双向Stream状态
一个双向的Stream由发送和接收两部分组成，实现上可以将发送和接送部分的状态组合为双向Stream的状态。最简单的模型，当发送和接收部分都不处于终端状态时，Stream处于”Open”状态，当发送和接收都处于终端状态时，Stream处于”Closed”状态。    
下图展示了一种更为复杂的组合Stream状态，其近似于HTTP/2。由Stream的发送和接收部分的多个状态映射为一个复合状态。注意，这只是这种映射的一种可能；这种映射要求在转换到“closed”或“half closed”状态之前确认所有数据。
```
+----------------------+----------------------+-----------------+
| 发送部分状态           |  接收部分状态          |  复合状态        |
+======================+======================+=================+
| No Stream/Ready      | No Stream/Recv *1    | idle            |
+----------------------+----------------------+-----------------+
| Ready/Send/Data Sent | Recv/Size Known      | open            |
+----------------------+----------------------+-----------------+
| Ready/Send/Data Sent | Data Recvd/Data Read | half-closed     |
|                      |                      | (remote)        |
+----------------------+----------------------+-----------------+
| Ready/Send/Data Sent | Reset Recvd/Reset    | half-closed     |
|                      | Read                 | (remote)        |
+----------------------+----------------------+-----------------+
| Data Recvd           | Recv/Size Known      | half-closed     |
|                      |                      | (local)         |
+----------------------+----------------------+-----------------+
| Reset Sent/Reset     | Recv/Size Known      | half-closed     |
| Recvd                |                      | (local)         |
+----------------------+----------------------+-----------------+
| Reset Sent/Reset     | Data Recvd/Data Read | closed          |
| Recvd                |                      |                 |
+----------------------+----------------------+-----------------+
| Reset Sent/Reset     | Reset Recvd/Reset    | closed          |
| Recvd                | Read                 |                 |
+----------------------+----------------------+-----------------+
| Data Recvd           | Data Recvd/Data Read | closed          |
+----------------------+----------------------+-----------------+
| Data Recvd           | Reset Recvd/Reset    | closed          |
|                      | Read                 |                 |
+----------------------+----------------------+-----------------+
```
注(*1):    
如果Stream没有创建，或者Stream的接收状态处于"Recv"而没有接收到任何帧，则视为"idle"状态。
### 3.5 请求的状态转换
如果一个应用不再对Stream接收的数据感兴趣，可以终止Stream的读取然后设置一个应用的error code。如果Stream处于"Recv"或"Size Known"状态，传输应该通过发送**STOP_SENDING**帧来提示对端关闭Stream的发送部分。这表示接收端的应用不再读取之后接收到的数据，但并不代表会忽略掉已经接收到的数据。    
在发送**STOP_SENDING**后接收到的**STREAM**帧依然会计入连接和流量控制中，即使这些帧可能会被丢弃。    
一个**STOP_SENDING**帧要求接收端返回一个**RESET_STREAM**帧，如果Stream处于"Ready"或"Send"状态，在接收到**STOP_SENDING**帧后**一定**要发送一个**RESET_STREAM**帧做为反馈。如果Stream处于"Data Sent"状态并且未传输的数据被申明为丢弃，EndPoint**应该**发送一个**RESET_STREAM**帧来代替重传。    
如果Stream在接收到**STOP_SENDING**的时候已经处于"Data Sent"状态，EndPoint如果想要终止先前发送的**STREAM**帧的重传，则要先发送一个**RESET_STREAM**帧。    
**STOP_SENDING** **应该**只能被没有被对端重置的Stream发送，**STOP_SENDING**对处于"Recv"或"Size Known"状态的Stream是非常有效的。    
如果前一个**STOP_SENDING**丢失，则EndPoint需要重传另一个**STOP_SENDING**，然而，一旦Stream接收到了所有数据或接收到了**RESET_STREAM**，也就是说，Stream已经不处于"Recv"或"Size Known"状态，就没有必要再发送**STOP_SENDING**帧了。    
如果EndPoint希望终止双向Stream两个方向上的数据传输，可以发送一个**RESET_STREAM**来终止通知对端自己不再发送，然后再发送一个**STOP_SENDING**来通知对端不要再向自己发送。    

## 4 流量控制
非常有必要来限制数据的数量以使接收端可以有效缓存，一是防止一个快速的发送端压垮一个较慢的接收端，二是防止恶意的发送端发送大量数据以占用接收端过量的内存。为了使接收端能够控制连接使用的内存以压缩发送端的发送数据量，Stram的流控既有单独的控制也有聚合的控制。一个QUIC的接收端在任何时候都控制着发送端最大数据量的发送限制。详细描述见4.1节和4.2节。    
同样，为了控制一个连接上的并发，QUIC的EndPoint控制着对端可以启动的最大Stream数量限制。详细描述见4.5节。    
**CRYPTO**帧数据的发送与Stream的流控方式不同，QUIC依赖加密协议的实现来避免数据的过度缓存(见[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-tls-27))。实现上QUIC应该提供一种接口来告知其缓存上限，这样就不会在多层上存在冗余缓存。    

### 4.1 数据流控制
QUIC采用了一种类似于HTTP/2的基于信用的流控制方案，接收端会公布它在Stream和对应连接上准备好接收的字节数，这就导致QUIC有两层的流量控制：    
+ Stream层的流控，它通过限制在任意Stream上发送的数据量来避免一个单个的Stream消耗连接上过多的缓存。
+ 连接层的流控，通过限制所有Streams的**STREAM**帧的数据量来避免发送端发送的数据超出连接的整个缓存大小。    

接收端在握手(见7.3节)的时候通过发送传输参数来设置所有Stream的初始流量控制信息，通过发送**MAX_STREAM_DATA**帧(见19.10节)或**MAX_DATA**帧(见19.9节)到对端去调整流量限制。    
Stream的接收端通过发送设置了适当Stream ID的**MAX_STREAM_DATA**帧来通知对端流量控制信息，一个**MAX_STREAM_DATA**帧携带了Stream的所允许的绝对最大数据偏移，接收端可以使用当前所消耗的数据偏移来确定流量控制的偏移量。接收端**可能**会在多个包上发送**MAX_STREAM_DATA**帧来确保接收端在超出流控限制之前接收到了流控通知，即使其中的一些包丢失。    
接收端通过发送**MAX_DATA**帧来调整连接的流量控制信息，它携带所有Stream绝对偏移量之和。接收端维护累计所有Stream已经接收数据量的和，以用来检测是否超出了流量限制。接收端可以使用所有Stream上消耗的字节总数来确定要公布的流量限制。    
接收端通过发送**MAX_STREAM_DATA**帧和**MAX_DATA**帧来通告一个更大的偏移值。如果发布了没有增加偏移的偏移值，也没有影响。发送端**必须**忽略偏移量未增加的**MAX_STREAM_DATA**帧和**MAX_DATA**帧。
如果发送端违反了连接层或Stream层的流量限制，接收端**一定**会使用**FLOW_CONTROL_ERROR**错误来终止连接。    
如果发送端消耗完了对端通知的流量限制偏移，那么就无法再发送数据而进入阻塞状态，这时**应该**发送**STREAM_DATA_BLOCKED**帧或**DATA_BLOCKED**帧来通知对端还有数据未发送但是被流量限制阻塞了。如果阻塞的时间超过了设置的空闲超时时间(见10.2节)，那么连接就可能会关闭，即使还有数据没有发送完。为了防止连接关闭，受流量限制的发送端**应该**在没有未确认的在途数据的时候定期发送**STREAM_DATA_BLOCKED**或**DATA_BLOCKED**帧。    

### 4.2 流量限制增加
实现要决定何时通过**MAX_STREAM_DATA**和**MAX_DATA**发送多少偏移限制，本节提供一些考虑因素。    
为了避免阻塞发送端，接收端可以在一个交互回合中多次发送或尽早发送**MAX_STREAM_DATA**和**MAX_DATA**以便从丢包中快速恢复。    
控制帧会增加连接的开销，因此，极小的变动就频繁的发送**MAX_STREAM_DATA**和**MAX_DATA**帧是不明智的。另一方面，如果更新的频次较低，需要发送更大的限制偏移来避免发送端阻塞。在确定公布的流量限制偏移有多大时，应该在资源开销和传输开销之间有一个权衡。    
接收端可以基于包的往返时间和接收端消耗数据的速率来自动调整发送的偏移限制和频率，类似与常见的TCP实现。作为一种优化，EndPoint可以在有其他包要发送或者对端已经被流量限制阻塞时发送相关的**MAX_STREAM_DATA**和**MAX_DATA**帧，以确保流控不会导致发送额外的控制包。    
被阻塞的发送端并不强制要求发送**STREAM_DATA_BLOCKED**和**DATA_BLOCKED**帧，因此，接收端在发送**MAX_STREAM_DATA**和**MAX_DATA**帧之前**禁止**等待**MAX_STREAM_DATA**和**MAX_DATA**帧。因为这样做的话可能会阻塞连接上的其他发送端，另外，就算发送端发送了这些帧，等待这些帧也会导致发送端最少阻塞一个RTT周期。    
如果一个阻塞了的发送端接收到了新的偏移通告，则可能在响应中发送大量的数据，导致短期的拥塞。在6.9节有如何避免这种拥塞的相关讨论。

### 4.3 处理Stream的取消
EndPoints应该在Stream取消时就流量限制的偏移量达成一致，以避免超出流量限制和死锁。    
在接收**RESET_STREAM**的过程中，EndPoint会终止对应Stream的状态并忽略Stream上新达到的数据。如果**RESET_STREAM**帧不携带偏移量，两个EndPoint可能会在计算连接流量控制的偏移上产生不一致。为了解决这个问题，**RESET_STREAM**帧包含了Stream最终发送数据的数量。在接收**RESET_STREAM**的过程中，接受端可以确切的知道在**RESET_STREAM**之前已经接收了多少数据，发送端**必须**使用Stream的最终偏移大小来计算整个连接层流量控制的偏移大小。    
**RESET_STREAM**帧会突然终止Stream的一个方向，对于一个双向的Stream来说，**RESET_STREAM**对另一个方向的流量控制没有影响。两端都必须保持在未终止方向上的流量控制，直到该方进入终端状态或者其中一个EndPoint发送了**CONNECTION_CLOSE**。

### 4.4 Stream最终大小
最终大小是Stream消耗流量控制偏移的数量。如果每个相邻的byte都被只发送了一次，那么最终大小就是发送byte的数量。通常，最终大小比Stream上已经发送的最大偏移高一个。如果还没有数据发送，则是0。    
对于一个已经被重置的Stream，最终大小在**RESET_STREAM**中携带，或者，最终大小是偏移量加上用FIN标志标记的Stream帧的长度。如果是单向Stream的接收端，则为0。

当接受端的Stream在进入”Size Known”或”Reset Recvd”状态时，会知晓最终的大小。EndPoint**禁止**发送超过最终大小的数据。    
一旦Stream的最终大小被确定，就不能再修改。如果接收到了**RESET_STREAM**或**STREAM**帧导致最终大小发生变化，则EndPoint**应该**发送一个**FINAL_SIZE_ERROR**错误作为响应(见11节)。接收端**应该**将超过最终大小的数据视为**FINAL_SIZE_ERROR**错误，即使在Stream关闭之后。生成这些错误并不是强制性的，而是因为EndPoint生成这些错误也意味着EndPoint需要为关闭Stream保持最终大小状态，这是重要的状态承诺。

### 4.5 控制并发
Endpoint限制着对端打开Stream的并发数据。只有Stream ID比(max_stream * 4 + initial_stream_id_for_type)小的Stream可以被打开。初始的限制在在握手时通过传输参数设置，之后的限制通过**MAX_STREAMS**帧来调整。单独的限制适用于单向流和双向流。    
如果通过握手时的传输参数或者**MAX_STREAMS**帧接收到的最大Stream数量超过了2^60，这将导致最大的Stream ID不能按照变长整数编码(见16节)。一旦接受到这样的数字，则连接**一定**要立马关闭连接并返回**STREAM_LIMIT_ERROR**错误(见10.3节)。   
EndPoint**禁止**超过他们对端设置的限制。一旦收到帧携带的Stream ID超过了限制，则**一定**要视为连接错误并返回**STREAM_LIMIT_ERROR**。    
一旦接受端通过**MAX_STREAMS**接收到了一个Stream数量限制，则再接收到小于这个的限制会被忽略。接收端**一定**要忽略任何不会将限制增大的**MAX_STREAMS**帧。    
与Stream和连接的流量控制一样，实现中要自己定义什么时候通过**MAX_STREAMS**帧限制多少Stream并发到对端。实现可能会选择在Stream ID接近限制时增加限制，以保持对等方可用的流的数量大致一致。    
如果EndPoint由于对端的限制不能再打开新的Stream，则**应该**发送**STREAMS_BLOCKED**帧(见9.14节)，这对程序调试非常有用。EndPoint**一定不要**等待**STREAMS_BLOCKED**帧之后再调整对端Stream数量限制，如果这样做的话意味着对端至少要阻塞一个RTT周期，如果对端选择不发送**STREAMS_BLOCKED**帧，则可能会阻塞更长时间。    

## 5 连接
QUIC的连接建立过程结合了版本协商和加密传输握手以减少连接建立时的延迟，这将在第七节讲述。一旦连接建立，则可以迁移到任何一个不同ip和端口的EndPoint上，这将在第九节讲述。最后，第十节将说明连接的中断过程。

### 5.1 连接ID
每个连接都有一组连接标识或者连接ID，以用来标识一个连接。连接ID由EndPoint独立选择，每个EndPoint选择对端使用的连接ID。连接ID的主要作用是确保下层协议(UDP,IP)协议的地址变更不会导致QUIC连接的数据传输到错误的EndPoint上。每个EndPoint都使用一个特定于实现(或特定于部署的)方式来选择连接ID。    
相同的连接ID不能在同一连接上多次发出。    
具有长数据头的包包含源连接ID和目的连接ID字段，这些字段被用来为新的连接设置连接ID，具体细节在7.2节介绍。    
具有短数据头的包(17.3节)只包括目的地连接ID，而忽略显式长度。目的连接ID字段的长度应该被对端所知道。EndPoint使用一种基于路由的负载均衡器来就连接ID的长度或编码方案达成一致，固定部分可以编码一个显式的长度，这允许整个连接ID的长度不同，并且仍然由负载平衡器使用。
一个版本协商包(17.2.1节)原路返回客户端选择的连接ID，以保证包可以正常路由到客户端，且客户端可识别该包。    
当不需要连接ID路由到正确的Endpoint时，可以使用长度为零的连接ID。然而，相同IP和端口上的多路复用连接使用零长度的连接ID时会导致连接迁移失效。NAT的重新绑定和客户端的端口重用都会导致此问题产生，因此，除非确认这些协议的功能没有启动，否则不要使用长度为零的连接ID。     
当一个EndedPoint使用一个非零长度的连接ID时，它需要确认对端有一个可以选择的连接ID来发送数据。这些连接ID由EndPoint使用**NEW_CONNECTION_ID**帧来提供。    

### 5.1.1 发布连接ID
每个连接ID都有一个关联的序列号用来消除重复消息。在握手阶段，EndPoint发出的初始连接ID在长数据包头(见17.2节)的Source Connection ID字段中，初始连接ID的序列号为0，如果发送了preferred_address参数，则提供的连接ID为1。    
之后附加的连接ID通过**NEW_CONNECTION_ID**帧发送给对端。每个新发布的连接ID**必须**加1。客户端在初始包中随机选择的连接ID和重试包提供的任何连接ID都不会被分配序列号，除非服务器选择将它们保留为初始连接ID。   
当一个EndPoint发出了一个连接ID，则在连接期间它**必须** **接收**携带这个连接ID的包直到对端通过**RETIRE_CONNECTION_ID**帧宣布这个ID失效。已经发出而且没有失效的连接ID时活跃的，任何活动的连接ID在任何时候都是有效的，可以在任何包类型中使用，这包括服务器通过preferred_address参数发出的连接ID。    
EndPoint应该确保它的对端有足够数量可用和未使用的连接ID，EndPoint存储接收到的连接ID以供将来使用，并在活跃的连接上通过active_connection_id_limit参数来宣布愿意存储的活跃ID数量。EndPoint**一定不要**提供过多的连接ID超过对端的限制，当EndPoint接收到超过通过active_connection_id_limit参数宣布的ID限制的连接ID时，**必须**用**CONNECTION_ID_LIMIT_ERROR**错误关闭这个连接。    
当对端退出一个连接ID时，EndPoint必须提供一个新的连接ID，如果一个EndPoint提供的连接ID少于对端的活动连接ID限制，那么当它接收到一个带有以前未使用的连接ID的数据包时，它**可能**会提供一个新的连接ID。EndPoint可以限制为每个连接发出的连接ID的频率或总数，以避免连接ID用完的风险(请参阅第10.4.2节)。    
启动连接迁移并需要non-zero-length连接ID的EndPoint应确保其对端可用的连接ID池允许在迁移时使用新的连接ID，因为如果池耗尽，对端将关闭连接。   

### 5.1.2 使用和注销连接ID
EndPoint在连接存在的任何时间都可以修改它使用的连接ID，EndPoint使用连接ID响应对端的迁移。(9.5节)    
EndPoint维护着一组从对端接收到的连接ID，其中的任何一个连接ID都可以在发送包时使用。当EndPoint希望从使用的连接ID中删除一个的时候，需要发送**RETIRE_CONNECTION_ID**帧到对端。发送**RETIRE_CONNECTION_ID**通知对端某个连接ID不再使用，对端需要通过**NEW_CONNECTION_ID**回复一个新的连接ID来替代。    
如9.5节的讨论，每个连接ID都只能用于一个IP地址发送数据，如果EndPoint发生迁移不再使用之前的IP地址，则要将之前所有的连接ID都注销掉。    
EndPoint可以通过发送一个带有递增Retire Prior To字段的**NEW_CONNECTION_ID**帧来使对端注销一个连接ID，收到后，对端**一定要**立马通过反馈**RETIRE_CONNECTION_ID**帧来注销一个连接ID并将新提供的连接ID放到活跃连接ID列表内。如果无法在大约一个PTO内注销连接ID，可能会导致包的延迟，丢失，或者发送端的EndPoint会使用不能再正确到达目的地址的连接ID发送无状态的重置反馈。    
如果这个连接ID在小于三个PTO时间内已经被要求注销，EndPoint可能会丢弃**NEW_CONNECTION_ID**确认的连接ID。在此之前，Endpoint应该准备好接收包含它所请求的连接ID的数据包，使用该连接ID的后续传入数据包可以使用相应的无状态重置令牌引发响应。    
### 5.2 将数据包与连接匹配
接受时需要对数据包进行分类，以关联到一个现有的连接上，或者，对于服务端，可能会新建一个连接。    
EndPoint尝试将数据包与现有的连接进行关联，如果这个包携带了非零长度的目的连接ID关联现有的某个连接，QUIC则使用该连接处理该包。注意，一个连接可以与多个连接ID相关联，见5.1节。    
如果包的目的连接ID是零长度的并且地址信息匹配到了EndPoint使用的某个零长度的连接ID的地址，则QUIC使用此连接处理该包。EndPoint可以只使用目的IP和端口或同时使用源地址和目标地址进行标识，尽管这会使连接变得脆弱，如第5.1节所述。    
对与那些不能关联到任何连接的包，EndPoint可以发送反馈一个无状态的重置。一个无状态的连接重置可以使对端快速识别连接不可用。    
如果与现有连接匹配的数据包与该连接的状态不一致，则丢弃这些数据包。比如，如果某个包携带的协议版本与匹配的连接不同则会被丢弃，或者一旦预期的密钥可用，则删除数据包保护失败。    
没有数据包保护的包(例如初始化，重试或版本协商)可能会被丢弃，如果EndPoint在发现错误之前提交了状态变更，则**一定要**生成连接错误。    

### 5.2.1 客户端包处理
客户端发出的有效数据包通常会携带一个客户端选择的目的连接ID，那些选择零长连接ID的客户端可以使用本地的地址和端口来标识一个连接，不匹配任何连接的数据包会被丢弃。    
由于数据包重新排序或丢失，客户机可能会接收到使用尚未计算的密钥加密的连接的数据包。客户端可能会丢弃这些数据包或缓存这些数据包，以备之后的数据包计算其所用密钥。    
如果客户端接收到的数据包版本不受支持，则**必须**丢弃该数据包。    

### 5.2.2 服务端包处理
如果服务端接收到的包拥有不支持的版本，但是该包足够长能够支持服务端创建任何版本的新连接，则发送一个版本协商包(6.1节)。服务端可以对这些版本协商的包进行速率控制以避免发送太多。     
不支持的版本的第一个数据包可以对任何特定于版本的字段使用不同的语义和编码。特别是不同的保护密钥可能被用于不同的版本。如果服务器不支持某个版本，也不大可能能解密该版本的加密内容。    
具有某个支持版本的或者没有版本字段的包，被通过连接ID匹配到某个连接，或者零长度连接的包被通过本地IP和端口匹配到某个连接。如果包不能匹配到任何一个已经存在的连接，则继续执行以下操作：    
+ 如果使完全复合规范的初始包，则服务端继续进行握手过程(见7节)。这意味着服务端提交客户端选择的版本。    
+ 如果当前不服务接收任何新连接，则反馈一个**CONNECTION_CLOSE**的初始包并携带**SERVER_BUSY**的错误码。    
+ 如果是0-RTT包，服务端**可以**缓存一定数量的这些包以等待延迟到达的初始包。客户端无法在收到服务响应之前发送握手包，所以服务**应该**忽略这些包。    
+ 在所有其他情况下，服务器必须丢弃传入的数据包。  

## 5.3 QUIC连接的生命周期
QUIC连接是服务端和客户端之间有状态的互动，其最主要的作用是通过一种应用层协议来进行数据交换。Stream(第2节)是应用层数据交换的最主要手段。    
每个连接都开始与握手阶段，在此阶段客户端和服务端使用加密握手协议建立加密密钥，协商应用层的控制协议。握手(第7节)确认双端都愿意建立通信连接(8.1节)，并建立连接的参数(7.3节)。    
应用协议也可以通过有限的方式控制握手过程，0-RTT允许客户端发送应用层数据而不用接收到任何服务端数据。然而，0—RTT缺少一定的密钥安全保证。特别是，在0-RTT中没有针对重传攻击的保护，见[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-tls-27)。另外，服务器还可以在接收到客户端最终的加密握手信息(以确认客户端的的身份和活跃)之前，向客户端发送应用层数据。这些功能允许应用程序协议提供选择，以换取一些安全保证以减少延迟。     
连接ID的使用允许连接迁移到一个新的网络路径，即可以由EndPoint直接选择迁移，或者是因为中间设备改变而被迫迁移。第9节描述了与迁移相关的安全和隐私问题的缓解措施。    
对于不在需要的连接，有几种方式供客户端和服务器来关闭一个连接(见第10节)。

## 5.4 连接所需操作
在与QUIC传输交互时，应用程序必须能够执行某些操作。本文没有声明具体的API，但是这个版本的QUIC的任何实现都必须提供在QUIC连接上执行本节中描述的操作的能力。    
在客户端，QUIC的实现应该能够：    
+ 打开一个连接，开始第7节所述的交换。    
+ 当0-RTT可用时启用。    
+ 当0-RTT被服务器接受或拒绝时，通知上层。    

在服务端：    
+ 监听传入的连接，这为第7节中描述的交换做准备。    
+ 如果支持**Early Data**，则将应用程序控制的数据嵌入发送到客户端的TLS恢复票证中。    
+ 如果支持**Early Data**，则从客户端的恢复票证中检索应用程序控制的数据，并允许基于该信息拒绝早期数据。    

在双端：   
+ 为每种类型的允许Stream的初始数量配置最小值，如传输参数中所述(7.3节)。    
+ 控制各种类型的资源分配，包括流控制和每种类型的允许Stream的数量。     
+ 确定握手已经完成还是仍在进行。    
+ 通过生成**PING**帧(第19.2节)，或请求传输在空闲超时过期之前发送额外的帧(第10.2节)，防止连接静默关闭。    
+ 立即关闭(第10.3节)连接。

## 6 版本协商
版本协商确保客户机和服务器同意一个相互支持的QUIC版本。服务器发送一个版本协商包，以响应每个可能启动新连接的包；有关详细信息，请参阅第5.2节。    
客户端发送的第一个包的大小将决定服务器是否发送版本协商包。支持多个QUIC版本的客户端应该尽可能的(包的大小限制)将支持的所有版本信息都填充到一个发送的包中。这样可以确保服务器在存在相互支持的版本时做出响应。    

### 6.1 发送版本协商包
如果客户端选择的版本不被服务器接受，服务器将用版本协商包进行响应(见第17.2.1节)，这个包包括一个服务器支持版本的列表。EndPoint在收到版本协商包后**禁止**再以版本协商包作为响应。    
此系统允许服务器处理不支持版本的数据包而不保留状态。由于初始包和版本协商包都有可能丢失，客户端可以在未接收到成功的确认响应时发送新的包，或者放弃连接的尝试，如果这样，客户端将丢弃连接的所有状态，并且不再在连接上发送任何数据包。   
服务端可以限制发送版本协商包的数量，例如，能够识别包为0-RTT的服务器可能选择不发送版本协商包而发送0-RTT包，然后等待客户端的初始包。    

### 6.2 处理版本协商包
当客户端接收到版本协商数据包时，它必须放弃当前的连接尝试。QUIC的版本协商过程是向前兼容的。将来版本的QUIC可能会改变之前版本数据协商包的处理过程，如何进行版本协商是QUIC未来版本定义的未来工作，特别是，未来的工作将需要确保对版本降级攻击的健壮性；见21.10节。    

### 6.2.1 草案版本之间的版本协商
当实现接收到版本协商包时，它可以使用尝试使用包中列出的某个版本来尝试建立新连接，而不是放弃当前的连接尝试；见第6.2节。    
客户端必须检查接收到的目标和源连接ID字段是否与自己发送的数据包中的源和目标连接ID字段匹配，如果检查失败则**必须**丢弃。    
一旦确定服务器发送的版本协商包是有效的，客户端会选择一个自己支持的服务器提供的协议版本，之后尝试使用这个版本来建立新的连接，新连接必须使用一个新的随机目标连接ID，而不是以前发送的ID。   
请注意，此机制不能防止降级攻击，并且不能在草稿实现之外使用。    

### 6.3 使用保留版本
为了使服务器将来使用新版本，客户端需要正确处理不受支持的版本。为此，当生成版本协商包时，服务端应该包括保留用于强制版本协商的版本(如15节定义)。    
版本协商的设计允许服务器避免维护以这种方式拒绝的数据包的状态，客户端可以使用为强制版本协商而保留的版本发送数据包，这可用于从服务器请求受支持版本的列表。    

## 7 加密和传输握手
QUIC依赖于密码和传输握手的组合，以最小化连接建立延迟。QUIC使用第19.6节描述的**CRYPTO**帧来进行加密握手，QUIC的0x00000001版本使用TLS(如[QUIC-TLS]中所述).不同的QUIC版本号可能表示正在使用不同的加密握手协议。
QUIC提供可靠、有序的加密握手数据传递,QUIC将握手的数据包尽可能的进行加密。加密的握手过程必须支持以下属性：    
+ 进行密钥交换，当：    
    - 服务器总是经过身份验证
    - 客户端可选的进行身份验证
    - 每个连接都会产生不同和不相关的键
    - 密钥可以用于0-RTT和1-RTT包的保护
    - 1-RTT密钥具有前向保密性
+ 验证双端的传输参数，以及服务器传输参数的加密(7.3节)。
+ 应用协议的协商。    

Endpoint可以在它发送的第一个数据包中验证对显式拥塞通知(ECN)的支持，如第13.4.2节所述。    
**CRYPTO**帧可以在不同的包编号空间发送。**CRYPTO**帧用于确保加密握手数据的有序传递的序列号在每个包编号空间中都是从零开始。    
EndPoint必须协商应用层协议，以避免使用的协议出现分歧。    
## 7.1 握手流程示例
这里只提供一些实例，详细的TLS如何与QUIC集成在[QUIC-TLS](https://tools.ietf.org/html/draft-ietf-quic-tls-27)。第8.1.2节显示了支持客户端地址验证的扩展。    
一旦交换地址验证完成，就可以使用加密握手来商定加密的密钥，加密握手数据被初始包(17.2.2节)和握手包(17.2.4节)携带。    
图3提供了1-RTT握手的概述，每行显示一个QUIC包，首先显示包类型和包编号，然后是通常包含在这些包中的帧。因此，例如，第一个包是Initial类型，包编号为0，并且包含一个携带ClientHello的**CRYPTO**帧。    
注意，多个QUIC数据包——即使是不同的加密级别——也可以合并成一个单独的UDP数据报(见第12.2节)，因此，这种握手可能只包含4个UDP数据报，或者更多。例如，服务器的第一次发送的数据包包含来自初始加密级别(模糊化)、握手级别的数据包，以及来自服务器的1-RTT加密级别的"0.5-RTT数据"。
```
Client                                                             Server
Initial[0]: CRYPTO[CH] ->
                                            Initial[0]: CRYPTO[SH] ACK[0]
                                  Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                            <- 1-RTT[0]: STREAM[1, "..."]
Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] ->
                                       1-RTT[1]: STREAM[3, "..."], ACK[0]
                                                  <- Handshake[1]: ACK[0]
                          图3: 1-RTT 握手示例
```
图4展示了一个具有0-RTT握手和一个0-RTT数据包的连接示例，请注意，如第12.3节所述，服务器在1-RTT加密级别确认0-RTT数据，而客户端在相同的包编号空间中发送1-RTT包。    
```
Client                                                             Server
Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0, "..."] ->
                                            Initial[0]: CRYPTO[SH] ACK[0]
                                             Handshake[0] CRYPTO[EE, FIN]
                                     <- 1-RTT[0]: STREAM[1, "..."] ACK[0]
Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[1]: STREAM[0, "..."] ACK[0] ->
                                       1-RTT[1]: STREAM[3, "..."], ACK[1]
                                                  <- Handshake[1]: ACK[0]
                          图4: 0-RTT 握手示例
```

## 7.2 协商连接ID
连接ID被用来确保数据包的路由目标，这在5.1节有述。长数据包头包含两个连接ID：       
+ 目的连接ID，由数据接收端选择的，用来标识路由目标
+ 源连接ID，接收端发包时用来设置包目的连接ID    

在握手阶段，长数据包头的包用来确定双端使用的连接ID。每个EndPoint都使用接收到的包的源连接ID来标示自己接收使用的目的连接ID，在接收到包之后，EndPoint使用接收到的源连接ID来设置发送数据包的目的连接ID。    
当客户端在接收到服务的初始包或者重试包前，就发送初始化包，那么目的连接ID的值很可能是未知的，但是长度必须至少为8字节。在从服务器接收到数据包之前，客户端必须使用相同的值来发送数据包，除非它放弃连当前的连接尝试并开始新的连接尝试。初始包的目的地连接ID用于确定初始包保护密钥。    
客户机使用其选择的值填充源连接ID字段，并设置SCID Len字段以指示长度。    
第一个发送的0-RTT包使用与客户端初始包相同的目的连接ID和源连接ID。    
一旦从服务器接收到初始或重试数据包，客户端使用服务器提供的源连接ID作为后续数据包(包括任何后续的0-RTT数据包)的目标连接ID。这意味着客户端在建立连接期间可能会更改两次目标连接ID，一次在响应重试时，一次在响应来自服务器的第一个初始数据包时。一旦客户机从服务器接收到初始数据包，它必须丢弃它接收到的具有不同源连接ID的任何数据包。    
客户端只能在响应接收到服务器的第一个初始包或者重试包时，修改目的连接ID的值。而服务器必须根据初始化包设置目的连接ID，任何额外的修改都是不允许的。如果这些类型的后续数据包包含不同的源连接ID，则必须丢弃它们。这避免了无状态处理建立连接ID时，出现多个初始数据包可能出现的问题。
连接ID可以在连接的生存周期内修改，但是只针对连接迁移(第九节)，详情请看5.1.1节。
## 7.3 传输参数
在连接建立确认期间，双端进行传输参数的设定。这些声明是由每个EndPoint单方面作出的，EndPoints需要遵守这些参数所隐含的限制；每个参数的描述都包括处理它的规则。    
关于传输参数的编码细节见18节。     
QUIC在加密握手中包含编码的传输参数 ，一旦握手完成，对端声明的传输参数是可用的。每个EndPoint都验证对端声明的传输参数的值。    
第18.2节中包含了每个传输参数的定义。    
EndPoint必须将接收到无效的传输参数视为**TRANSPORT_PARAMETER_ERROR**连接错误。    
EndPoint禁止多次发送传输参数，EndPoint应将接收到的重复传输参数视为**TRANSPORT_PARAMETER_ERROR**连接错误。
如第17.2.5节所述，如果服务器发送了一个重试包以启用重试验证，则必须包含**original_connection_id**传输参数(第18.2节)。
### 7.3.1 0-RTT的传输参数
EndPoints需要存储服务器设置的传输参数的值，并将其设置到后续连接中发送到对端的任何0-RTT包中，但是设置了显示排除的参数除外。记录的传输参数将应用于新连接，直到握手完成客户端开始发送1-RTT包。一旦握手完成，客户端将使用握手中建立的传输参数。    
定义一个新的传输参数(7.3.2节)时**一定要**指定其必须，可以，或者禁止应用于0-RTT包。客户端不需要存储其不能处理的参数参数。    
客户端**禁止**存储以下参数：**original_connection_id**, **preferred_address**, **stateless_reset_token**,
**ack_delay_exponent**，和**active_connection_id_limit**，客户端一定要使用握手中设置的最新传输参数的值，如果服务端没有指定，则只用默认值。    
客户端尝试发送0-RTT包时**一定**要记录所有的服务器使用的传输参数，服务器可以记住这些传输参数，或者在上下文中存储完整的副本，并在接受0-RTT数据时恢复信息，服务器使用传输参数来确定是否接受0-RTT数据。    
如果服务端接受0-RTT数据包，则服务端**禁止**减少限制或修改任何和客户端0-RTT包中冲突的参数值。特别是，接受0-RTT数据的服务器缩减以下参数值(见18.2节)：    
+ **initial_max_data**
+ **initial_max_stream_data_bidi_local**
+ **initial_max_stream_data_bidi_remote**
+ **initial_max_stream_data_uni**
+ **initial_max_streams_bidi**
+ **initial_max_streams_uni**    

忽略或设置某些传输参数的为零会导致虽然启用0-RTT数据，但不可用。部分保证应用层数据发送的传输参数**应该**在0-RTT包中设置为非0值，这包括：    
+ **initial_max_data**
+ **initial_max_streams_bidi**
+ **initial_max_stream_data_bidi_remote**
+ **initial_max_streams_uni**
+ **initial_max_stream_data_uni**

如果传输参数的值不受支持，服务器必须拒绝0-RTT数据或中止握手。    
当使用0-RTT发送帧时，客户端**应该**只使用记录的传输参数，特别是，不要使用从接收到1-RTT包中获取到的新的传输参数值。来自握手的传输参数的更新值仅适用于1-RTT数据包。例如，存储的传输参数的流控制限制(旧的值)适用于所有0-RTT包，即使这些值通过握手或在1-RTT包中增加。服务器可能会将0-RTT中更新的传输参数的使用视为**PROTOCOL_VIOLATION**类型的连接错误。

### 7.3.2 新的传输参数
新的传输参数可以用来协商新的协议行为，EndPoint必须忽略那些它不支持的传输参数。因此，缺少传输参数将禁用使用该参数协商的任何可选协议的功能。如18.1节所述，为了保证必须的协议功能，保留了一些强制的传输参数。    
可根据第22.2节中的规则注册新的传输参数。    
## 7.4 加密消息缓冲
实现上需要维护一个缓存存储失序接收的**CRYPTO**数据。由于**CRYPTO**帧没有流量控制，对端可能会要求缓存无限量的数据。    
实现必须支持缓存至少4096 bytes的无序**CRYPTO**帧数据，EndPoint可能在握手阶段允许缓存更多的数据。握手过程中的更大限制可能允许交换更大的密钥或凭据。EndPoint的缓冲区大小不需要在连接的生命周期内保持不变。    
在握手阶段无法缓存**CRYPTO**会导致连接失败。如果在握手过程中数据超过了EndPoint的缓存大小，则可以临时扩展其缓存区以完成握手。如果EndPoint不选择扩大其缓存区，则要以**CRYPTO_BUFFER_EXCEEDED**终止此连接过程。    
一旦握手完成，如果EndPoint无法缓存**CRYPTO**帧中的所有数据，它可能会丢弃该帧和将来接收到的所有**CRYPTO**帧，或者使用CRYPTO_BUFFER_EXCEEDED错误码关闭此连接。必须回复ACK确定包含**CRYPTO**帧的数据包，因为即使将其丢弃，也算被中断接收和处理过。   

## 8 地址验证
QUIC使用地址验证来避免被流量放大攻击，在这种攻击中，发送到服务器的包具有受害者的伪造地址信息，如果服务器响应了很多或者较大的数据包，则攻击者可以发送更多的数据到受害主机上。针对放大攻击的主要防御措施是验证EndPoint是否能够在其声明的传输地址处接收数据包。地址验证在连接建立期间(见第8.1节)和连接迁移期间(见第8.2节)进行。

## 8.1 连接建立期间的地址验证
连接建立隐式地为两个Endpoint提供地址验证。特别是由握手密钥保护的包和客户端接收到服务器的初始化包。一旦服务器成功地处理了来自客户端的握手包，它就可以认为客户端地址已经过验证。    
在验证客户端地址之前，服务器发送的字节数**不得**超过其接收bytes数的三倍。这限制了使用欺骗源地址伪装的放大攻击的规模。在计算此限制时，服务器只计算成功处理的数据包的大小。    
客户端必须确保包含初始数据包的UDP数据报的UDP有效负载至少为1200 bytes，根据需要填充数据报中的数据。发送填充数据报可以确保服务器不受放大限制的过度限制。   
数据包丢失，特别是来自服务器的握手包的丢失，可能导致客户端没有数据需要发送而服务器达到上述限制而无法发送数据的情况。为了避免这种握手死锁产生，客户端**必须**在超时时发送数据包，详情见[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)。如果客户端没有要重新传输的数据，也没有握手密钥，它**必须**以至少1200字节的UDP数据报重新发送初始数据包。如果客户端有握手密钥，则**应该**发送一个握手包。 
服务器可能希望在加密握手之前验证客户端的地址。QUIC在初始数据包中使用token在完成握手之前提供地址验证。此token在连接建立期间通过重试数据包(见第8.1.2节)或在以前的连接中使用新的**NEW_TOKEN**帧(第8.1.3节)传递给客户端。    
除了在地址验证之前设置的发送限制之外，服务器还受到拥塞控制设置的限制，以限制了可以发送的内容。客户端仅受拥塞控制的约束。

### 8.1.1 Token构造
在**NEW_TOKEN**帧或重试包中发送的令牌的构造必须允许服务器标识它是如何提供给客户端的。这些token在同一字段中携带，但需要在服务器中进行不同的处理。    

### 8.1.2 使用重试包地址验证
在接收到客户端的初始数据包后，服务器可以通过发送包含token的重试包(第17.2.5节)来请求地址验证，客户端在接收到该重试数据包后，必须在该连接之后发送的所有初始数据包中携带此token。服务器在对包含token的初始化包处理时，可以选择终止连接或者继续处理。    
只要攻击者不能够为自己的地址生成一个有效的令牌(见8.1.4节)，并且正常客户端能够返回该令牌，那就向服务器证明了它收到了token。    
服务器还可以使用重试包来延迟建立连接的状态和处理开销。比如提供一个不同的连接ID，以及强制使用第18.2节中定义的**original_connection_id**传输参数，或者从客户端接收原始的初始数据包。提供一个不同的连接ID还可以让服务器控制后续数据包的路由方式。这可用于将连接定向到其他服务器实例。    
如果服务器接收到一个不被保护的初始包携带了无效的重试token，它知道客户端不会再接受另一个充实token，服务器可以丢弃这样的数据包，从而导致客户端超时检测握手失败，这可能会对客户端造成很大的延迟。服务器**可以**在不验证token的情况下继续进行连接，但服务器**不能**将客户端地址视为已验证。如果一个服务器选择终止继续握手过曾，它应该立即以**INVALID_TOKEN**错误关闭连接(第10.3节)。请注意，此时服务器尚未为连接建立任何状态，因此不会进入关闭期。  
图5显示了使用重试包的流程:

```
Client                                                               Server
Initial[0]: CRYPTO[CH] ->
                                                             <- Retry+Token
Initial+Token[1]: CRYPTO[CH] ->
                                              Initial[0]: CRYPTO[SH] ACK[1]
                                    Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                              <- 1-RTT[0]: STREAM[1, "..."]
                           图 5: 重试握手示例
```

### 8.1.3 未来连接的地址验证
服务器**可以**在一个连接中给客户端一个地址验证token，以用于之后的连接。地址验证对于0-RTT尤其重要，因为服务器可能会向客户端发送大量数据以响应0-RTT数据。    
服务端通过**NEW_TOKEN**帧(19.7节)发送给客户端token，该token可用于将来的地址验证。客户端通过在初始化包中携带此token以提供未来连接的地址验证能力。客户端**必须**在它发送的所有初始数据包中包含令牌，除非服务端的重试包将令牌替换为新的令牌。客户端不得将重试包中提供的token用于将来的连接。服务器**可以**丢弃任何不携带预期token的初始包。    
与立即使用的重试数据包创建的token不同，在**NEW_TOKEN**帧中发送的令牌可能会在经过一段时间后使用。因此，令牌应该有一个过期时间，可以是显式的过期时间，也可以是可用于动态计算过期的时间戳。服务器可以存储过期时间，也可以在令牌中以加密的形式包含它。    
发送token的**NEW_TOKEN**的帧**禁止**携带任何关于本机的连接信息以防止链路上的网络阶段截取，除非它是加密的。例如，它不能包含以前的连接ID或地址信息。服务器必须确保它发送的每一个**NEW_TOKEN**帧在所有客户端中都是唯一的，除了那些被发送来修复先前发送的**NEW_TOKEN**帧丢失的客户端。    
两个不同连接上的客户机端口号不太可能相同；因此验证端口不太可能成功。    
从**NEW_TOKEN**接收到的token适用于被认为是授权连接的任何服务器(例如，证书中包含的服务器名称)。当持有一个可用而未使用的token连接服务器时，应该在它发送的初始包中携带该token。包含toekn可以让服务器进行地址验证而不必额外的交互往返。客户端**禁止**使用不适用于某服务器的token去创建连接，除非客户端知道发出token的服务器和客户端连接的目标服务器正在共同管理令牌。客户端可以使用以前连接到该服务器的令牌。     
想要中断与服务器的身份连续性验证的客户端可以丢弃使用**NEW_TOKEN**帧提供的令牌。相比之下，在重试数据包中获得的token必须在连接尝试期间立即使用，并且不能在随后的连接尝试中使用。    
客户端不应在不同的连接尝试中重复使用**NEW_TOKEN**令牌。复用token在连接迁移中使用，见9.5节。    
客户端可能会从一个连接上接收到多个token，除非被显示阻止，任何token都可以被用到任何连接尝试中，服务器可以发送额外的token去开启多个连接尝试的地址验证，或者替换将要失效的token。这对客户端而言，发送最近收到的未使用的token最有可能生效。虽然保存和使用旧的token没有负面影响，但是客户端可以认为旧的token对地址验证是不起作用的。    
当服务器接收到一个携带token的初始包时，**必须**对token进行验证，除非服务器已经完成了地址验证。如果token无效，则服务器应像客户端没有经过地址验证一样继续操作，包括可能发送重试包。如果token验证通过，则服务器**应该**继续握手流程。    
注意：将客户端视为未验证而不是丢弃数据包的原因是，客户端可能已经在前一个连接的**NEW_TOKEN**帧接收到了新的token，如果服务器丢失了状态，则可能无法验证该token，如果直接丢包，则可能导致未来的连接失败。服务器应该以不同的方式对带有token的**NEW_TOKEN**帧和重试包进行编码，并对后者进行更严格的验证。    
在无状态设计中，服务器可以使用加密的和经过身份验证的token将信息传递给客户机，服务器稍后可以恢复这些信息并使用这些token验证客户端地址。token没有集成到加密握手中，因此它们没有经过身份验证。例如，客户端可能会重用一个token，为了避免因此而被攻击，服务器可以将token的使用限制为仅持有验证客户端地址所需的信息。    
在相同版本时，客户端可能使用从一个连接上获取到的token以用于之后任何的连接尝试。当选择了一个token时，客户端不需要考虑任何其他的连接属性，包括可能的应用程序协议，会话或其他的连接属性选择。    
攻击者可以重放token，将服务器用作DDoS攻击的放大器。为了防止此类攻击，服务器应确保在重试包中发送的token仅在较短时间内被接受。在**NEW_TOKEN**帧(见19.7节)中提供的令牌需要更长的有效期，但不应在短时间内多次接受。如果可能，鼓励服务器所有令牌只使用一次。    

### 8.1.4 地址验证token完整性
地址验证的token一定要非常难被猜到。在token中应该包括足够多的随机值，但这取决于服务器能否记住发送给客户端的该值。   
基于token的方案允许服务器将与验证相关的任何状态放到客户端。为了使这个设计有效，token必须保证完整性，以防止被客户端伪造和篡改。如果没有完整性保护，恶意的客户端可以生成或猜测服务器将接受token值。只有服务器需要访问token的完整性保护密钥。    
并不需要为token定义明确的格式，因为只有生成它的服务器使用它。token可以包括有关所声明的客户端地址(IP和端口)信息、时间戳以及服务器将来验证token所需的任何其他补充信息。    

## 8.2 路径验证
EndPoint的地址迁移期间使用路径验证(参见第9节和第9.6节)，从新的地址验证对等机的可访问性。在路径验证中，EndPoint测试特定本地地址和特定对等地址之间的可达性，其中地址是IP地址和端口的两元组。    
路径验证测试包(Path_CHALLENGE)可以发送到路径上的对等方，也可以从路径上的对等方接收(PATH_RESPONSE)。重要的是，它验证从迁移Endpoint接收的数据包是否携带伪造的源地址。    
任何EndPoint都可以随时使用路径验证。例如，EndPoint可能会检查对端在一段静止时间之后是否仍然拥有它的地址。    
路径验证不是作为NAT遍历机制设计的。尽管这里描述的机制对于创建支持NAT遍历的NAT绑定可能是有效的, 但是有效的NAT遍历需要额外的同步机制，这里没有提供这些机制。    
Endpoint可以将用于路径验证的**PATH_CHALLENGE**和**PATH_RESPONSE**帧与其他帧捆绑在一起。具体地说，Endpoint可以使PMTU发现填充包携带**PATH_CHALLENGE**，或者Endpoint可以将**PATH_RESPONSE**与自己的**PATH_CHALLENGE**捆绑在一起。

当探测新路径时，Endpoint可能希望确保它的对端具有可用于响应的未使用的连接ID。Endpoint可以在相同的包中发送**NEW_CONNECTION_ID**，**PATH_CHALLENGE**帧，以确保对端有可使用的连接ID。
## 8.3 启动路径验证 
要启动路径验证，Endpoint将发送一个**PATH_CHALLENGE**帧，其中包含要验证的路径上的随机负载。Endpoint可能要发送多个**PATH_CHALLENGE**帧来避免包丢失，但是Endpoint不应该将多个**PATH_CHALLENGE**帧放到同一个包中。Endpoint不发送**PATH_CHALLENGE**的频次不能比初始化包高，以确保连接迁移在新路径上的负载不会超过建立新连接的负载。    
Endpoint**必须**在每个**PATH_CHALLENGE**帧中使用不可预测的数据，以便它可以将对等方的响应与相应的**PATH_CHALLENGE**相关联。

## 8.4 路径验证响应
在接收到**PATH_CHALLENGE**帧时，Endpoint必须用**PATH_CHALLENGE**帧中的数据以**PATH_RESPONSE**帧响应。Endpoint在响应**PATH_CHALLENGE**帧时**不能**发送多个**PATH_RESPONSE**帧(见13.3节)。对端应根据需要发送更多的**PATH_CHALLENGE**帧，以引发额外的**PATH_RESPONSE**帧。    

## 8.5 路径验证成功
当接收到包含在上一个**PATH_RESPONSE**中发送的数据的**PATH_CHALLENGE**时，新地址被视为有效。收到包含**PATH_CHALLENGE**帧包确认地址验证是不充分的，因为对端可能会恶意的伪造。    
注意，不同本地地址的接收不会导致路径验证失败，因为这可能是转发包(见第9.3.3节)或错误路由的结果。将来可能会收到有效的**PATH_RESPONSE**响应。

## 8.6 地址验证失败
只有当尝试验证路径的Endpoint放尝试时，路径验证才会失败。    
Endpoint不应该基于定时器进行路径验证。一旦设置了定时器，实现时新路径的往返时间就可能会比源路径更长。推荐使用[QUIC-RECOVERY]中定义的当前探测超时(PTO)或初始超时(即2*KINITALRTT)的三倍值，其定义为：     
validation_timeout = max(3*PTO, 6*kInitialRtt)    

请注意，Endpoint可能会接收到包含新路径上其他帧的数据包，但成功的路径验证需要具有适当数据的**PATH_RESPONSE**帧。    
当Endpoint放弃路径验证时，它确定路径不可用。但这并不一定意味着连接失败，Endpoint可以根据需要继续通过其他路径发送数据包。如果没有路径可用，Endpoint可以等待一个新的有效路径或者关闭这个连接。    
除了失败之外，路径验证可能会因为其他原因而被放弃。主要是，如果在旧路径上进行路径验证时启动到新路径的连接迁移，就会发生这种情况。    

## 9 连接迁移
连接ID的使用允许连接迁移到其他地址，例如Endpint迁移到新的网络。本节描述Endpoint迁移到新地址的过程。   
QUIC的设计依赖于Endpoint在握手期间保持一个稳定的地址，Endpoint**禁止**在握手完成之前进行连接迁移，见4.1.2节。    
如果对端在握手期间发送了**disable_active_migration**传输参数，则本地Endpoint禁止在其他地址上发送数据和主动启动连接迁移。而发送了这个传输参数的Endpoint如果检测到对端已迁移到另一个网络，则必须在不生成无状态重置的情况下丢弃该路径上的传入数据包，或者继续进行路径验证并允许该对端进行迁移。生成无状态重置或关闭连接将允许网络中的第三方通过欺骗或以其他方式操纵观察到的流量来关闭连接。    
并非所有对端地址的更改都是有意或主动的迁移。对端可能会经历NAT重新绑定: 由于中间设备(通常是NAT)而导致的地址更改，为流分配新的传出端口甚至新的传出IP地址。如果Endpoint检测到对等地址的任何更改，则必须执行路径验证(第8.2节)，除非它以前验证过该地址。    
当Endpoint没有可用于发送数据包的已验证路径时，它**可能**会放弃连接状态。能够进行连接迁移的Endpoint可能会等待新路径变为可用，然后才放弃连接状态。    
本文档限制了连接到新客户端地址的迁移，但第9.6节中所述的情况除外。客户端负责启动所有迁移。服务器不会向客户端地址发送非探测数据包(见第9.1节)，除非它们看到来自该地址的非探测数据包。如果客户端从未知服务器地址接收数据包，则该客户端必须丢弃这些数据包。

## 9.1 检测新路径
在将连接迁移到新的地址之前，Endpoint可以使用路径验证(第8.2节)从新的地址探测对端的可达性。路径验证失败仅仅意味着新路径不能用于此连接。除非没有有效的替代路径，否则验证路径失败不会导致连接结束。  
Endpoint使用一个新的连接ID来处理从新的本地地址发送的探测(见9.5节的讨论)，因此当Endpoint使用一个新的本地地址时需要确定对端至少有一个可以使用的连接ID，这可以通过在探测中发送包含**NEW_CONNECTION_ID**帧来确认。     
从对端接收到**PATH_CHALLENGE**帧表示该对端正在探测路径上的可达性。此时应该以**PATH_RESPONSE**作为响应(8.2节)。    
**PATH_CHALLENGE**, **PATH_RESPONSE**, **NEW_CONNECTION_ID**, 和**PADDING**都是探测帧，而其他类型的帧都是非探测帧。只包含探测帧的包是“探测包”，而包含任何其他帧的包是“非探测包”。   

## 9.2 启动连接迁移
Endpoint可以通过从其他本地地址发送非探测帧而降连接迁移到新的地址。在连接建立期间，没有Endpoint都验证其对端的地址。因此，迁移的Endpoint可以知道对端在哪个地址上等待接收。所以Endpoint可以迁移到一个新的地址而不用首次旧验证对端的地址。    
当连接迁移时，新的路径可能不支持Endpoint当前的发送速度，因此，Endpoint会重置它的拥塞控制，见9.4节。    
新的网络路径可能没有相同的ECN能力，因此，Endpoint验证ECN能力，如第13.4节所述。    
接收在新路径上发送的数据的确认可以作为对端迁移到新地址的证据。由于确认包可以在任何路径上被接收，新路径上的访问可达性时不确定的。为了在新路径上建立访问可达性，Endpoint可以同时在新路径上启动路径验证(第8.2节)。    

## 9.3 响应地址迁移
从对端新的地址上接收到包含非探测帧的包，表明对端已经迁移到了一个新的地址。    
在这种包的响应中，Endpoint**必须**开始向新的对等地址发送后续数据包，并且**必须**启动路径验证(第8.2节)，以验证对端对未验证地址的所有权。    
Endpoint可以将数据发送到未经验证的对端地址，但必须按照第9.3.1节和第9.3.2节中的描述防止潜在攻击。如果地址最近被验证过，则可以跳过对端地址的验证过程。特别是，如果Endpoint在检测到某种形式的伪迁移后返回到先前验证的路径，则跳过地址验证并恢复丢失检测和拥塞状态可以减少此类恶意攻击对性能的影响。    
Endpoint只改变它发送数据包的地址，以响应编号最高的非探测数据包。这可以确保Endpoint在接收到重新排序的数据包的情况下不会将数据包发送到旧的对等地址。    
一旦迁移到了发送非探测包的地址，Endpoint可以放弃对其他地址的任何路径验证。    
从新的对端地址接收数据包可能是在对端重新绑定NAT的导致的。    
在验证一个新的客户端地址之后，服务器应该向客户机发送新的地址验证token(第8节)。

### 9.3.1 对端地址欺骗
有可能是对端端欺骗其源地址，导致Endpoint向主机发送过多的非期望数据。   
如果正常的Endpoint需要发送的数据比欺骗迁移的Endpoint更多，则连接迁移可能被用来进行流量放大攻击。    
如第9.3节所述，Endpoint需要验证对端的新地址，以确认端方拥有新地址，确实产生了连接迁移。在对端的地址被认为有效之前，Endpoint必须限制它向该地址发送数据的速率。Endpoint在每个评估的往返时间(kMinimumWindow，如[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)中定义)发送的数据不得超过最小拥塞窗口值。在没有这个限制的情况下，Endpoint有可能被用来对不知情的受害者进行拒绝服务攻击。注意，由于Endpoint不会有任何到该地址的往返时间测量值，所以估计值应该是默认的初始值（请参见[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27))。    
另外，如果Endpoint跳过了对对端地址的路径验证，那就不需要再限制发送速率。    
### 9.3.2 路径地址欺骗
在路径上的攻击者可以通过复制和转发具有欺骗地址的数据包，在原始数据包之前到达，从而导致虚假的连接迁移。具有欺骗地址的数据包将被视为来自迁移的新连接，而原始数据包将被视为重复数据并被丢弃。在假迁移之后，地址的验证将失败，因为虚假地址处的实体没有必要的加密密钥来读取或响应发送给它的**PATH_CHALLENGE**帧(即使它愿意)。     
为了防止连接因这种错误的迁移而失败，当验证新的对端地址失败时，Endpoint必须恢复为使用最后验证的对端地址。    
如果Endpoint没有关于最后验证的对端地址的状态，它必须通过放弃所有连接状态来静默地关闭连接。这会导致连接上的新数据包被一般性地处理，例如，Endpoint可以发送无状态重置以响应任何进一步的传入包。    
请注意，从合法对等地址接收具有更高数据包编号的数据包将触发另一个连接迁移。这个将导致错误迁移地址的验证被放弃。    

### 9.3.3 非路径包转发
能够观察到数据包的位于传输路径上的攻击者可能会将真实数据包的副本转发到Endpoint。如果复制的数据包在真正的数据包之前到达，这将被认为是NAT重新绑定。真正的数据包会被认为是副本而被丢弃。如果攻击者可以持续的抓发数据包，则可能导致连接迁移到攻击者的路径上。这将使位于传输路径上的攻击者可以观察或丢弃所有后续的数据包。    
与9.3.2节描述的攻击不同，这里的攻击者可以确保新的路径被验证。    
这种类型的攻击依赖于攻击者使用的路径大约与Endpoint之间的直接路径传输一样快或者更快。如果发送的数据较少或者丢包与尝试攻击同时发生，则这类的攻击可能会更容易生效。    
如果在源路径上接收到非探测数据包使得接收数据包编号增大，则会导致连接迁移回源路径。在该路径上增加数据包交换会减少被攻击的可能性。因此，减轻这种攻击依赖于触发包的交换。   
在明显迁移的响应中，Endpoint必须使用**PATH_CHALLENGE**帧验证先前活动的路径。这会导致在该路径上发送新的数据包。如果该路径不再有效，则验证尝试会超时和失败。如果该路径依然有效但是不再被使用，则验证会成功，但是该路径只会发送探测数据包。    
在活动路径上的Endpoint接收到**PATH_CHALLENGE**应该发送非探测数据包作为响应。如果非探测数据包在攻击者复制的数据包之前到达，则会导致连接迁移回活动的源路径上。任何后续迁移到其他路径的尝试都会重新启动这个过程。    
这种机制是不完美的，但这不是一个严重的问题。如果尽管多次尝试使用源路径，但是攻击者路径依然比源路径传输数据快，则无法区分这是攻击还是路由改进。    
Endpoint还可以使用启发的方式来提高对这种攻击的检测。例如，如果最近在旧路径上接收到数据包，则不可能是NAT重新绑定，类似地，在IPv6路径上很少会进行重新绑定。Endpoint也可以查找重复的数据包。而且，连接ID的更改更可能表示有意的连接迁移，而不是攻击。

## 9.4 丢失检测和拥塞控制
新路径上的可用容量可能与旧路径不同。在旧路径上发送的数据包不能帮助确认新路径的拥塞控制和RTT评估。    
在确认对端迁移到新路径后，Endpoint**必须**以初始值重置拥塞控制和RTT时间除非它知道先前的发送速率或往返时间估计对于新路径是有效的。例如，一个Endpoint可能会推断客户端只有口号的更改表示NAT重新绑定，这意味着新路径可能具有相似的带宽和往返时间。但是，这个策略并不总是正确，如果判定不正确，则拥塞控制器和RTT估计器需要适应新的路径。通常，建议实现时在新路径上使用以前的值时要谨慎。    
当Endpoint在迁移期间可能会从多个地址发送数据和探测，在接收器处可能存在明显的重新排序，因为两个结果路径可能具有不同的往返时间。接收多个路径上数据包的接收器仍需要对所有的发送端发送ACK帧。    
在连接迁移过程中可能会使用多个路径，但是一个控制拥塞上下文和一个丢失恢复上下文就足够处理多个路径。例如，Endpoint可能会延迟切换到新的拥塞控制上下文，直到确认不再需要旧路径（如第9.3.3节中的情况）。    
发送方可以对探测包进行异常处理，这样它们的丢失检测是独立的，并且不会过度地导致拥塞控制器降低其发送速率。Endpoint发送**PATH_CHALLENGE**之后可以设置一个单独计时器，在接收到**PATH_RESPONSE**时再将定时器取消。如果定时器在接收到**PATH_RESPONSE**之前触发，Endpoint可能会发送一个新的**PATH_CHALLENGE**帧并设置一个更长超时时间的定时器。该定时器**应该**类似5.3节的描述设置。    

## 9.5 连接迁移的隐私保护
在多个网络路径上使用固定的连接ID使得这些Endpoint会产生一些交互。在网络之间移动的Endpoint可能不希望将其活动与除对端之外的任何实体关联，因此当从不同的本地地址发送时，将使用不同的连接ID，如第5.1节所述。要使其有效，Endpoint需要确保它们提供的连接ID不能被任何其他实体连接。    
在任何时候，Endpoint都可以将其发送的目标连接ID更改为未在其他路径上使用的值。    
如果Endpoint按照第9.2节所述启动连接迁移，或者按照第9.1节的描述探测新的网络路径，则它必须使用新的连接ID。如果对端发送的包使用了新的地址并携带了未曾使用过的连接ID，则本端**必须**在响应中也提供提供新的连接ID。    
在每个新的网络路径上，对双向发送的数据包使用不同的连接ID，可以避免不同的网络路径的ID重复。报头保护确保数据包编号不能用于关联活动。这并不妨碍数据包的其他属性（如时间和大小）用于关联活动。    
在不更改连接ID的情况下，可能会无意中更改路径。例如，在一段时间的网络不活动之后，当客户端恢复发送时，NAT重新绑定可能会导致数据包在新路径上发送。    
客户端可能希望在一段不活动的时间后发送流量时使用新的连接ID和源UDP端口来降低可链接性。更改同时发送数据包的UDP端口可能会导致数据包显示为连接迁移。更改端口号可能会导致对等端重置其拥塞状态（见第9.4节），因此应避免更改端口。    
耗尽可用连接ID的Endpoint不能探测新路径或启动迁移，也不能响应对等方的探测或迁移尝试。为了确保迁移是可能的，并且在不同路径上发送的数据包不能相互关联，Endpoint应该在对等点迁移之前提供新的连接ID；参见第5.1.1节。如果对等端可能已用尽可用的连接ID，则迁移Endpoint可以在新网络路径上发送的所有数据包中包含一个**NEW_CONNECTION_ID**帧。    

## 9.6 服务器的首选地址
QUIC允许服务器接受一个IP地址上的连接，并在握手后不久尝试将这些连接传输到更合适的地址。当客户端最初连接到多个服务器共享的地址，但希望使用单播地址来确保连接稳定性时，这一点尤其有用。本节介绍将连接迁移到首选服务器地址的协议。    

### 9.6.1 通讯首选地址
服务器通过在TLS握手中包含** preferred_address**传输参数来传输首选地址。    
服务器可以提供每个地址族(IPv4和IPv6)的首选地址，以允许客户端选择最适合其网络的地址。    
一旦握手完成，客户端应选择其中一个地址，并使用** preferred_address**传输参数中提供的连接ID启动该地址的路径验证（见第8.2节）。    
如果路径验证成功，客户端应立即开始使用新的连接ID将所有未来的数据包发送到新的服务器地址，并停止使用旧的服务器地址。 如果路径验证失败，客户端必须继续将所有未来数据包发送到服务器的原始IP地址。     

### 9.6.2 响应连接迁移
在接受连接后，服务器可能会在任何时候接收到指向其首选IP地址的数据包。如果此数据包包含一个**PATH_CHALLENGE**帧，则服务器根据第8.2节反馈一个** PATH_RESPONSE**帧。服务器必须从其原始地址发送非探测帧，直到它从客户端选择的首选地址接收到非探测数据包并验证了该路径。服务器必须从其首选地址探测指向客户端的路径，这有助于防止攻击者发起虚假迁移。    
一旦服务器完成了路径验证，并且在其首选地址上收到了一个新的最大包号的非探测包，服务器就开始从其首选IP地址开始向客户端发送非探测包。它应该丢弃在旧IP地址上接收到的此连接的数据包，但可以继续处理延迟的数据包。

### 9.6.3 客户端迁移与首选地址交互
在迁移到服务器的首选地址之前，客户端可能需要执行连接迁移。在这种情况下，客户端应该同时从客户端的新地址对原始服务器地址和首选服务器地址执行路径验证。    
如果服务器首选地址的路径验证成功，则客户端必须放弃对原始地址的验证，并迁移到使用服务器的首选地址。如果服务器首选地址的路径验证失败，但服务器的原始地址验证成功，则客户端可以迁移到其新地址并继续发送到服务器的原始地址。    
如果与服务器首选地址的连接不是来自同一个客户机地址，则服务器必须按照第9.3.1节和第9.3.2节中的描述防止潜在攻击。除了有意的同时迁移之外，这也可能是因为客户端的访问网络对服务器的首选地址使用了不同的NAT绑定。    
服务器应该在接收到来自不同地址的探测包时启动到客户端新地址的路径验证，在路径验证完成之前，服务器不能向新地址发送超过最小拥塞窗口值的非探测数据包。迁移到新地址的客户机应使用服务器同一地址族中的首选地址。    

## 9.7 IPv6流标签的使用和迁移
使用IPv6发送数据的Endpoint应用符合[RFC6437]的IPv6流标签，除非本地API不允许设置IPv6流标签。
IPv6流标签应该是源地址和目标地址、源和目标UDP端口以及目标CID的伪随机函数。

## 10 连接终止
一个活动的QUIC连接可以通过以下三种方式终止：
+ 空闲超时(10.2节)
+ 立即关闭(10.3节)
+ 无状态重置(10.4节)

如果一个Endpoint没有一个可以发送数据包的经过验证的路径，那么它可以丢弃连接状态（见第8.2节）。

### 10.1 关闭和排出的连接状态
存在关闭和排出这种连接状态，以确保连接干净地关闭，并正确地丢弃延迟或重新排序的数据包。这些状态应至少持续三倍于[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)中定义的当前探测超时（PTO）间隔。    
Endpoint在启动立即关闭后进入关闭期（第10.3节），关闭时，除非数据包包含**CONNECTION_CLOSE**帧，否则Endpoint不得发送数据包。Endpoint只保留足够的信息，以生成包含**CONNECTION_CLOSE**帧的数据包，并标识属于连接的数据包。只要有Endpoint选择的连接ID和QUIC版本是信息，就可以识别关闭连接的数据包；Endpoint可以丢弃所有其他连接状态。Endpoint可以为传入的分组保留分组保护密钥，以允许它读取和处理连接关闭帧。    
一旦一个Endpoint接收到其对等端正在关闭或正在排出的信号，则进入排出状态。虽然在其他方面与关闭状态相同，但处于排出状态的Endpoint不能发送任何数据包。一旦连接处于排出状态，就不需要保留数据包保护密钥。    
如果Endpoint接收到**CONNECTION_CLOSE**帧或无状态重置，则它可以从关闭周期过渡到排出周期，这两种情况都表明对端也正在关闭或排出。排出期应在关闭期结束时结束。换言之，Endpoint可以使用相同的结束时间，但要停止重新传输关闭的数据包。     
在关闭或排出期间结束之前处理连接状态可能会导致延迟或重新排序的数据包生成不必要的无状态重置。Endpoint要有一些方法来确保连接上迟到的数据包不会引起Endpoint的响应，例如那些能够关闭UDP套接字的Endpoint，可以使用一个缩短的排出周期，以允许更快的资源恢复。保留开放套接字以接受新连接的服务器不应提前退出关闭或排出期。    
一旦关闭或排出期结束后，Emdpoint应放弃所有连接状态。这会导致连接上的新数据包被一般性地处理。例如，Endpoint可以发送无状态重置以响应任何进一步的传入包。    
当发送无状态重置（第10.4节）时，排出和关闭周期不适用。Endpoint在关闭或排出时不需要处理密钥更新。密钥更新可能会阻止Endpoint从关闭状态移动到排出状态，但在其他方面没有影响。
在关闭期间，Endpoint可以从新的源地址接收数据包，这表示连接迁移（第9节）。处于关闭状态的Endpoint必须严格限制它发送到这个新地址的数据包的数量，直到地址被验证为止（见第8.2节）。处于关闭状态的服务器可以选择放弃从新源地址接收的数据包。

### 10.2 空闲超时
如果任一端启用了空闲超时，则当连接保持空闲状态的时间超过**max_idle_timeouts**的最小值（见第18.2节）和当前探测超时（PTO）的三倍时，连接将静默关闭，其状态将被丢弃。每个Endpoint都公布一个**max_idle_timeout**值，但是一个Endpoint的有效值被计算为两个公布值中的最小值。当设置有**max_idle_timeout**时，如果在Endpoint有超时之前放弃连接，则它应该启动立即关闭（第10.3节）。     
当从对端成功接收和处理数据包时，Endpoint重新启动其空闲计时器。当发送ack确认包时，空闲定时器也会重新启动（参见[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)），但前提是自上次接收包以来没有发送其他ack激发包。发送数据包时重新启动可确保在启动新活动时连接不会过早超时。如果Endpoint由于受到流控制限制而无法发送应用程序数据，则可能需要发送数据包以避免空闲超时；请参阅第4节。   
如果Endpoint在空闲超时时间接近结束时发送数据包，而其对端在数据包到达之前进入排出状态，则有丢弃这些数据包的风险。如果对端可能在探测超时时间内超时（PTO；请参阅[QUIC-RECOVERY](https://tools.ietf.org/html/draft-ietf-quic-recovery-27)的第6.6节），建议在发送任何无法安全重试的数据之前测试活动性。请注意，可能只有应用程序或应用程序协议才知道可以重试哪些信息。    

### 10.3 立即关闭
Endpoint发送一个CONNECTION_CLOSE帧（19.19节）来立即终止连接。CONNECTION_CLOSE帧会导致所有流立即关闭；打开的流可以假定为隐式重置。发送CONNECTION_CLOSE帧后，Endpoint立即进入关闭状态。    
在关闭期间，发送连接**CONNECTION_CLOSE**帧的Endpoint应响应对端**CONNECTION_CLOSE**的响应数据包。这样的Endpoint应该限制它生成的包含连接关闭帧的数据包的数量。例如，Endpoint可以等待接收到的包的数量或等待时间到达一定数量，然后才对接收到的包作出响应。    
当进入关闭周期（第10.1节）时，允许Endpoint丢弃数据包保护密钥，并发送包含**CONNECTION_CLOSE**的数据包以响应接收到的任何UDP数据报。但是，没有数据包保护密钥的Endpoint无法识别和丢弃无效数据包。为了避免造成无意的放大攻击，此类Endpoint必须降低发送包含**CONNECTION_CLOSE**帧的数据包的频率。为了减少Endpoint为关闭的连接所需保持的状态，Endpoint可以发送完全相同的包。    
注意：允许重新传输一个关闭的数据包与本文档中建议为每个数据包创建新的数据包编号的其他建议相矛盾。发送新的数据包号码主要有利于丢失恢复和拥塞控制，而这与闭合连接无关。重新传输最终数据包需要较少的状态。    
来自未验证地址的新数据包可用于创建放大攻击（见第8节）。为了避免这种情况，Endpoint必须将**CONNECTION_CLOSE**帧的传输限制为已验证的地址，或者如果响应比接收到的数据包大三倍以上，则必须在没有响应的情况下丢弃数据包。    
接收到**CONNECTION_CLOSE**帧后，Endpoint进入排出状态。接收到**CONNECTION_CLOSE**帧的Endpoint可以在进入排出状态之前发送包含**CONNECTION_CLOSE**帧的单个数据包，如果合适，使用**CONNECTION_CLOSE**帧和**NO_ERROR**作为响应。Endpoint不能再发送其他数据包，这可能导致连接关闭帧的不断交换，直到任何一个对等端的关闭时间结束。    
在应用协议安排关闭连接后，可以使用立即关闭。这可能是在应用程序协议协商正常关闭之后。应用程序协议交换任何需要的消息，以使两个Endpoint同意关闭连接，然后应用程序请求关闭连接。应用协议可以使用带有适当错误代码的**CONNECTION_CLOSE**帧来发出关闭信号。    

### 10.3 在握手阶段关闭连接
当发送CONNECTION_CLOSE时，目标是确保对端会处理该帧。通常情况下，会将该帧设置为最高保护级别以避免被丢弃。确认握手后（见[QUIC-TLS]第4.1.2节），Endpoint必须在1-RTT包中发送**CONNECTION_CLOSE**帧。然而，在确认握手之前，更高级的分组保护密钥可能对端不可用，因此**CONNECTION_CLOSE**帧可能会复制到较低分组保护级别的分组中。    
客户端将始终知道服务器是否有握手密钥（见17.2.2.1节），但服务器可能不知道客户端是否有握手密钥。在这种情况下，服务器应该在握手和初始数据包中发送**CONNECTION_CLOSE**帧，以确保客户端至少可以处理其中一个数据包。类似地，对端可能无法读取1-RTT数据包，因此Endpoint应在确认握手之前发送CONNECTION_CLOSE和1-RTT数据包。这些数据包可以合并成一个单独的UDP数据报；见第12.2节。    
Endpoint可以在初始包中或响应初始包或握手包中接收到的未经验证的信息时，发送**CONNECTION_CLOSE**帧。这种立即关闭可能会使合法连接拒绝服务。QUIC没有握手过程中对路径攻击的防御措施；见第21.1节。但是，如果Endpoint丢弃非法数据包，而不是在连接关闭时终止连接，则以减少合法对端的错误反馈为代价，某些形式的拒绝服务可能会使攻击更加困难。因此，如果在缺少身份验证的数据包中检测到错误，Endpoint可能会丢弃数据包，而不是立即关闭。  
尚未建立状态的Endpoint（如在初始数据包中检测到错误的服务器）不会进入关闭状态。没有连接状态的Endpoint在发送**CONNECTION_CLOSE**帧时不会进入关闭或排出状态。

## 10.4 无状态重置
对于不能访问连接状态的Endpoint，提供无状态重置作为最后的选择。崩溃或中断可能会导致对端继续向无法正常继续连接的Endpoint发送数据。Endpoint可以发送无状态重置以响应接收到它不能与活动连接关联的包。    
无状态重置不适用于信号错误情况。希望传递致命连接错误的Endpoint必须使用**CONNECTION_CLOSE**帧（如果它有足够的状态这样做）。    
为了支持这个过程，Endpoint发送一个Token。Token携带在**NEW_CONNECTION_ID**帧的**Stateless Reset Token**字段中。服务器还可以在握手过程中指定一个**stateless_reset_token**传输参数，该参数应用于它在握手过程中选择的连接ID；客户端无法使用此传输参数，因为它们的传输参数没有保密保护。这些令牌受加密保护，因此只有对应的客户端和服务器知道它们的值。当Tockens关联的连接标识通过**RETIRE_CONNECTION_ID**确认失效时，Tocken也会失效（第19.16节）。    
接收无法处理的数据包的Endpoint按以下布局发送数据包：    
```
0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|1|               Unpredictable Bits (38 ..)                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                   Stateless Reset Token (128)                 +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        图 6: 无状态重置包
```
这种设计确保无状态重置数据包尽可能接近具有短报头的常规数据包。
无状态重置使用整个UDP数据报，从包头的前两位开始。第一个字节的剩余部分及其后面的任意数量的字节被设置为不可预测的值。数据报的最后16个字节包含无状态重置Token。    
对于目标接收方以外的实体，无状态重置将显示为具有短标头的包。要使无状态重置显示为有效的QUIC数据包，不可预测的位字段至少需要包含38位数据（或5个字节，减去两个固定位）。    
最小大小的21比特不能保障将无状态重置包与其他要求使用连接ID的包区分开。为了防止产生的无状态重置与有效数据包之间的无法区分，Endpoint发送的所有数据包都应填充到比Endpoint可能使用的最小连接ID长，至少要22字节的长度。    
这些值假定无状态重置令牌与包保护AEAD的最小扩展相同。如果Endpoint可以协商具有较大最小扩展的数据包保护方案，则需要额外的不可预测字节。    
Endpoint不能发送比接收到的数据包大三倍或更多的无状态重置，以避免被用于放大攻击。第10.4.3节描述了无状态重置大小的附加限制。    
Endpoint必须丢弃太小而不能成为有效QUIC数据包的数据包。在[QUIC-TLS]中定义的AEAD函数集中，小于21字节的数据包永远无效。    
Endpoint必须发送格式化为具有短报头的无状态重置数据包。但是，Endpoint必须将以有效的无状态重置令牌结尾的任何数据包视为无状态重置，因为其他QUIC版本可能允许使用长标头。    
Endpoint可以发送无状态重置以响应具有长报头的包。在对端可以使用无状态重置Token之前，发送无状态重置无效。在本文的QUIC版本中，具有长报头的包只在建立连接时使用。因为在连接建立完成或接近完成之前，无状态重置令牌不可用，因此忽略具有长标头的未知包可能与发送无状态重置一样有效。    
Endpoint无法从具有短标头的数据包中确定源连接ID，因此无法在无状态重置数据包中设置目标连接ID。因此，目的地连接ID将不同于以前的数据包中使用的值。随机的目的地连接ID看起来像是通过**NEW_CONNECTION_ID**帧而使用了新的连接ID。    
使用随机连接ID会导致两个问题： 
+ 数据包可能无法到达对端。如果目的地连接ID对于路由到对等端至关重要，则此数据包可能被错误地路由。这也可能会触发另一个无状态重置响应；参见第10.4.3节。未正确路由的无状态重置是无效的。在这种情况下，Endpoint将需要依赖其他方法（如计时器）来检测连接是否失败。
+ 随机生成的连接ID可由对等方以外的实体使用，会将其识别为潜在的无状态重置。偶尔使用不同连接ID的Endpoint可能会带来一些不确定性。    
这种无状态重置设计特定于QUIC初始版本。支持多个版本QUIC的Endpoint需要生成一个无状态重置，该重置将适用Endpoint可能支持的任何版本（或在失去状态之前可能已支持）的对等方所接受。QUIC新版本的设计者需要意识到这一点，要么重用这个设计，要么使用数据包的一部分而不是最后16个字节来传输数据。    

### 10.4.1 检测无状态重置
Endpoint使用UDP数据报的尾部16个字节检测潜在的无状态重置。Endpoint会记住所有与无状态重置token关联的连接ID和最近发送数据的远端地址。这包括来自**NEW_CONNECTION_ID**帧和服务器传输参数的无状态重置令牌，但不包括与未使用或失效的连接标识关联的无状态重置令牌。Endpoint通过将数据报的最后16个字节与接收数据报的远程地址相关联的无状态重置令牌做比较，判断是否接收到的数据报标识为无状态重置。    
可以对接收的每个数据包做上述比较。如果成功处理来自数据报的任何数据包，则Endpoint可能跳过此检查。但是，当传入数据报中的第一个数据包无法与连接关联或无法解密时，必须执行比较。Endpoint不能检查与它未使用的连接ID相关联的任何无状态重置标记，也不能检查已失效的连接ID。    
将数据报与无状态重置令牌值进行比较时，Endpoint执行的比较不能泄漏有关令牌值的信息。例如，在恒定时间内执行此类比较可保护单个无状态重置令牌的值，使其不会通过定时侧通道泄漏信息(不懂)。另一种方法是存储和比较无状态重置令牌的转换值，而不是原始令牌值，其中转换被定义为使用密钥的加密安全伪随机函数（例如，块密码、HMAC[RFC2104]）。    
如果数据报的最后16个字节的值与无状态重置令牌的值相同，则Endpoint必须进入排出期，并且不再在此连接上发送任何之后的数据包。    

### 10.4.2 计算无状态重置token
无状体重置的Token一定要很难被猜中。为了创建无状态重置令牌，Endpoint可以为它创建的每个连接随机生成[RFC4086]一个秘密。但是，当集群中有多个实例时这会带来协调问题，或者Endpoint的存储问题也可能导致状态丢失(密钥丢失)。无状态重置专门用于处理状态丢失的情况，因此这种方法是次优的。    
一个静态密钥可以在同一个Endpoint的所有连接之间使用，方法是使用一个防镜像函数的第二次迭代生成证明，该函数将静态密钥和Endpoint选择的连接ID（见第5.1节）作为输入。Endpoint可以使用HMAC[RFC2104](https://tools.ietf.org/html/rfc2104)（例如，HMAC（static_key，connection_id））或HKDF[RFC5869](https://tools.ietf.org/html/rfc5869)（例如，使用静态键作为input keying material，连接id为salt）。此函数的输出被截断为16个字节，以生成该连接的无状态重置令牌。       
失去状态的Endpoint可以使用相同的方法来生成有效的无状态重置令牌。连接ID来自Endpoint接收的数据包。    
这种设计依赖于对等方总是在其数据包中发送连接ID，这样Endpoint就可以使用数据包中的连接ID来重置连接。使用此设计的Endpoint必须对所有连接使用相同的连接ID长度，或者对连接ID的长度进行编码，以便可以在没有状态的情况下恢复。此外，它不能提供长度为零的连接ID。    
暴露无状态重置令牌允许任何实体终止连接，因此一个值只能使用一次。这种选择无状态重置令牌的方法意味着连接ID和静态密钥的组合不能用于另一个连接。如果共享静态密钥的实例使用相同的连接ID，或者攻击者可以将数据包路由到没有状态但只有相同静态密钥的实例，则可能发生拒绝服务攻击；请参阅第21.9节。对于共享静态密钥的节点上的新连接，不能重用被无状态重置令牌而重置的连接ID。    
同一个无状态重置令牌不能用于多个连接ID。Endpoint不需要将新值与所有以前的值进行比较，但重复值可能会被视为**PROTOCOL_VIOLATION**类型的连接错误。    
请注意，无状态重置数据包没有任何加密保护。

### 10.4.3 循环
这样的无状态重置设计，在不知道无状态重置Token的情况下，它与有效的数据包无法区分。例如，如果一个服务器向另一个服务器发送一个无状态重置，它可能会收到另一个无状态重置作为响应，这可能导致无限的交换。    
Endpoint必须确保它发送的每个无状态重置都小于触发它的包，除非它保持足够的状态以防止循环。在循环的情况下，这会导致数据包最终太小而无法触发响应。Endpoint可以记住它已发送的无状态重置数据包的数量，并在达到限制后停止生成新的无状态重置数据包。    
对不同的远程地址使用单独的限制将确保当其他对等方或连接已用尽限制时，可以使用无状态重置数据包来关闭连接。    
将无状态重置的大小减少到41字节以下意味着包可以向观察者显示它是无状态重置，这取决于对等方的连接ID的长度。相反，拒绝响应小数据包发送无状态重置可能会导致无状态重置连接断开的情况下不起作用(发送方无法获得重置响应)；此类故障可能只能通过其他方法（如计时器）检测到。     

## 11 错误处理
检测到错误的Endpoint应该向其对端发出该错误存在的信号。传输级错误和应用程序级错误都会影响整个连接（见11.1节），而只有应用程序级的错误才能被隔离到单个流中（见11.2节）。
适当的错误码（第20节）应包含在发出错误信号的帧中。当这个规则判断错误时，它也会识别所使用的错误码；尽管这些错误码被描述为需求，但是不同的实现策略可能会导致报告不同的错误。特别是，当Endpoint检测到错误情况时，它可以使用任何适用的错误代码；通常可以使用通用错误代码（如**PROTOCOL_VIOLATION**或**INTERNAL_ERROR**）来代替特定的错误代码。无状态重置（第10.4节）不适用于任何可以通过**CONNECTION_CLOSE**或**RESET_STREAM**帧触发的错误。具有在连接上发送帧所需的状态的Endpoint不得使用无状态重置。    

### 11.1 连接错误
导致连接不可用的错误，如明显违反协议语义或影响整个连接的状态损坏，必须使用**CONNECTION_CLOSE**帧发出信号（第19.19节）。Endpoint可以以这种方式关闭连接，即使错误只影响单个流。    
应用程序协议可以使用**CONNECTION_CLOSE**帧的来报告应用程序的协议错误。特定于传输的错误，包括本文档中描述的所有错误，都包含在**CONNECTION_CLOSE**中。    
**CONNECTION_CLOSE**可以包含在丢失重传的包中，如果一个Endpoint在一个终止的连接上依然收到更多的数据包，那么它应该在重新传输的包中设置**CONNECTION_CLOSE**。    
如果Endpoint不在重传包中包含**CONNECTION_CLOSE**帧，则对等端可能会丢失第一个此类数据包。Endpoint继续接收终止连接的数据的唯一机制是使用无状态重置过程（第10.4节）。    

### 11.2 Stream错误
如果一个应用层的错误影响了一个Stream，但是连接处于可用状态，那么Endpoint可以发送**RESET_STREAM**帧（19.4节）并携带一个应用层错误码来终止此Stream。    
在没有应用程序协议参与的情况下重置流可能会导致应用程序协议进入不可恢复状态。重置流只能由使用QUIC的应用程序协议发起。    
应用协议定义了重置流中的应用错误代码的语义。只有应用协议才能导致流终止。应用程序协议的本地实例使用直接API调用，远程实例使用**STOP_SENDING**帧，都将触发**RESET_STREAM**。    
应用程序协议应该定义规则以处理被任一Endpoint过早取消流的情况。    

## 12 包和帧定义
QUIC通过交换数据包来进行交互，数据包具有保密性和完整性保护，并通过UDP数据报传输。    
此版本的QUIC在建立连接期间使用长数据包报头（见第17.2节）。具有长报头的数据包是初始包（第17.2.2节）、0-RTT包（第17.2.3节）、握手包（第17.2.4节）和重试包（第17.2.5节）。版本协商使用一个具有长报头的独立于版本的数据包（见第17.2.1节）。    
具有短报头的数据包（17.3节）是为减小交互开销而设计的，并且在建立连接和1-RTT密钥可用后使用。    

### 12.1  受保护的数据包
除版本协商数据包外，所有QUIC数据包都使用经过身份验证的附加数据加密（AEAD）[RFC5116]来提供机密性和完整性保护。重试数据包使用AEAD提供完整性保护。有关数据包保护的详细信息，请参阅[QUIC-TLS]；本节概述了该过程。    
初始数据包使用静态派生的密钥进行保护。这种保护并不严谨。初始保护只存在于确保数据包的发送方在网络路径上。从客户端接收初始数据包的任何实体都可以恢复必要的密钥，以删除数据包保护或生成将成功验证的数据包。    
所有其他数据包都使用从加密握手派生的密钥进行保护。来自长报头的数据包类型或来自短报头的密钥阶段的数据包类型用于标识所使用的加密级别以及密钥。使用0-RTT和1-RTT密钥保护的数据包应具有机密性和数据源身份的验证；加密握手确保只有通信Endpoint接收到相应的密钥。    
数据包编号字段包含一个数据包编号，在应用数据包保护后，该数据包具有附加的保密性保护（有关详细信息，请参阅[QUIC-TLS]）。 在给定的数据包编号空间中，每发送一个数据包，基础数据包的编号就会增加；有关详细信息，请参阅第12.3节。    

### 12.2 合并数据包
初始（第17.2.2节）、0-RTT（第17.2.3节）和握手（第17.2.4节）数据包包含一个长度字段，该字段确定数据包的结尾。长度包括包号和有效载荷字段，这两个字段都是保密的，并且最初长度未知。卸下包头保护后，有效负载字段的长度即被读入。    
使用Length字段，发送方可以将多个QUIC数据包合并为一个UDP数据报。这可以减少完成加密握手并开始发送数据所需的UDP数据报的数量。这也可用于构建PMTU探针（见第14.3.1节）。接收器必须能够处理合并的数据包。    
按照加密级别（初始、0-RTT、握手、1-RTT）的顺序合并数据包，使接收器更有可能在一次传递中处理所有数据包。具有短报头的数据包不包含长度，因此它只能是UDP数据报中包含的最后一个数据包。Endpoint不应合并同一加密级别的多个数据包。    
发送方不得将不同连接的QUIC数据包合并为单个UDP数据报。接收者应该忽略与数据报中第一个数据包具有不同目的地连接ID的任何后续数据包。    
合并成单个UDP数据报的每个QUIC包都是独立的和完整的。合并QUIC包的接收方必须单独处理每个QUIC包并分别确认它们，就像它们是作为不同UDP数据报的有效载荷接收的一样。例如，如果解密失败（因为密钥不可用或任何其他原因），接收器可以丢弃或缓冲该分组以备以后处理，并且必须尝试处理剩余的分组。     
 重试数据包（第17.2.5节）、版本协商数据包（第17.2.1节）和具有短标头的数据包（第17.3节）不包含长度字段，因此不能跟在同一UDP数据报中的其他数据包后面。还请注意，不存在重试或版本协商数据包与另一个数据包合并的情况。 

### 12.3 数据包编号

### 12.3 数据包编号
 数据包编号是0到2^62-1范围内的整数。此数字用于确定数据包保护的加密现时值。每个Endpoint都为发送和接收维护一个单独的包编号。分组号被限制在这个范围内，因为它们需要在ACK帧的最大确认字段中被整体地表示（第19.3节）。然而，当出现在长或短报头中时，分组号被减少并以1到4字节编码（见第17.1节）。    
版本协商（第17.2.1节）和重试（第17.2.5节）数据包不包括数据包编号。
在QUIC中，数据包编号分为3个空间：    
+ 初始空间：所有初始包（第17.2.2节）都在这个空间中。  
+ 握手空间：所有握手包（第17.2.4节）都在此空间中。
+ 应用程序数据空间：所有0-RTT和1-RTT加密包（第12.1节）都在这个空间中。    
如[QUIC-TLS]所述，每种数据包类型使用不同的保护密钥。    
从概念上讲，包编号空间可以处理和确认包的上下文。初始包只能用初始包保护密钥发送，并且在也是初始包的包中进行确认。类似地，握手分组在握手加密级别发送，并且只能在握手分组中被确认。这将强制在不同分组序列号空间中发送的数据之间进行加密分离。每个空间中的数据包编号从0开始。在同一数据包编号空间中发送的后续数据包必须将数据包编号至少增加一个。0-RTT和1-RTT数据存在于同一个包数空间中，使得两种包类型之间的丢失恢复算法更容易实现。    
QUICEndpoint不能在一个连接中重用同一数据包编号空间内的数据包编号。如果发送的数据包编号达到2^62-1，发送方必须关闭连接，而不发送**CONNECTION_CLOSE**帧或任何其他数据包；Endpoint可以发送无状态重置（第10.4节），以响应其接收到的更多数据包。    
接收器必须丢弃一个新的未受保护的包，除非它确定它没有处理来自同一个包编号空间的另一个包。由于[QUIC-TLS]第9.3节中所述的原因，删除包保护后必须进行重复抑制。重复抑制的有效算法见[RFC4303]第3.4.3节。    
第17.1节描述了在发送方处的分组号编码和在接收机处的解码。

### 12.4 帧和帧的类型 
去除包保护后，QUIC包的有效负载由一系列完整的帧组成，如图7所示。版本协商、无状态重置和重试数据包不包含帧。    
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame 1 (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame 2 (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame N (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                           图 7: QUIC 的数据负载
```
包含帧的包的有效载荷必须至少包含一个帧，并且可以包含多个帧和多钟帧类型。帧总是适合一个QUIC包，不能跨越多个包。    
每个帧以一个帧类型开头，指示其类型，后跟其他类型相关字段：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Frame Type (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-Dependent Fields (*)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                           图 8: 帧布局
```
表3列出了本规范中定义的帧类型。**ACK**、**STREAM**、**MAX_STREAMS**、**STREAMS_BLOCKED**和**CONNECTION_CLOSE**帧的用于携带其他帧特定的标志。对于所有其他帧，帧类型字段只标识帧，这些帧在第19节中有更详细的说明。
```
     +-------------+----------------------+---------------+---------+
     | Type Value  | Frame Type Name      | Definition    | Packets |
     +=============+======================+===============+=========+
     | 0x00        | PADDING              | Section 19.1  | IH01    |
     +-------------+----------------------+---------------+---------+
     | 0x01        | PING                 | Section 19.2  | IH01    |
     +-------------+----------------------+---------------+---------+
     | 0x02 - 0x03 | ACK                  | Section 19.3  | IH_1    |
     +-------------+----------------------+---------------+---------+
     | 0x04        | RESET_STREAM         | Section 19.4  | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x05        | STOP_SENDING         | Section 19.5  | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x06        | CRYPTO               | Section 19.6  | IH_1    |
     +-------------+----------------------+---------------+---------+
     | 0x07        | NEW_TOKEN            | Section 19.7  | ___1    |
     +-------------+----------------------+---------------+---------+
     | 0x08 - 0x0f | STREAM               | Section 19.8  | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x10        | MAX_DATA             | Section 19.9  | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x11        | MAX_STREAM_DATA      | Section 19.10 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x12 - 0x13 | MAX_STREAMS          | Section 19.11 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x14        | DATA_BLOCKED         | Section 19.12 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x15        | STREAM_DATA_BLOCKED  | Section 19.13 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x16 - 0x17 | STREAMS_BLOCKED      | Section 19.14 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x18        | NEW_CONNECTION_ID    | Section 19.15 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x19        | RETIRE_CONNECTION_ID | Section 19.16 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x1a        | PATH_CHALLENGE       | Section 19.17 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x1b        | PATH_RESPONSE        | Section 19.18 | __01    |
     +-------------+----------------------+---------------+---------+
     | 0x1c - 0x1d | CONNECTION_CLOSE     | Section 19.19 | IH_1*   |
     +-------------+----------------------+---------------+---------+
     | 0x1e        | HANDSHAKE_DONE       | Section 19.20 | ___1    |
     +-------------+----------------------+---------------+---------+

							  表 3: 帧类型
```
表3中的“数据包”列不构成IANA注册表的一部分（见第22.3节）。此列列出了每种帧类型可以出现的数据包类型，由以下字符表示：
+ I:  初始包 (17.2.2节)
+ H:  握手报 (17.2.4节)
+ 0:  0-RTT包 (17.2.3节)
+ 1:  1-RTT包 (17.3节)
+ '*' :     0x1c类型的**CONNECTION_CLOSE**帧可以出现在初始、握手和1-RTT数据包中，而0x1d类型的**CONNECTION_CLOSE**帧只能出现在1-RTT数据包中。    
第4节[QUIC-TLS]提供了有关这些限制的更多详细信息。请注意，所有帧都可以出现在1-RTT包中。    
Endpoint必须将接收到的未知类型的帧视为**FRAME_ENCODING_ERROR**类型的连接错误。   
在这个版本的QUIC中，所有的QUIC帧都是幂等的。也就是说，一个有效的帧在多次接收时不会引起不良的副作用或错误。    
帧类型字段使用可变长度整数编码（见第16节），除了一个例外。为了确保帧解析的简单高效，帧类型必须使用尽可能短的编码。对于本文档中定义的帧类型，这意味着使用单字节编码，即使可以将这些值编码为2字节、4字节或8字节可变长度整数。例如，尽管0x4001是值为1的可变长度整数的合法双字节编码，但**PING**帧始终被编码为值为0x01的单字节。此规则适用于所有当前和未来的QUIC帧类型。Endpoint可以将接收到的帧类型（使用的编码长度超过所需长度）视为**PROTOCOL_VIOLATION**类型的连接错误。    

## 13 包处理和可靠性传输
发送方将一个或多个帧捆绑在一个QUIC包中（见第12.4节）。发送方可以通过将尽可能多的帧捆绑在一个QUIC包中，从而使每包带宽和计算成本最小化。发送方可以在发送量未达到最大化包之前等待一定时间来捆绑多个帧，以避免发送大量的小分组。 实现可以使用有关应用程序发送行为或启发式的算法来确定是否等待以及等待多长时间。这个等待期是一个实现决定，实现应该谨慎地延迟，因为任何延迟都可能增加应用程序可见的延迟。   
流复用是通过将来自多个流的帧交织成一个或多个QUIC包来实现的。单个QUIC包可以包括来自一个或多个流的多个帧。    
QUIC的好处之一是避免了跨多个流的头部阻塞。当发生分组丢失时，只有在该分组中有数据的流被阻塞，等待重新传输，而其他流可以继续进行。请注意，当来自多个流的数据被捆绑到一个QUIC包中时，该包的丢失会阻塞所有这些流。建议实现将尽可能少的流捆绑在传出数据包中，这不会使未满数据包的传输效率降低。    

### 13.1 数据包处理
在包保护被成功移除并且包携带的所有帧都已被处理之前，包不能被确认。对于流帧，这意味着数据已经排队，准备由应用程序协议接收，但还不能交付应用。一旦包被完全处理，接收机通过发送一个或多个包含所接收包的分组号的**ACK**帧来确认接收。

### 13.2 生成确认
Endpoint确认它们接收和处理的所有数据包。然而，只有ack引起的分组才导致在最大**ACK**延迟内发送ack帧。只有当由于其他原因发送了一个ack帧时，才会确认没有应答的包。   
当出于任何原因发送包时，如果最近没有发送ACK帧，那么Endpoint应该尝试绑定ACK帧。这样做有助于在对端及时检测丢失。一般来说，来自接收器的频繁反馈改善了丢失和拥塞响应，但这必须与接收器产生的过多ACK包相平衡。下面提供的指导旨在实现这一平衡。    

### 13.2.1 发送ACK帧
每一个包应该至少被确认一次，并且在最大的ack延迟内必须至少确认一次ack发出包。Endpoint使用**max_ack_delay**传输参数通信其最大延迟；见第18.2节。**max_ack_delay**参数声明了一个显式约定：Endpoint承诺永远不会故意延迟ack发送而超过该值。如果是这样的话，任何超出的部分都会累积到RTT估计中，并可能导致来自对等方的错误或延迟的重传。对于初始数据包和握手数据包，不使用延迟确认。发送方使用接收方的**max_ack_delay**值来确定基于定时器的重传的超时，如[QUIC-RECOVERY]第5.2.1节所述。
应至少每秒钟生成一个ACK帧，以获取分组发送。本建议符合TCP的标准做法[RFC5681]。为了协助发送方的丢失检测，Endpoint应在接收到无序到达包时立即发送ACK帧。Endpoint可以继续在随后接收到的每个分组上立即发送ACK帧，但是Endpoint应该在1/8 RTT的时间段内返回到对每个其他分组的确认，除非无序地接收到更多的ACK激发分组（存疑）。如果每个后续的数据包都无序到达，则应该为每个接收到的数据包包立即发送一个ack帧。    
类似地，在IP报头中标记有ECN拥塞经历（CE）码位的包应该被立即确认，以减少对等方对拥塞事件的响应时间。   
作为优化，接收机可以在响应发送任何ACK帧之前处理多个分组。在这种情况下，接收器可以确定在处理传入的分组之后是应该生成立即确认还是延迟确认。   
为了拥塞控制目的，包含**PADDING**帧的包被认为是在in flight的[QUIC-RECOVERY]。
只发送**PADDING**帧可能会导致发送方因没有接收到确认而被拥塞控制器阻塞。因此，发送方应该确保除了**PADDING**帧外，还发送其他帧以从接收方获取确认。    
一个只发送**ACK**帧的Endpoint将不会从它的对等方接收到确认，除非**ACK**帧是被稍带发送的。当有新的数据包要确认时，Endpoint应该将ACK帧与其他帧捆绑在一起。   
[QUIC-RECOVERY]中的算法对不遵循上述指导的接收机具有选择性。然而，只有在仔细考虑了这样做对性能的影响之后，实现者才应该偏离这些需求。    
只包含ACK帧的数据包不受拥塞控制，因此要限制它们的发送频率。一个Endpoint不能发送一个以上的只包含一个ACK帧的数据包，以确认接收到一个数据包。限制ACK帧可以避免应答的无限反馈循环，这可以防止连接变得空闲。    
Endpoint应该将接收到的未发送的数据包的确认视为**PROTOCOL_VIOLATION**类型的连接错误，如果Endpoint能够检测到这种情况。    

### 13.2.2 管理ACK范围
当发送ACK帧时，包括一个或多个已确认分组的范围。ACK帧应该始终确认最近接收到的分组，并且分组越乱，就越需要快速发送更新的ACK帧，以防止对等方误判数据包丢失并错误地重新传输。一个ACK帧应该只填充一个QUIC包，如果没有，则忽略旧的范围（包数最小的那些）。    
第13.2.3节和第13.2.4节描述了一种用于确定在每个ACK帧中确认哪些分组的示例性方法。    

### 13.2.3 接收ACK帧
当发送包含**ACK**帧的分组时，可以保存该帧中的最大确认。当包含ACK帧的分组被确认时，接收机可以停止发送小于或等于此**ACK**帧中最大确认编号的ACK。    
在没有ACK帧丢失的情况下，该算法允许最少1 RTT的重新排序。数据包可能被无序接收，包含它们的所有后续ACK帧都可能丢失。在这种情况下，丢失恢复算法可能会导致虚假的重传，但发送方将继续发送后续数据。    

### 13.2.4 限制确认范围
为了将ACK范围（见第19.3.1节）限制在发送方尚未接收到的范围内，接收方应跟踪其对端已确认哪些ACK帧。接收机应该从将来的ACK帧中排除已经确认的包，以防止不必要地影响ACK帧的大小。当接收器仅发送非ack激发包时，它可以将**PING**或其他小的ack激发帧与其中的一部分捆绑在一起，例如每往返一次，以允许丢弃不必要的ack范围和先前发送的包的任何状态。为了避免应答的无限反馈循环，接收器不能将一个ack-executing帧（如PING）与所有非ack-elicing的包捆绑在一起。   
为了限制接收机状态或ACK帧的大小，接收机可以限制它发送的ACK范围的数量。即使没有接收到对其ACK帧的确认，接收方也可以这样做，因为知道这可能导致发送方不必要地重新传输一些数据。标准QUIC算法（[QUIC-RECOVERY]）在确认足够新的数据包后确认数据包丢失。因此，相对于过去接收到的分组，接收机应该重复地确认新接收到的分组。    

### 13.2.5 测量和报告主机延迟
Endpoint要测量从接收到最大编号包到发送ACK之前的主动延迟。端点在**ACK**帧的**Ack Delay**字段中对该延迟进行编码（见第19.3节）。这允许ACK的接收者针对任何有意的延迟进行调整，这对于更好地估计路径RTT非常重要。数据包在被处理之前可能被保存在操作系统内核或主机上的其他地方。当填充**ACK**帧中的Ack Delay字段时，端点不能包括不受它控制的延迟。    

### 13.2.6 ACK帧和包保护
ACK帧只能被与被确认的数据包具有相同包号空间的包携带（见第12.1节）。例如，必须在同时使用1-RTT密钥保护的数据包中确认使用1-RTT密钥保护的数据包。这可能意味着，如果服务器加密握手消息延迟或丢失，客户端将无法使用这些确认。注意，同样的限制也适用于受1-RTT密钥保护的服务器发送的其他数据。    

## 13.3 信息转发
被确定丢失的QUIC包不会被整体重传。这适用于相同帧内的丢失数据包。相反，在帧中可能携带的信息根据需要再次在新帧中发送。    
新的帧和数据包被用来携带已经丢失的信息。一般来说，当包含该信息的包被确定为丢失时，再次发送信息，并且在确认包含该信息的分组时停止发送。    
+ 在加密帧中发送的数据将根据[QUIC-RECOVERY]中的规则重新传输，直到所有数据都得到确认。 当相应加密级别的密钥被丢弃时，初始和握手包的加密帧中的数据被丢弃。     
+ 在**STREAM**帧中发送的应用程序数据将在新的**STREAM**帧中重新传输，除非端点已为该流发送了**RESET_STREAM**帧。一旦一个端点发送了一个**RESET_STREAM**帧，就不需要进一步的**STREAM**帧了。    
+ 如第13.2.1节所述，ACK帧携带来自最大确认分组的最新确认集合和ACK延迟。    
+ 延迟包含ACK帧的包的传输或发送旧的ACK帧会导致对等方生成膨胀的RTT样本或不必要地禁用ECN。
+ 直到**RESET_STREAM**帧中携带的流传输取消被确认，或者所有流数据被对等方确认（即，在流的发送部分达到"Reset Recvd"或"Data Recvd"状态）。重置流帧的内容在再次发送时不得更改。
+ 类似地，在**STOP_SENDING**帧中的取消流传输请求被发送，直到流的接收部分进入"Data Recvd”或"Reset Recvd”状态。见3.5节。 
+ 当检测到包丢失时，连接关闭信号，包括包**CONNECTION_CLOSE**帧的包不会再次发送，但如第10节所述。
+ 当前连接的最大数据在**MAX_DATA**帧中发送。如果包含最近发送的**MAX_DATA**帧的包被确认丢失，或者当Endpoint决定更新限制时，将在**MAX_DATA**帧中发送更新的值。必须注意避免过多地发送此帧，因为此限制可能会频繁增加，并导致发送不必要的大量**MAX_DATA**帧。
+ 当前数据流中最大偏移量在**MAX_STREAM_DATA**帧中发送。与**MAX_DATA**一样，当包含流的最新**MAX_STREAM_DATA**帧的数据包丢失或更新限制时，发送更新的值，并注意防止帧发送太频繁。当流的接收部分进入"Size Known"状态时，端点应停止发送**MAX_STREAM_DATA**帧。
+ 给定类型的流的限制在**MAX_STREAMS**帧中发送。与**MAX_DATA**一样，当包含最新**MAX_STREAMS**帧的数据包被确认丢失或更新限制时，发送更新的值，并注意防止帧发送太频繁。    
+ 阻塞信号在**DATA_BLOCKED**, **STREAM_DATA_BLOCKED**, **STREAMS_BLOCKED**帧中传输。**DATA_BLOCKED**帧适用于连接，**STREAM_DATA_BLOCKED**适用于Stream，**STREAMS_BLOCKED**帧的适用于特定的流类型。如果最近的此类帧丢失，则发送新的帧，但仅当端点因相应的限制上被阻止时。这些帧总是包含导致传输阻塞时的限制值。


