
# 使用TLS保护QUIC草案
## 摘要
本文描述了如何使用传输层安全性（TLS）来保护QUIC。

## 读者须知
本草案的讨论在QUIC工作组邮件列表中进行(quic@ietf.org)，存档于https://mailarchive.ietf.org/arch/search/?email_list=quic(https://mailarchive.ietf.org/arch/search/?email_list=quic).

工作组信息可在https://github.com/quicwg(https://github.com/quicwg);  
此草案的源代码和问题列表可在https://github.com/quicwg/base-drafts/labels/-
tls (https://github.com/quicwg/base-drafts/labels/-tls).

## 版权
版权所有（c）2020 IETF Trust和文件作者。

## 目录
<!-- TOC -->

- [使用TLS保护QUIC草案](#使用tls保护quic草案)
  - [摘要](#摘要)
  - [读者须知](#读者须知)
  - [版权](#版权)
  - [目录](#目录)
  - [1 简介](#1-简介)
  - [2 符号约定](#2-符号约定)
  - [2.1 TLS概述](#21-tls概述)
  - [3 协议概述](#3-协议概述)
  - [4 携带TLS信息](#4-携带tls信息)
    - [4.1 TLS接口](#41-tls接口)
      - [4.1.1 握手完成](#411-握手完成)
      - [4.1.2 握手确认](#412-握手确认)
      - [4.1.3 发送和接收握手消息](#413-发送和接收握手消息)
      - [4.1.4 加密级别更改](#414-加密级别更改)
      - [4.1.5 TLS接口摘要](#415-tls接口摘要)
    - [4.2 TLS版本](#42-tls版本)
    - [4.3 ClientHello大小](#43-clienthello大小)
    - [4.4 对等身份验证](#44-对等身份验证)
    - [4.5 启用0-RTT](#45-启用0-rtt)
    - [4.6 接受和拒绝0-RTT](#46-接受和拒绝0-rtt)
    - [4.7 验证0-RTT配置](#47-验证0-rtt配置)
    - [4.8 HelloRetryRequest](#48-helloretryrequest)
    - [4.9 TLS错误](#49-tls错误)
    - [4.10 丢弃未使用的密钥](#410-丢弃未使用的密钥)
      - [4.10.1 丢弃初始密钥](#4101-丢弃初始密钥)
      - [4.10.2 丢弃握手密钥](#4102-丢弃握手密钥)
      - [4.10.3 丢弃0-RTT密钥](#4103-丢弃0-rtt密钥)
  - [5 包保护](#5-包保护)
    - [5.1 数据包保护密钥](#51-数据包保护密钥)
    - [5.2 初始加密](#52-初始加密)
    - [5.3 AEAD使用](#53-aead使用)
    - [5.4 包头保护](#54-包头保护)
    - [5.4.1 应用头保护](#541-应用头保护)
    - [5.4.2 包头保护示例](#542-包头保护示例)
    - [5.4.3 基于AES的包头保护](#543-基于aes的包头保护)
    - [5.4.4 基于ChaCha20的包头保护](#544-基于chacha20的包头保护)
    - [5.4.5 接收受保护的数据包](#545-接收受保护的数据包)
    - [5.6 使用0-RTT密钥](#56-使用0-rtt密钥)
    - [5.7 无序接收受保护的帧](#57-无序接收受保护的帧)
    - [5.8 重试数据包的完整性](#58-重试数据包的完整性)
  - [6 密钥更新](#6-密钥更新)
    - [6.1 启动密钥更新](#61-启动密钥更新)
    - [6.2 响应密钥更新](#62-响应密钥更新)
    - [6.3 接收密钥生成的时间](#63-接收密钥生成的时间)
    - [6.4 使用更新的密钥发送](#64-使用更新的密钥发送)
    - [6.5 使用不同的密钥接收](#65-使用不同的密钥接收)
    - [6.6 密钥更新频率](#66-密钥更新频率)
    - [6.7 密钥更新错误码](#67-密钥更新错误码)
  - [7 初始消息的安全性](#7-初始消息的安全性)
  - [8 TLS握手的QUIC特定附加功能](#8-tls握手的quic特定附加功能)
    - [8.1 协议协商](#81-协议协商)
    - [8.2 QUIC传输参数扩展](#82-quic传输参数扩展)
    - [8.3 删除EndOfEarlyData 消息](#83-删除endofearlydata-消息)
  - [9 安全考虑因素](#9-安全考虑因素)
    - [9.1 使用0-RTT重放攻击](#91-使用0-rtt重放攻击)
    - [9.2 缓解包反射攻击](#92-缓解包反射攻击)
    - [9.3 包头保护分析](#93-包头保护分析)
    - [9.4 包头保护Timing Side-Channels](#94-包头保护timing-side-channels)
    - [9.5 密钥多样性](#95-密钥多样性)
  - [10 IANA考虑](#10-iana考虑)
  - [11 引用](#11-引用)
    - [11.1 规范性引用文件](#111-规范性引用文件)
    - [11.2 资料性引用](#112-资料性引用)
  - [附录](#附录)

<!-- /TOC -->

## 1 简介
本文档描述了如何使用TLS[TLS13]保护QUIC[QUIC-TRANSPORT]。    
TLS 1.3为以前版本的连接建立提供了关键的延迟改进。在没有数据包丢失的情况下，大多数新的连接都可以在一次往返中建立和保护；在同一客户机和服务器之间的后续连接上，客户机通常可以立即发送应用程序数据，即使用零往返设置。    
本文描述了TLS如何作为QUIC的安全组件。

## 2 符号约定
关键字 "**一定**", "**禁止**", "**要求**", "**应该**", "**不应**", "**推荐**", "**不推荐**", "**可以**", "**可选**"的使用与[BCP14](https://tools.ietf.org/html/bcp14) [RFC2119](https://tools.ietf.org/html/rfc2119) [RFC8174](https://tools.ietf.org/html/rfc8174)相同。 
本文件使用[QUIC-TRANSPORT]中规定的术语。   
为了简洁起见，虽然可以使用较新的版本（见4.2节），但缩写TLS用于指代TLS 1.3。

## 2.1 TLS概述
TLS为两个端点提供了一种在不受信任的介质（即Internet）上建立通信方式的方法，以确保它们交换的消息不能被观察、修改或伪造。    
在内部，TLS是一个分层协议，其结构如图1所示。
```
          +-------------+------------+--------------+---------+
Handshake |             |            |  Application |         |
Layer     |  Handshake  |   Alerts   |     Data     |   ...   |
          |             |            |              |         |
          +-------------+------------+--------------+---------+
Record    |                                                   |
Layer     |                      Records                      |
          |                                                   |
          +---------------------------------------------------+

                            Figure 1: TLS Layers
```
每个握手层消息（例如，握手、警报和应用程序数据）由记录层作为一系列类型化的TLS记录进行传输。记录被单独地加密保护，然后通过可靠的传输（通常是TCP）传输，它提供排序和有保证的传输。    
TLS认证密钥交换发生在两个端点之间：客户端和服务器。客户端启动交换，服务器响应。如果密钥交换成功完成，客户机和服务器都将同意一个密钥。TLS支持预共享密钥（PSK）和Diffie-Hellman在有限域或椭圆曲线（（EC）DHE）密钥交换上。PSK是0-RTT的基础，后者在（EC）DHE密钥被破坏时提供了完美的前向保密（PFS）。    
完成TLS握手后，客户机将识别并验证服务器的身份，并且服务器可以选择性地识别和验证客户机的身份。TLS支持服务器和客户端的基于X.509[RFC5280]证书的身份验证。    
TLS密钥交换能够抵抗攻击者的篡改，并且它产生的共享机密不能被任何一个参与的对等方控制。    
TLS提供了两种QUIC感兴趣的基本握手模式： 
+ 一种完整的1-RTT握手，在这种握手中，客户机能够在往返一次后发送应用程序数据，服务器在收到来自客户机的第一条握手消息后立即作出响应。
+ 一种0-RTT握手，在这种握手中，客户机使用它以前了解到的有关服务器的信息来立即发送应用程序数据。攻击者可以重放此应用程序数据，因此它不能携带任何非幂等操作的自包含触发器。   
 
图2显示了使用0-RTT应用程序数据的简化TLS握手。请注意，这忽略了在QUIC中没有使用的EndOfEarlyData消息（见第8.3节）。同样，QUIC不使用ChangeCipherSpec和KeyUpdate消息；ChangeCipherSpec在TLS 1.3中是冗余的，QUIC定义了自己的密钥更新机制（第6节）。
```
 Client                                             Server

 ClientHello
 (0-RTT Application Data)  -------->
                                                ServerHello
                                      {EncryptedExtensions}
                                                 {Finished}
                          <--------      [Application Data]
 {Finished}                -------->

 [Application Data]        <------->     [Application Data]

 () Indicates messages protected by Early Data (0-RTT) Keys
 {} Indicates messages protected using Handshake Keys
 [] Indicates messages protected using Application Data
    (1-RTT) Keys

            图 2: TLS 0-RTT 握手过程
```
使用多种加密级别保护数据：
+ 初始密钥
+ 早期数据（0-RTT）密钥
+ 握手密钥
+ 应用数据（1-RTT）密钥

应用程序数据可能只出现在早期数据和应用程序数据级别。握手和警报消息可以出现在任何级别。   
0-RTT握手只有在客户机和服务器之前进行过通信的情况下才可能。在1-RTT握手中，客户端在接收到服务器发送的所有握手消息之前无法发送受保护的应用程序数据。    

## 3 协议概述
QUIC[QUIC-TRANSPORT]负责数据包的机密性和完整性保护。为此，它使用从TLS握手[TLS13]中派生的密钥，但TLS握手和警报消息不是通过QUIC传输（与TCP一样），而是通过QUIC传输直接传输TLS握手和警报消息，QUIC传输接管了TLS记录层的职责，如图3所示。
```
+--------------+--------------+ +-------------+
|     TLS      |     TLS      | |    QUIC     |
|  Handshake   |    Alerts    | | Applications|
|              |              | |  (h3, etc.) |
+--------------+--------------+-+-------------+
|                                             |
|                QUIC Transport               |
|   (streams, reliability, congestion, etc.)  |
|                                             |
+---------------------------------------------+
|                                             |
|            QUIC Packet Protection           |
|                                             |
+---------------------------------------------+

             图 3: QUIC 层
```
QUIC还依赖TLS来验证和协商对安全性和性能至关重要的参数。这两个协议不是严格的分层，而是相互协作：QUIC使用TLS握手；TLS使用QUIC提供的可靠性、有序传递和记录层。   
在高层次上，TLS和QUIC组件之间有两个主要的交互作用：
+ TLS组件通过QUIC组件发送和接收消息，QUIC为TLS提供可靠的流抽象。
+ TLS组件为QUIC组件提供了一系列更新，包括（a）安装新的包保护密钥（b）状态更改，如握手完成、服务器证书等。

图4更详细地展示了这些交互，特别调用了QUIC包保护。
```
   +------------+                               +------------+
   |            |<---- Handshake Messages ----->|            |
   |            |<- Validate 0-RTT parameters ->|            |
   |            |<--------- 0-RTT Keys ---------|            |
   |    QUIC    |<------- Handshake Keys -------|    TLS     |
   |            |<--------- 1-RTT Keys ---------|            |
   |            |<------- Handshake Done -------|            |
   +------------+                               +------------+
    |         ^
    | Protect | Protected
    v         | Packet
   +------------+
   |   QUIC     |
   |  Packet    |
   | Protection |
   +------------+

                    图 4: QUIC 和 TLS 交互
```
与TCP上的TLS不同，要发送数据的QUIC应用程序不会通过TLS"application_data"记录发送数据。相反，它们将其作为QUIC**STREAM**帧或其他帧类型发送，然后在QUIC包中进行传输。

## 4 携带TLS信息
QUIC以**CRYPTO**帧的形式传输TLS握手数据，每个帧由一个由偏移量和长度标识的连续握手数据块组成。这些帧被打包成QUIC包，并在当前TLS加密级别下进行加密。与TCP上的TLS一样，一旦TLS数据被传递到QUIC，QUIC就有责任可靠地传递它。TLS生成的每个数据块都与TLS当前使用的密钥集相关联。如果QUIC需要重新传输数据，它必须使用相同的密钥，即使TLS已经更新为新的密钥。    
TLS记录（与TCP一起使用）和QUIC **CRYPTO**帧之间的一个重要区别是，在QUIC中，只要多个帧与相同的加密级别相关联，它们就可能出现在同一个QUIC包中。例如，一个实现可以将握手消息和一些握手数据的ACK绑定到同一个包中。    
有些帧在不同的加密级别被禁止，有些帧不能被发送。这里的规则概括了TLS的规则，因为与建立连接相关的帧通常可以出现在任何加密级别，而与传输数据相关的帧只能出现在0-RTT和1-RTT加密级别：
+ **PADDING**和**PING**帧**可以**出现在任何加密级别的包中。
+ QUIC层（0x1c类型）的**CRYPTO**帧和标识QUIC层错误的**CONNECTION_CLOSE**帧（类型0x1c）能出现在除0-RTT之外的任何加密级别的数据包中。
+ 标识应用程序错误的**CONNECTION_CLOSE**帧（类型0x1d）只能在1-RTT加密级别的数据包中发送。
+ **ACK**帧可以出现在0-RTT以外的任何加密级别的数据包中，但是只能确认出现在该数据包号空间中的数据包。
+ 所有其他帧类型只能以0-RTT和1-RTT级别发送。  

请注意，由于各种原因，无法在0-RTT中发送以下帧：**ACK**、**CRYPTO**、**HANDSHAKE_DONE**、**NEW_TOKEN**、**PATH_RESPONSE**和**RETIRE_CONNECTION_ID**。    
因为数据包可以在网络上重新排序，QUIC使用数据包类型来指示给定数据包的加密级别，如表1所示。当需要发送多个不同加密级别的数据包时，Endpoint应该使用合并的数据包在同一个UDP数据报中发送它们。
```
+---------------------+------------------+-----------+
| Packet Type         | Encryption Level | PN Space  |
+=====================+==================+===========+
| Initial             | Initial secrets  | Initial   |
+---------------------+------------------+-----------+
| 0-RTT Protected     | 0-RTT            | 0/1-RTT   |
+---------------------+------------------+-----------+
| Handshake           | Handshake        | Handshake |
+---------------------+------------------+-----------+
| Retry               | N/A              | N/A       |
+---------------------+------------------+-----------+
| Version Negotiation | N/A              | N/A       |
+---------------------+------------------+-----------+
| Short Header        | 1-RTT            | 0/1-RTT   |
+---------------------+------------------+-----------+

         表 1: 按数据包类型划分的加密级别
```
[QUIC-TRANSPORT]的第17节展示了不同加密级别的数据包如何适应握手过程。

### 4.1 TLS接口
如图4所示，QUIC到TLS的接口主要有四个功能:
+ 发送和接收握手信息
+ 从恢复的会话处理存储的传输和应用程序状态，并确定接受早期数据是否有效
+ 重新键入（发送和接收）
+ 握手状态更新
配置TLS可能需要其他功能。

#### 4.1.1 握手完成
在本文中，当TLS协议栈报告握手完成时，TLS握手被认为是完成的。当TLS堆栈既发送了完成的消息，又验证了对等方的完成消息时，即任务握手完成。验证对端是否完成为端点提供了一个保证，即先前的握手消息没有被修改。请注意，握手不会在两个端点同时完成。因此，任何基于握手完成的需求都取决于所讨论端点的视角。

#### 4.1.2 握手确认
在本文中，TLS握手在握手完成时被认为是在服务器上确认的。在客户端，当接收到**HANDSHAKE_DONE**帧时，握手被认为是确认的。    
当客户端接收到对1-RTT数据包的确认时，**可以**考虑确认握手。这可以通过记录用1-RTT密钥发送的最低数据包号来实现，并将其与任何接收到的1-RTT ACK帧中的最大确认字段进行比较：一旦后者大于或等于前者，则确认握手。    

#### 4.1.3 发送和接收握手消息
为了驱动握手，TLS依赖于能够发送和接收握手消息。这个接口有两个基本功能：一个是QUIC请求握手消息，另一个是QUIC提供握手包。    
在开始握手之前，QUIC向TLS提供它希望携带的传输参数（见第8.2节）。QUIC客户端通过从TLS请求TLS握手字节来启动TLS。客户端在发送第一个数据包之前获取握手字节。QUIC服务器通过向TLS提供客户端的握手字节来启动握手过程。    
在任何时候，端点处的TLS堆栈都将具有当前的发送加密级别和接收加密级别。每个加密级别都与不同的字节流相关联，这些字节流以**CRYPTO**帧的形式可靠地传输给对方。当TLS提供要发送的握手字节时，它们被附加到当前流中，并且任何包含**CRYPTO**帧的包都使用来自相应加密级别的密钥进行保护。    
QUIC将TLS握手记录中未受保护的内容作为加密帧的内容。QUIC不使用TLS记录保护。QUIC将**CRYPTO**帧组装成QUIC包，利用QUIC包保护对其进行保护。    
QUIC只能在**CRYPTO**帧中传输TLS握手记录。TLS警报转为QUIC **CONNECTION_CLOSE**携带的错误码；参见第4.9节。TLS应用程序数据和其他消息类型在任何加密级别都不能由QUIC携带，如果从TLS堆栈接收它们，则是一个错误。    
当端点从网络接收到包含**CRYPTO**帧的QUIC包时，其进行如下过程：
+ 如果数据包处于TLS接收加密级别，则像往常一样将数据排序到输入流中。与**STREAM**帧一样，偏移量用于在数据序列中找到适当的位置。如果此过程的结果是新数据可用，则按顺序将其传递到TLS。
+ 如果数据包来自先前安装的加密级别，则它**不能**扩展的包含数据放到该流中先前接收到的数据末尾。实现必须将任何违反此要求的行为视为**PROTOCOL_VIOLATION**类型的连接错误。
+ 如果数据包来自新的加密级别，则会将其保存以供TLS稍后处理。一旦TLS从这个加密级别开始接收，就可以提供保存的数据。当从任何新的加密级别向TLS提供数据时，如果TLS没有使用以前的加密级别的数据，则必须将其视为**PROTOCOL_VIOLATION**类型的连接错误。    

每次向TLS提供新数据时，都会从TLS请求新的握手字节。如果TLS接收到的握手消息不完整或没有要发送的数据，则TLS可能不会提供任何字节。    
一旦TLS握手完成，这将与TLS需要发送的任何最终握手字节一起指示给QUIC。TLS还向QUIC提供对等方在握手过程中公布的传输参数。    
一旦握手完成，TLS将变为被动。TLS仍然可以从其对等方接收数据并以实物方式响应，但除非应用程序或QUIC特别要求，否则它不需要发送更多数据。发送数据的一个原因是服务器可能希望向客户端提供额外或更新的会话凭证。    
当握手完成时，QUIC只需要向TLS提供到达加密流的任何数据。与握手期间的方法相同，在提供接收到的数据后，从TLS请求新数据。

#### 4.1.4 加密级别更改
当新加密级别的密钥可用时，TLS为QUIC提供这些密钥。另外，当给定加密级别的密钥对TLS可用时，TLS向QUIC指示在该加密级别上读写密钥是可用的。这些事件不是异步的；它们总是在TLS获得新的握手字节之后或者TLS生成握手字节之后立即发生。    
TLS为QUIC提供了三项新的加密级别：
+ 密钥
+ 一个经过身份验证的关联数据加密（AEAD）函数
+ 密钥派生函数（KDF）    

这些值基于TLS协商的结果，QUIC使用这些值生成包和头保护密钥（见第5节和第5.4节）。    
如果0-RTT是可能的，那么在客户端发送TLS "ClientHello"消息或服务器接收到该消息之后，它就准备好了。在向QUIC客户机提供第一个握手字节后，TLS堆栈可能会向0-RTT密钥发出更改信号。在服务器上，在接收到包含"ClientHello"消息的握手字节后，TLS服务器可能会发出0-RTT密钥可用的信号。    
虽然TLS一次只使用一个加密级别，但QUIC可能使用多个级别。例如，在发送完消息（在握手加密级别使用**CRYPTO**帧）之后，端点可以发送流数据（在1-RTT加密中）。如果完成的消息丢失，端点将使用握手加密级别重新传输丢失的消息。数据包的重新排序或丢失意味着QUIC将需要在多个加密级别处理数据包。在握手过程中，这意味着可能以高于或低于TLS使用的当前加密级别来处理数据包。    
特别是，服务器实现需要能够在握手加密级别和0-RTT加密级别同时读取数据包。客户端可以将由握手密钥保护的ACK帧与0-RTT数据交错，服务器需要处理这些确认以检测丢失的握手包。    
QUIC还需要访问TLS实现通常不可用的密钥。例如，客户端可能需要在准备发送加密级别的**CRYPTO**帧之前确认握手包。因此，TLS需要为QUIC提供密钥，然后才能为自己的用途生成密钥。

#### 4.1.5 TLS接口摘要
图5总结了客户机和服务器的QUIC和TLS之间的交换。每个箭头都标记有用于该传输的加密级别。
```
   Client                                                    Server

   Get Handshake
                        Initial ------------->
                                                 Handshake Received
   Install tx 0-RTT Keys
                        0-RTT --------------->
                                                      Get Handshake
                        <------------- Initial
   Handshake Received
   Install Handshake keys
                                              Install rx 0-RTT keys
                                             Install Handshake keys
                                                      Get Handshake
                        <----------- Handshake
   Handshake Received
                                              Install tx 1-RTT keys
                        <--------------- 1-RTT
   Get Handshake
   Handshake Complete
                        Handshake ----------->
                                                 Handshake Received
                                              Install rx 1-RTT keys
                                                 Handshake Complete
   Install 1-RTT keys
                        1-RTT --------------->
                                                      Get Handshake
                        <--------------- 1-RTT
   Handshake Received

                      Figure 5: QUIC与TLS的交互
```
图5显示了构成单独处理的消息的单个"飞行"的多个包，以显示哪些传入消息触发不同的操作。在处理完所有传入数据包后，将请求新的握手消息。这个过程可能会有所不同，这取决于QUIC实现和它们接收到的包的结构。

### 4.2 TLS版本
本文档描述了TLS 1.3[TLS13]如何与QUIC一起使用。    
实际上，TLS握手将协商要使用的TLS版本。如果两个端点都支持1.3版本，这可能会导致协商一个比1.3更新的TLS版本。如果QUIC使用的tls1.3特性得到更新版本的支持，这是可以接受的。    
配置错误的TLS实现可以协商tls1.2或其他旧版本的TLS。如果协商的TLS版本早于1.3，则Endpoint**必须**终止连接。

### 4.3 ClientHello大小
来自客户端的第一个初始数据包包含其第一个加密握手消息的开始或全部，对于TLS来说是"ClientHello"。服务器可能需要解析整个"ClientHello"（例如，访问服务器名称标识（SNI）或应用层协议协商（ALPN））等扩展，以决定是否接受新的传入QUIC连接。如果"ClientHello"跨越多个初始数据包，这样服务器就需要缓冲第一个接收到的片段，如果客户端的地址还没有被验证，这可能会消耗过多的资源。为了避免这种情况，服务器可以使用重试功能（参见[QUIC-TRANSPORT]的第8.1节），只缓冲来自具有验证地址的客户端的部分"ClientHello"消息。    
QUIC包和帧为"ClientHello"消息增加了至少36字节的开销。如果客户机选择长度不为零的连接ID，则开销会增加。开销也不包括Token或长度超过8字节的连接ID，如果服务器发送重试包，则可能需要这两个字节。    
典型的TLS "ClientHello"可以很容易地放入1200字节的数据包中。然而，除了QUIC增加的管理开销外，还有几个变量可能导致超出此限制。大session 凭证、多个或大共享密钥、受支持密码的长列表、签名算法、版本、QUIC传输参数和其他可协商参数和扩展可能导致此消息增长。对于服务器，除了连接ID和Token外，TLS session凭证的大小也会影响客户端高效连接的能力。最小化这些值的大小会增加客户端可以使用它们的概率，并且仍然将"ClientHello"消息放入第一个初始包中。   
TLS实现不需要确保"ClientHello"足够大。添加QUIC **PADDING**帧就可以以根据需要增加数据包的大小。 

### 4.4 对等身份验证
身份验证的要求取决于所使用的应用程序协议。TLS提供服务器身份验证并允许服务器请求客户端身份验证。  
端户机必须验证服务器的身份。这通常涉及到验证服务器的身份是否包含在证书中，以及证书是否由受信任的实体颁发（例如请参见[RFC2818]）。在握手过程中，服务器可以请求客户端进行身份验证。如果客户端在请求时无法进行身份验证，则服务器可能会拒绝连接。客户机身份验证的要求因应用程序协议和部署而异。    
服务器不能使用握手后的客户端身份验证（如[TLS13]第4.6.2节所定义），因为QUIC提供的多路复用阻止客户端将证书请求与触发该请求的应用程序级事件相关联（参见[HTTP2-TLS13]）。更具体地说，服务器不能发送握手后的TLS "CertificateRequest"消息，客户端必须将接收到的此类消息视为**PROTOCOL_VIOLATION**类型的连接错误。

### 4.5 启用0-RTT
为了表达他们处理0-RTT数据的意愿，服务器发送一条NewSessionTicket消息，其中包含"early_data"扩展名，max_early_data_size为0xffffffff；客户端可以在0-RTT中发送的数据量由服务器提供的"initial_max_data"传输参数控制。服务器在发送"early_data"扩展时，不能将max_early_data_size设置为0xffffffff以外的任何值。客户机必须将接收到的包含"early_data"扩展名和任何其他值的"NewSessionTicket"视为**PROTOCOL_VIOLATION**类型的连接错误。   
希望发送0-RTT数据包的客户端在随后握手的"ClientHello"消息中使用"early_data"扩展（见[TLS13]的4.2.10节）。然后它以0-RTT包的形式发送应用程序数据。

### 4.6 接受和拒绝0-RTT
服务器通过发送"EncryptedExtensions"中的"early_data"扩展来接受0-RTT（参见[TLS13]的4.2.10节）。然后，服务器处理并确认它接收到的0-RTT包。服务器通过发送不带"early_data"扩展名的"EncryptedExtensions"拒绝0-RTT。如果服务器发送TLS "HelloRetryRequest"，它将始终拒绝0-RTT。拒绝0-RTT后，服务器不能处理任何0-RTT数据包，即使具备处理能力。当0-RTT被拒绝后，如果客户端能够检测到这种情况，则应将收到的0-RTT数据包确认视为**PROTOCOL_VIOLATION**类型的连接错误。   
当0-RTT被拒绝后，客户端假定的所有连接特征都可能不正确。这包括应用程序协议、传输参数和任何应用程序配置的选择。
因此，客户端必须重置所有流的状态，包括绑定到这些流的应用程序状态。   
如果客户端收到重试或版本协商包，则可能会尝试再次发送0-RTT。这些数据包并不表示拒绝0-RTT。

### 4.7 验证0-RTT配置
当服务器接收到带有"early_data"扩展的"ClientHello"时，它必须决定是接受还是拒绝来自客户端的早期数据。有些决定是由TLS协议栈做出的（例如，检查正在恢复的密码套件是否包含在ClientHello中；参见[TLS13]第4.2.10节）。即使TLS协议栈没有理由拒绝早期数据，QUIC协议或使用QUIC的应用程序协议可能会拒绝早期数据，因为与恢复会话相关联的传输或应用程序配置与服务器的当前配置不兼容。   
QUIC要求附加的传输状态与0-RTT会话凭证相关联。实现这一点的一种常见方法是使用无状态会话凭证并将此状态存储在会话凭证中。使用QUIC的应用程序协议在关联或存储状态方面可能有类似的要求。此关联状态用于决定是否必须拒绝早期数据。例如，HTTP/3（[QUIC-HTTP]）设置决定如何解释来自客户端的早期数据。使用QUIC的其他应用程序在确定是否接受或拒绝早期数据时可能有不同的要求。

### 4.8 HelloRetryRequest
在TCP上的TLS中，"HelloRetryRequest"特性（见[TLS13]的4.1.4节）可用于纠正客户机不正确的"KeyShare"扩展以及无状态的往返检查。从QUIC的角度来看，这看起来就像初始加密级别中携带的附加消息。虽然原则上可以在QUIC中使用此功能进行地址验证，但是QUIC实现应该使用重试功能（参见[QUIC-TRANSPORT]的第8.1节）。"HelloRetryRequest"仍然用于请求共享。

### 4.9 TLS错误
如果TLS遇到错误，它会生成[TLS13]第6节中定义的适当警报。   
通过将单字节警报描述转换为QUIC错误码，TLS警报将转变为QUIC连接错误。警报描述被添加到0x100中，以在为**CRYPTO_ERROR**保留的范围内生成QUIC错误代码。结果值在QUIC **CONNECTION_CLOSE**帧中发送。   
所有TLS警报的警报级别均为"fatal"；TLS堆栈不得生成"warning"级别的警报。

### 4.10 丢弃未使用的密钥
QUIC移动到新的加密级别后，以前加密级别的数据包保护密钥可以被丢弃。这种情况在握手过程中以及密钥更新时会发生多次；请参阅第6节。   
当新密钥可用时，不会立即丢弃包保护密钥。如果来自较低加密级别的数据包包含**CRYPTO**帧，则重新传输该数据的帧必须在同一加密级别发送。类似地，端点为与所确认的数据包相同的加密级别的包生成确认。因此，在新的加密级别的密钥可用后的短时间内，可能需要较低加密级别的密钥。   
端点不能丢弃给定加密级别的密钥，除非它已接收并确认该加密级别的所有**CRYPTO**帧，并且该加密级别的所有**CRYPTO**帧都已被其对端确认。但是，这并不保证在该加密级别上不再需要接收或发送更多的数据包，因为对等方可能没有收到达到相同状态所需的所有确认。   
虽然端点可能保留旧密钥，但新数据必须以当前可用的最高加密级别发送。只有**ACK**帧和**CRYPTO**帧中数据的重传在先前的加密级别被发送。这些包还可能包括**PADDING**帧。

#### 4.10.1 丢弃初始密钥
使用初始密钥（第5.2节）保护的数据包没有经过身份验证，这意味着攻击者可以伪造数据包，意图中断连接。为了限制这些攻击，可以比其他密钥更早地丢弃初始包保护密钥。   
握手包的成功使用表明不再需要交换更多的初始包，因为这些密钥只能在从初始包接收到所有**CRYPTO**帧之后产生。因此，客户端在第一次发送握手包时必须丢弃初始密钥，而服务器在首次成功处理握手包时必须丢弃初始密钥。端点在此之后**不得**发送初始数据包。   
这将导致放弃初始加密级别的丢失恢复状态，并忽略任何未完成的初始数据包。

#### 4.10.2 丢弃握手密钥
当TLS握手被确认时，端点必须丢弃它的握手密钥（第4.1.2节）。服务器**必须**在完成握手后立即发送**HANDSHAKE_DONE**帧。    

#### 4.10.3 丢弃0-RTT密钥
0-RTT和1-RTT包共享相同的包号空间，客户端在发送1-RTT包后不发送0-RTT包（第5.6节）。因此，客户端应该在安装1-RTT密钥后立即丢弃0-RTT密钥，因为在那之后它们就没有用处了。   
另外，服务器在接收到1-RTT包时可能会丢弃0-RTT密钥。然而，由于包的重新排序，0-RTT包可能在1-RTT包之后到达。服务器可以暂时保留0-RTT密钥，以允许对重新排序的包进行解密，而无需使用1-RTT密钥重新传输其内容。在接收到1-RTT数据包后，服务器必须在短时间内丢弃0-RTT密钥；建议的时间段是探测超时的三倍（PTO，请参阅[QUIC-RECOVERY]）。如果服务器确定它已经接收到所有0-RTT包，可以通过跟踪丢失的包号来提前丢弃0-RTT密钥。

## 5 包保护
与TCP上的TLS一样，QUIC使用TLS协商的AEAD算法，用TLS握手派生的密钥保护数据包。

### 5.1 数据包保护密钥
QUIC派生包保护密钥的方式与TLS导出记录保护密钥的方式相同。这些流量加密由TLS导出（见[TLS13]第7.1节），QUIC将其用于除初始加密级别之外的所有加密级别。初始加密级别的密钥根据客户端的初始目标连接ID计算，如第5.2节所述。   
用于包保护的密钥是使用TLS提供的KDF从TLS机密中计算出来的。在TLS 1.3中，使用了[TLS13]第7.1节中描述的"HKDF Expand Label"函数，使用协商密码套件中的哈希函数。   
当前的加密级别机密和标签"quic key"被输入到KDF以生成AEAD密钥；标签"quic iv"用于派生IV；参见第5.3节。包头保护钥匙使用"quic hp"标签；见第5.4节。使用这些标签可以在QUIC和TLS之间进行密钥分隔；参见第9.5节。   
用于初始机密的KDF始终是tls1.3中的"HKDF Expand Label"函数（见第5.2节）。   

### 5.2 初始加密
初始数据包使用从客户端的初始数据包的目标连接ID字段派生的机密进行保护。具体如下：
```
initial_salt = 0xc3eef712c72ebb5a11a7d2432bb46365bef9f502
   initial_secret = HKDF-Extract(initial_salt,
                                 client_dst_connection_id)

   client_initial_secret = HKDF-Expand-Label(initial_secret,
                                             "client in", "",
                                             Hash.length)
   server_initial_secret = HKDF-Expand-Label(initial_secret,
                                             "server in", "",
                                             Hash.length)
```
当派生初始机密和密钥时，HKDF的哈希函数是SHA-256[SHA]。   
与HKDF Expand Label一起使用的连接ID是客户端发送的初始数据包中的目标连接ID。这将是一个随机选择的值，除非客户端在接收到重试数据包后创建初始数据包，其中目标连接ID由服务器选择。   
initial_salt的值是图中以十六进制表示的20字节序列。未来版本的QUIC应该生成一个新的salt值，从而确保每个版本的QUIC的键都是不同的。这可以防止只识别一个QUIC版本的中间设备查看或修改将来版本的包的内容。   
TLS 1.3中定义的"HKDF Expand Label"函数必须用于初始数据包，即使提供的TLS版本不包括TLS 1.3。   
当服务器发送重试数据包以使用服务器选择的连接ID值时，用于保护初始数据包的机密会发生更改。当客户端响应来自服务器的初始数据包而更改其使用的目标连接ID时，密钥不会更改。   
注意：目标连接ID的长度是任意的，如果服务器发送的重试数据包的源连接ID字段为零，则长度可能为零。在这种情况下，初始密钥不向客户端保证服务器已收到其数据包；客户端必须依赖包含该属性的重试数据包的交换。

### 5.3 AEAD使用
用于QUIC数据包保护的身份验证加密（AEAD）[AEAD]函数是协商用于TLS连接的AEAD。例如，如果TLS使用TLS_AES_128_GCM_256，则使用AEAD_AES_128_GCM函数。   
在应用包头保护之前，数据包受到保护（第5.4节）。无保护的数据包头是相关数据（A）的一部分。当删除数据包保护时，端点首先删除包头保护。   
除版本协商和重试数据包之外的所有QUIC数据包都使用AEAD算法[AEAD]进行保护。在建立共享密钥之前，数据包由AEAD_AES_128_GCM和从客户端第一个初始数据包中的目标连接ID派生的密钥进行保护（见第5.2节）。这提供了针对非路径攻击者的保护，并针对QUIC版本不知道的中间盒提供了健壮性，但不针对路径上的攻击者。   
QUIC可以使用[TLS13]中定义的任何密码套件，TLS_AES_128_CCM_8_SHA256除外。除非为密码套件定义了标头保护方案，否则不得协商密码套件。本文件为[TLS13]中定义的除TLS_AES_128_CCM_8_SHA256之外的所有密码套件定义了一个头保护方案。这些密码集具有16字节的身份验证标记，并产生比输入大16字节的输出。   
注意：端点不能拒绝提供它不支持的密码套件的"ClientHello"，否则将无法部署新的密码套件。这也适用于TLS_AES_128_CCM_8_SHA256。   
如第5.1节所述，计算包的密钥和IV。所有的密钥由数据包保护IV与数据包号组合而成。以网络字节顺序重建的QUIC数据包编号的62位用0填充到IV的大小。填充包编号和IV的异或构成AEAD。   
AEAD的相关数据A是QUIC包头的内容，从短或长包头中的标志字节开始，直到并包括未受保护的数据包编号。   
AEAD的输入明文P是QUIC包的有效载荷，如[QUIC-TRANSPORT]中所述。AEAD的输出密文C代替P传输。    
一些AEAD函数对相同密钥和IV下可以加密的数据包数量有限制（例如，请参见[AEBounds]）。这可能低于包数限制。端点必须在超过为正在使用的AEAD设置的任何限制之前启动密钥更新（第6节）。

### 5.4 包头保护
QUIC包头的部分，特别是包号字段，使用独立于包保护密钥和IV的密钥来保护。使用"quic hp"标签派生的密钥用于为那些不暴露于on-path元素的字段提供机密性保护。   
此保护适用于第一个字节的最低有效位，加上数据包编号字段。第一字节的四个最小有效位为具有长包头的数据包提供保护；对于短包头的数据包，保护第一字节的五个最小有效位。对于这两种包头的形式，包括保留位和包号长度字段；"Key Phase"位也为具有短包头的数据包提供保护。   
在连接期间使用相同的头保护密钥，在密钥更新后该值不变（见第6节）。这允许头保护被用来保护关键阶段。   
此过程不适用于重试或版本协商数据包，这些数据包不包含受保护的有效负载或任何字段。

### 5.4.1 应用头保护
在应用数据包保护后应用包头保护（见第5.3节）。对数据包的密文进行采样并作为加密算法的输入。使用的算法取决于协商的AEAD。   
该算法的输出是一个5字节掩码，它使用异或应用于受保护的头字段。包的第一个字节的最低有效位被第一个掩码字节的最低有效位屏蔽，包号用剩余字节屏蔽。任何可能由较短的数据包编号编码产生的未使用的掩码字节都不使用。   
图6显示了应用头保护的示例算法。移除包头保护只在数据包号长度（pn_length）的确定顺序上有所不同。
```
   mask = header_protection(hp_key, sample)

   pn_length = (packet[0] & 0x03) + 1
   if (packet[0] & 0x80) == 0x80:
      # Long header: 4 bits masked
      packet[0] ^= mask[0] & 0x0f
   else:
      # Short header: 5 bits masked
      packet[0] ^= mask[0] & 0x1f

   # pn_offset is the start of the Packet Number field.
   packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]

              图 6: 包头保护伪码
```
图7显示了用E标记的长标题和短标题的受保护字段。图7还显示了采样字段。
```
   Long Header:
   +-+-+-+-+-+-+-+-+
   |1|1|T T|E E E E|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Version -> Length Fields                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Short Header:
   +-+-+-+-+-+-+-+-+
   |0|1|S|E E E E E|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0/32..144)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Common Fields:
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E E E E E E E E E  Packet Number (8/16/24/32) E E E E E E E E...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   [Protected Payload (8/16/24)]             ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Sampled part of Protected Payload (128)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Protected Payload Remainder (*)             ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    图 7: 包头保护和密文样本
```
在TLS密码套件可以与QUIC一起使用之前，必须为与该密码套件一起使用的AEAD指定标头保护算法。本文件定义了AEAD_AES_128_GCM、AEAD_AES_128_GCM、AEAD_AES_256_GCM（所有AES AEAD定义在[AEAD]）和AEAD_CHACHA20_POLY1305[chachacha]的算法。在TLS选择密码套件之前，使用AES包头保护（第5.4.3节），匹配AEAD_AES_128_GCM包保护。

### 5.4.2 包头保护示例
包头保护算法同时使用包头保护密钥和来自包有效载荷字段的密文样本。   
对相同数量的字节进行采样，但是需要为Endpoint移除保护留出一个余量，因为Endpoint移除保护将不知道包编号字段的长度。在对包密文进行采样时，假设包编号字段为4字节长（其最大可能编码长度）。   
端点必须丢弃长度不足以包含完整样本的数据包。   
为了确保有足够的数据可用于采样，对包进行填充，使得编码的包编号和受保护的有效载荷的组合长度至少比包头保护所需的样本长4个字节。[TLS13]中定义的密码套件（TLS_AES_128_CCM_8_SHA256除外，本文档中未定义头保护方案）具有16字节扩展和16字节头保护示例。这导致在未保护的有效负载中需要至少3字节的帧（如果包编号是在单字节上编码的），或者对于2字节的数据包号编码，则需要2字节的帧。
具有短包头的包的抽样密文可由以下伪码确定：  
```
sample_offset = 1 + len(connection_id) + 4
sample = packet[sample_offset..sample_offset+sample_length]
```
例如，对于具有短包头、8字节连接ID并受AEAD_AES_128_GCM保护的数据包，该示例使用字节13到28（包括字节13到28）（使用基于零的索引）。   
具有长包头的数据包以相同的方式进行采样，注意多个QUIC数据包可能包含在同一个UDP数据报中，并且每个数据包都是单独处理的。   
```
sample_offset = 7 + len(destination_connection_id) +
                       len(source_connection_id) +
                       len(payload_length) + 4
if packet_type == Initial:
       sample_offset += len(token_length) +
                        len(token)

sample = packet[sample_offset..sample_offset+sample_length]
```

### 5.4.3 基于AES的包头保护
本节定义AEAD_AES_128_GCM、AEAD_AES_128_CCM和AEAD_AES_256_GCM的数据包保护算法。AEAD_AES_128_GCM和AEAD_AES_128_CCM在电子码本（ECB）模式下使用128位AES[AES]。AEAD_AES_256_GCM在ECB模式下使用256位AES。   
该算法从包密文中抽取16个字节。该值用作AES-ECB的输入。在伪代码中：
```
mask = AES-ECB(hp_key, sample)
```

### 5.4.4 基于ChaCha20的包头保护
使用AEAD_CHACHA20_POLY1305时，头保护使用[CHACHA]第2.4节中定义的原始CHACHA20功能。这使用一个256位的密钥和从包保护输出中取样的16个字节。   
采样密文的前4个字节是块计数器。ChaCha20实现可以用32位整数代替字节序列，在这种情况下，字节序列被解释为一个"little-endian"值。   
剩下的12个字节用作"nonce"。一个ChaCha20实现可以用一个由三个32位整数组成的数组来代替一个字节序列，在这种情况下，"nonce"字节被解释为一个32位低位整数序列。   
加密掩码是通过调用ChaCha20来保护5个零字节来生成的。在伪代码中：
```
counter = sample[0..3]
nonce = sample[4..15]
mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0})
```

### 5.4.5 接收受保护的数据包
一旦一个端点成功地接收到一个具有给定包号的包，它必须丢弃在同一个包号空间中具有更高包号的所有包，如果这些包不能用同一个密钥成功地解除保护，或者-如果有密钥更新-下一个包保护密钥（见第6节）。类似地，似乎触发密钥更新但无法成功解除保护的数据包必须被丢弃。   
未能解除对数据包的保护并不一定表示对等方或攻击中存在协议错误。在QUIC中使用的截短包号编码，如果包被严重延迟，则会导致包编号被错误解码。

### 5.6 使用0-RTT密钥
如果0-RTT密钥可用（参见第4.5节），则缺少重播保护意味着必须限制其使用，以避免对协议的重播攻击。客户端必须仅使用0-RTT密钥来保护幂等数据。客户端可能希望在完成TLS握手之前对其发送的数据应用附加限制。否则，客户端将0-RTT密钥视为等同于1-RTT密钥，除非它不能用0-RTT密钥发送ack。   
接收到服务器已接受其0-RTT数据的指示的客户机可以发送0-RTT数据，直到它接收到服务器的所有握手消息。如果客户端收到0-RTT数据已被拒绝的指示，则应停止发送0-RTT数据。   
服务器不能使用0-RTT密钥来保护数据包；它使用1-RTT密钥来保护0-RTT数据包的确认。客户端不能试图解密它接收到的0-RTT数据包，而必须丢弃它们。   
一旦客户端安装了1-RTT密钥，它就不能再发送任何0-RTT包。   
注意：服务器在接收0-RTT数据时可以对其进行确认，但是在TLS握手完成之前，任何包含0-RTT数据确认的数据包都不能被客户端删除数据包保护。在客户端接收到所有服务器握手消息之前，无法导出删除数据包保护所需的1-RTT密钥。

### 5.7 无序接收受保护的帧
由于重新排序和丢失，在接收到最终的TLS握手消息之前，端点可能会接收到受保护的数据包。客户端将无法从服务器解密1-RTT包，而服务器将能够从客户端解密1-RTT包。在完成握手之前，任一角色中的Endpoint都不要解密对端的1-RTT数据包。   
即使1-RTT密钥在从客户端接收到第一次握手消息后可供服务器使用，但它缺少关于客户端状态的保证：
+ 除非服务器选择使用预共享密钥并验证了客户端的预共享密钥绑定器，否则客户端不会进行身份验证；请参见[TLS13]第4.2.11节。
+ 除非使用了重试数据包，否则客户端没有显示活动性。
+ 服务器响应的任何接收到的0-RTT数据都可能是由于重播攻击造成的。

因此，服务器对1-RTT密钥的使用必须限于在握手完成之前发送数据。在TLS握手完成之前，服务器**不得**处理传入的受1-RTT保护的数据包。因为发送确认表示一个包中的所有帧都已被处理，所以在TLS握手完成之前，服务器无法为1-RTT数据包发送确认。接收到的用1-RTT密钥保护的数据包可以被存储，并且在握手完成后解密和使用。   
注意：TLS实现可能在握手完成之前提供所有1-RTT机密。即使QUIC实现有1-RTT密钥，在完成握手之前也不能使用这些密钥。   
要求服务器等待客户端的完成消息会对所传递的消息产生依赖。客户端可以在发送1-RTT包时联合一个包含了"Finished"消息的**CRYPTO**帧副本的握手包，直到其中一个握手包被确认为止，从而避免潜在的线头阻塞。这使服务器能够立即处理这些数据包。   
在接收TLS "ClientHello"之前，服务器可以接收用0-RTT密钥保护的数据包。服务器可以保留这些数据包以备以后解密，以预期接收到"ClientHello"。

### 5.8 重试数据包的完整性
重试数据包（请参阅[QUIC-TRANSPORT]的"重试数据包"部分）带有一个"Retry Integrity Tag"标记，该标记提供两个属性：允许丢弃被网络意外损坏的数据包，并削弱了非路径攻击者发送有效重试数据包的能力。    
"Retry Integrity Tag"标记是一个128位字段，计算为AEAD_AES_128_GCM[AEAD]的输出，并与以下输入一起使用：
+ 128位的密钥K，等于0x4d32ecdb2a213c841e4043df27d4430。
+ 96位的nonce N，等于0x4d1611d05513a552c587d575。
+ 明文P，空的。
+ 关联数据A是重试伪包的内容，如图8所示：密钥和nonce是通过调用HKDF Expand Label得到的值，使用0x656e61e336ae9417f7f0edd8d78d461e2aa7084aba7a14c1e9f726d55709169a作为机密，标签为"quic key"和"quic iv"（第5.1节）。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | ODCID Len (8) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Original Destination Connection ID (0..160)        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|1| 3 | Unused|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Retry Token (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                            图 8: 重试包
```
重试伪数据包不会通过线路发送。通过获取传输的重试数据包，删除重试完整性标记并在前面添加以下两个字段来计算：
+ ODCID Len: ODCID Len包含后面的原始目标连接ID字段的字节长度，编码为8位无符号整数。
+   Original Destination Connection ID:  包含此重试响应的初始数据包中的目标连接ID的值。此字段的长度以ODCID Len表示。此字段的存在减少了非路径攻击者注入重试数据包的可能。

## 6 密钥更新
一旦握手被确认（见第4.1.2节），端Endpoint就可以启动密钥更新。   
"The Key Phase"位指示使用哪些包保护密钥来保护该包。对于第一组1-RTT数据包，"The Key Phase"位最初设置为0，并切换以向每个后续密钥更新发送信号。   
"The Key Phase"位允许接收者检测密钥的变化，而不需要接收触发该变化的第一个包。通知"The Key Phase"变更的Endpoint更新密钥并解密包含更改值的包。   
此机制将替换TLS "KeyUpdate"消息。Endpoint**不要**发送TLS "KeyUpdate"消息。   
Endpoint必须将接收到的TLS "KeyUpdate"消息视为0x10a类型的连接错误，相当于"unexpected_message"发出致命的TLS fatal警报（参见第4.9节）。   
图9显示了一个密钥更新过程，其中使用的初始密钥集（用@M标识）被更新的密钥（标识为@N）替换。键相位的值用括号[]表示。   
```
   Initiating Peer                     Responding Peer
   @M [0] QUIC Packets
   ... Update to @N
   @N [1] QUIC Packets
                        -------->
                                     Update to @N ...
                                  QUIC Packets [1] @N
                        <--------
                                  QUIC Packets [1] @N
                                containing ACK
                        <--------
   ... Key Update Permitted
   @N [1] QUIC Packets
       containing ACK for @N packets
                        -------->
                              Key Update Permitted ...
                   图 9: 密钥更新
```

### 6.1 启动密钥更新
端点为包保护维护单独的读写密钥。端点通过更新其数据包保护写入密钥以启动密钥更新，并使用它来保护新数据包来。端点根据[TLS13]第7.2节中所述的现有写入密钥创建新的写入密钥。它使用TLS提供的带有"quic ku"标签的KDF函数。相应的密钥和IV根据第5.1节中定义的密钥创建。包头保护密钥并没有更新。   
例如，要用TLS 1.3更新写密钥，HKDF Expand Label用作：
```
secret_<n+1> = HKDF-Expand-Label(secret_<n>, "quic ku",
                            "", Hash.length)
```
端点切"Key Phase"位的值，并使用更新后的密钥和IV来保护所有后续数据包。   
在确认握手之前，端点不得启动密钥更新（第4.1.2节）。端点不能在启动后续密钥的更新，除非它已收到由当前"Key Phase"的密钥保护发送的包的确认。这样可以确保在启动另一个密钥更新之前，密钥对两个对端都可用。这可以通过跟踪每个"Key Phase"发送的最低数据包号和1-RTT空间中的最高确认数据包号来实现：一旦后者大于或等于前者，就可以启动另一个密钥更新。   
注意：除1-RTT数据包外，其他数据包的密钥永远不会更新；它们的密钥仅从TLS握手状态派生。   
启动密钥更新的端点还更新它用于接收数据包的密钥。更新后，需要这些密钥来处理对等方发送的数据包。   
端点应该保留旧密钥，以便可以处理在接收密钥更新之前由其对端发送的数据包。过早丢弃旧密钥会导致延迟的数据包被丢弃。丢弃数据包将被对端解释为数据包丢失，并可能对性能产生不利影响。   

### 6.2 响应密钥更新
在当前密钥阶段接收到包的确认之后，允许对等方发起密钥更新。端点在处理密钥阶段与上次用于保护它发送的最后一个数据包的值不同的数据包时检测密钥更新。为了处理这个包，端点使用下一个包保护密钥和IV。有关生成这些键的注意事项，请参见第6.3节。   
如果使用下一个密钥和IV成功地处理了一个数据包，则对等方已启动密钥更新。端点必须将其发送密钥更新到相应的密钥阶段，如第6.1节所述。发送密钥必须在发送用更新密钥接收的包的确认之前更新。通过确认由更新密钥保护的包中触发密钥更新的包，端点发出密钥更新完成的信号。   
端点可以根据其正常的数据包发送行为延迟发送数据包或确认；不需要立即生成响应密钥更新的数据包。端点发送的下一个数据包将使用更新后的密钥。包含确认的下一个数据包将导致密钥更新完成。如果一个端点在发送带有更新密钥的任何包之前检测到第二次更新，其中包含对启动密钥更新的包的确认，则它指示其对等方已更新密钥两次，而无需等待确认。端点可以将连续的密钥更新视为**KEY_UPDATE_ERROR**类型的连接错误。   
接收到由旧密钥保护的数据包中携带的确认的端点，其中任何已确认的数据包都被新密钥保护，则该端点可以将其视为**KEY_UPDATE_ERROR**类型的连接错误。这表示对等方已经接收并确认了发起密钥更新的包，但没有响应地更新密钥。   

### 6.3 接收密钥生成的时间
响应明显密钥更新的端点**不得**生成可能指示密钥阶段位无效的"side-channel"信号（见第9.3节）。当还不允许密钥更新时，端点可以使用虚拟包保护密钥来代替丢弃的密钥。使用伪密钥将不会在试图移除包保护所产生的定时信号中产生任何变化，并导致具有无效密钥相位位的所有数据包被拒绝。   
为接收数据包创建新的数据包保护密钥的过程可能会显示密钥更新已发生。端点可以将此过程作为包处理的一部分执行，但这会创建一个定时信号，攻击者可以使用该信号来了解密钥更新的时间，从而了解某些数据包中密钥相位位的值。端点可以将下一组接收包保护密钥的创建推迟到密钥更新完成后的某个时间，最多为PTO的三倍；请参阅第6.5节。   
一旦生成，就应该保留下一组数据包保护密钥，即使接收到的数据包随后被丢弃。包含明显的密钥更新的数据包很容易伪造，而且-虽然密钥更新过程不需要大量工作-触发此过程可能会被攻击者用于DoS。   
因此，端点必须能够为接收数据包保留两组数据包保护密钥：当前和下一个。除了这些之外保留以前的关键点可能会提高性能，但这并不重要。   

### 6.4 使用更新的密钥发送
端点总是发送用最新密钥保护的数据包。用于包保护的密钥在切换到新的密钥后可以立即丢弃。   
数据包编号较高的数据包必须使用与较低数据包编号的数据包相同或更新的数据包保护密钥进行保护。当较新的密钥用于数据包编号较低的数据包时，如果某个Endpoint成功地删除了旧密钥的保护，则该端点必须将其视为**KEY_UPDATE_ERROR**类型的连接错误。   

### 6.5 使用不同的密钥接收
对于在密钥更新期间接收数据包，使用旧密钥保护的数据包可能会在网络延迟时到达。保留旧的数据包保护密钥可以成功地处理这些数据包。   
由于由下一个密钥阶段的密钥保护的数据包使用与前一个密钥阶段的密钥保护的数据包相同的密钥阶段值，因此有必要区分这两者。这可以使用数据包编号来完成。低于当前密钥阶段的任何数据包号的恢复数据包号使用先前的数据包保护密钥；高于当前密钥阶段的任何数据包号的恢复数据包号需要使用下一个数据包保护密钥。   
一定要小心，以确保在前一个、当前和下一个数据包保护密钥之间进行选择的任何过程都不会暴露"timing side channel"，该信道可能会揭示用于移除数据包保护的密钥。更多信息见第9节。   
或者，端点只能保留两组数据包保护密钥，在经过足够的时间以允许在网络中重新排序后，将前一组交换为下一组。在这种情况下，可以单独使用密钥相位位来选择密钥。   
在创建下一组数据包保护密钥之前，一个端点在密钥更新后可能允许大约一段时间的探测超时（PTO；请参阅[QUIC-RECOVERY]）。这些更新后的密钥可能会取代当时的密钥。有一点需要注意的是，PTO是一个主观的度量，也就是说，一个对等点可能对RTT有不同的看法，这个时间预计足够长，以至于任何重新排序的数据包都将被对等方声明丢失，即使它们被确认并且足够短以允许随后的密钥更新。   
端点需要考虑这样的可能性：对等方可能无法解密在保留旧密钥期间启动密钥更新的数据包。在接收到确认已接收到上一次密钥更新的确认后，Endpoint应等待PTO三次，然后再启动密钥更新。没有足够的时间可能会导致数据包被丢弃。   
Endpoint保留旧的读密钥的时间不应超过PTO的三倍。在这段时间之后，旧的读密钥及其相应的秘密应该被丢弃。   

### 6.6 密钥更新频率
在超过数据包保护密钥的使用限制之前，必须启动密钥更新。对于本文件中提到的密码套件，[TLS13]第5.5节中的限制适用。其他密码套件必须定义使用限制才能与QUIC一起使用。   

### 6.7 密钥更新错误码
**KEY_UPDATE_ERROR**（0xE）用于通知与密钥更新相关的错误。

## 7 初始消息的安全性
初始数据包不受密钥保护，因此可能会被攻击者篡改。QUIC提供了对无法读取数据包的攻击者的保护，但不试图提供额外的保护，以防攻击者在攻击中观察和注入数据包。某些形式的篡改（例如修改TLS消息本身）是可检测的，但有些形式（如修改ack）则不可检测。   
例如，攻击者可以注入一个包含ACK帧的包，该ACK帧使数据包看起来没有被接收，或者造成连接状态的错误印象（例如，通过修改ACK延迟）。请注意，这样的数据包可能会导致合法数据包作为重复数据被丢弃。在依赖初始数据包中未经其他方式验证的任何数据时，实现时应谨慎。   
攻击者还可能篡改握手数据包中携带的数据，但由于这种篡改需要修改TLS握手消息，因此这种篡改将导致TLS握手失败。   

## 8 TLS握手的QUIC特定附加功能
QUIC使用TLS握手不仅仅用于协商加密参数。TLS握手提供QUIC传输参数的初始值，并允许服务器在客户端上执行返回路由检查。   

### 8.1 协议协商
QUIC要求加密握手提供经过身份验证的协议协商。TLS使用应用层协议协商（ALPN）[ALPN]来选择应用协议。除非使用另一种机制来同意应用程序协议，否则端点必须为此使用ALPN。使用ALPN时，如果应用协议未与"no_application_protocol"TLS警报协商（QUIC错误代码0x178，请参阅第4.9节），则端点必须立即关闭连接（请参阅[QUIC-TRANSPORT]中的10.3节）。虽然[ALPN]只指定服务器使用此警报，但当ALPN协商失败时，QUIC客户端还必须使用它来终止连接。   
应用程序协议可能会限制它可以操作的QUIC版本。服务器必须选择与客户机所选QUIC版本兼容的应用程序协议。服务器必须将无法选择兼容的应用程序协议视为类型为0x178 (no_application_protocol)的连接错误。类似地，客户机必须将服务器选择的不兼容应用程序协议视为0x178类型的连接错误。   

### 8.2 QUIC传输参数扩展
QUIC传输参数在TLS扩展中携带。不同版本的QUIC可能会为协商传输配置定义不同的方法。   
在TLS握手中包含传输参数为这些值提供完整性保护。
```
enum {
    quic_transport_parameters(0xffa5), (65535)
} ExtensionType;
```
"quic_transport_parameters"扩展的"extension_data"字段包含一个由正在使用的quic版本定义的值。   
"quic_transport_parameters"扩展在"ClientHello"中进行，而"EncryptedExtensions"消息则在握手过程中进行。Endpoint必须发送"quic_transport_parameters"扩展；接收"ClientHello"或"EncryptedExtensions"消息但没有"quic_transport_parameters"扩展的Endpoint必须关闭连接，错误类型为0x16d（相当于致命的TLS missing_extensions警报，请参阅第4.9节）。   
虽然在握手完成之前传输参数在技术上是可用的，但是在握手完成之前不能完全信任它们，并且应该尽量减少对它们的依赖。但是，对参数的任何篡改都会导致握手失败。   
端点不能在不使用QUIC的TLS连接中发送此扩展（例如在[TLS13]中定义的TCP中使用TLS）。如果在传输不是QUIC时收到扩展，则支持此扩展的实现必须发送致命的"unsupported_extension"警报。

### 8.3 删除EndOfEarlyData 消息
TLS的"EndOfEarlyData"消息未与QUIC一起使用。QUIC不依赖于此消息来标记0-RTT数据的结束，也不表示握手键的更改。   
客户端禁止发送 "EndOfEarlyData"消息。服务器必须将收到0-RTT数据包中的**CRYPTO**帧视为**PROTOCOL_VIOLATION**类型的连接错误。   
因此，"EndOfEarlyData"不会出现在TLS握手记录中。

## 9 安全考虑因素
最终可能会有一些现实中的的冲突，但目前的一系列问题在正文的相关章节中得到了很好的体现。   
千万不要认为因为它不在安全考虑部分，它不会影响安全性。本文档的大部分内容都是这样。   

### 9.1 使用0-RTT重放攻击
如[TLS13]第8节所述，使用TLS早期数据会暴露于重放攻击。在QUIC中使用0-RTT同样容易受到重放攻击。   
端点必须实现和使用[TLS13]中描述的重放保护，但是人们认识到这些保护是不完善的。因此，需要额外考虑重放的风险。   
QUIC不易受到重播攻击，除非通过它可能携带的应用程序协议信息。基于[QUIC-TRANSPORT]中定义的帧类型管理QUIC协议状态不易重播。QUIC帧的处理是幂等的，如果帧被重放、重新排序或丢失，则不会导致无效的连接状态。QUIC连接不会产生持续超过连接生存期的效果，QUIC连接不会产生超过连接生命周期的效果，除了由QUIC服务的应用程序协议产生的影响。   
注意：TLS会话凭证和地址验证Token用于在连接之间传输QUIC配置信息。这些不能用于携带应用程序语义。重用这些Token的可能性意味着它们需要更强大的保护来防止重播。   
在连接上接受0-RTT的服务器比接受不接受0-RTT的连接产生更高的成本。这包括更高的处理和计算成本。服务器在接受0-RTT时需要考虑重放的概率和所有相关的成本。   
最终，使用0-RTT管理重播攻击风险的责任在于应用程序协议。使用QUIC的应用程序协议必须描述协议如何使用0-RTT以及用于防止重播攻击的措施。重播风险分析需要考虑所有携带应用程序语义的QUIC协议特性。   
完全禁用0-RTT是最有效的防御重放攻击。   
QUIC扩展必须描述重放攻击如何影响它们的操作，或者禁止它们在0-RTT中使用。应用程序协议必须禁止使用在0-RTT中携带应用程序语义的扩展，或者提供重放缓解策略。

### 9.2 缓解包反射攻击
小"ClientHello"会导致来自服务器的大量握手消息，可用于包反射攻击，以放大攻击者生成的通信量。   
QUIC包括三种防御措施。首先，包含"ClientHello"的包必须填充到最小大小。第二，如果响应未经验证的源地址，则禁止服务器在其第一次飞行中发送超过三个UDP数据报（见[QUIC-TRANSPORT]第8.1节）。最后，由于握手包的确认是经过身份验证的，盲目攻击者无法伪造它们。总之，这些防御措施限制了放大攻击。

### 9.3 包头保护分析
[NAN]分析提供nonce隐私的认证加密算法，称为"Hide nonce"（HN）转换。本文档中的一般包头保护结构是其中一种算法（HN1）。包头保护使用包保护AEAD的输出导出“sample”，然后使用伪随机函数（PRF）加密包头字段，如下所示：
```
protected_field = field XOR PRF(hp_key, sample)
```
本文档中的报头保护变体使用伪随机排列（PRP）代替通用PRF。然而，由于所有PRP也是PRF[IMC]，这些变体不会偏离HN1结构。   
由于“hp_key”不同于包保护密钥，因此，报头保护实现了[NAN]中定义的AE2安全性，从而保证了受保护的包报头“field”的隐私性。未来基于这种结构的报头保护变体必须使用PRF来确保同等的安全保证。   
多次使用同一密钥和密文样本会有损害报头保护的风险。使用相同的密钥和密文示例保护两个不同的标头会显示受保护字段的异或。假设AEAD充当PRF，如果采样L位，则两个密文样本相同的概率接近2^（-L/2），即生日界限。对于本文中描述的算法，这个概率是2^64中的一个。   
注意：在某些情况下，可能会使用比数据包保护算法要求的完整大小短的输入。   
为了防止攻击者修改数据包报头，使用数据包保护对报头进行传递性身份验证；整个数据包报头是经过身份验证的附加数据的一部分。伪造或修改的受保护字段只有在删除包保护后才能检测到。   

### 9.4 包头保护Timing Side-Channels
攻击者可以猜测数据包编号或密钥阶段位的值，并通过"Timing Side-Channels"让端点确认猜测。类似地，对分组号长度的猜测可以试验和公开。如果一个包的接收者丢弃了具有重复包号的包，而不尝试解除包保护，则它们可以通过"Timing Side-Channels"揭示包号与接收到的包相匹配。为了使认证不受旁"Side-Channels"的影响，必须同时应用报头保护移除、分组号恢复和分组保护移除的整个过程，而不需要定时和其他"Side-Channels"。   
对于分组的发送，分组有效载荷和分组号的构造和保护必须不受可能暴露分组号或其编码大小的"Side-Channels"的影响。   
在密钥更新期间，生成新密钥所花费的时间可以通过"Timing Side-Channels"显示密钥更新已经发生。或者，当攻击者注入数据包时，此"Side-Channels"可能会显示注入包的密钥阶段位的值。接收到密钥更新后，端点应生成并保存下一组接收包保护密钥，如第6.3节所述。通过在接收到密钥更新之前生成新密钥，接收包将不会产生泄漏密钥阶段位值的定时信号。   
这取决于在包处理期间不进行密钥生成，并且可能要求端点维护三组分组保护密钥以进行接收：用于前一密钥阶段、当前密钥阶段和下一密钥阶段。端点可以选择推迟下一个接收包保护密钥的生成，直到它们丢弃旧密钥，这样在任何时间点只需要保留两组接收密钥。   

### 9.5 密钥多样性
在使用TLS时，使用TLS的中心密钥调度。由于TLS握手消息被集成到加密计算中，包含QUIC传输参数扩展可确保握手和1-RTT密钥与通过TCP运行TLS的服务器产生的密钥不同。为了避免跨协议密钥同步的可能性，还提供了额外的措施来改进密钥分离。    
QUIC包保护密钥和IVs是使用与TLS中的等效密钥不同的标签来派生的。   
为了保持这种分离，新版本的QUIC应该为包保护密钥和IV以及头保护密钥定义新的密钥派生标签。这个版本的QUIC使用字符串“QUIC”。其他版本可以使用特定于版本的标签来代替该字符串。   
初始加密使用特定于协商的QUIC版本的密钥。新的QUIC版本应该定义一个用于计算初始机密的新salt值。    

## 10 IANA考虑
本文档不创建任何新的IANA注册表，但它在以下注册表中注册值：
+ TLS ExtensionType Values Registry[TLS-REGISTRIES]-IANA将注册第8.2节中找到的“quic_transport_parameters”扩展。建议列应标记为“是”。TLS 1.3列包括CH和EE。  
+ QUIC传输错误代码注册表[QUIC-Transport]-IANA将注册**KEY_UPDATE_ERROR**（0xE），如第6.7节所述。

## 11 引用

### 11.1 规范性引用文件
```
[AEAD]   McGrew, D., "An Interface and Algorithms for Authenticated
         Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
         <https://www.rfc-editor.org/info/rfc5116>.
[AES]    "Advanced encryption standard (AES)",
         DOI 10.6028/nist.fips.197, National Institute of Standards
         and Technology report, November 2001,
         <https://doi.org/10.6028/nist.fips.197>.
[ALPN]   Friedl, S., Popov, A., Langley, A., and E. Stephan,
         "Transport Layer Security (TLS) Application-Layer Protocol
         Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
         July 2014, <https://www.rfc-editor.org/info/rfc7301>.
[CHACHA] Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF
         Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,
         <https://www.rfc-editor.org/info/rfc8439>.
[QUIC-RECOVERY]
         Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection
         and Congestion Control", Work in Progress, Internet-Draft,
         draft-ietf-quic-recovery-27, 21 February 2020,
         <https://tools.ietf.org/html/draft-ietf-quic-recovery-27>.
[QUIC-TRANSPORT]
         Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
         Multiplexed and Secure Transport", Work in Progress,
         Internet-Draft, draft-ietf-quic-transport-27, 21 February
         2020, <https://tools.ietf.org/html/draft-ietf-quic-
         transport-27>.
[RFC2119] 
         Bradner, S., "Key words for use in RFCs to Indicate
         Requirement Levels", BCP 14, RFC 2119,
         DOI 10.17487/RFC2119, March 1997,
         <https://www.rfc-editor.org/info/rfc2119>.
[RFC8174]Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
         2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
         May 2017, <https://www.rfc-editor.org/info/rfc8174>.
[SHA]    Dang, Q., "Secure Hash Standard",
         DOI 10.6028/nist.fips.180-4, National Institute of
         Standards and Technology report, July 2015,
         <https://doi.org/10.6028/nist.fips.180-4>.
[TLS-REGISTRIES]
         Salowey, J. and S. Turner, "IANA Registry Updates for TLS
         and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,
         <https://www.rfc-editor.org/info/rfc8447>.
[TLS13]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
         Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
         <https://www.rfc-editor.org/info/rfc8446>.
```

### 11.2 资料性引用
```
[AEBounds] 
         Luykx, A. and K. Paterson, "Limits on Authenticated
         Encryption Use in TLS", 8 March 2016,
         <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.
[HTTP2-TLS13]
         Benjamin, D., "Using TLS 1.3 with HTTP/2", Work in
         Progress, Internet-Draft, draft-ietf-httpbis-
         http2-tls13-03, 17 October 2019, <http://www.ietf.org/
         internet-drafts/draft-ietf-httpbis-http2-tls13-03.txt>.
[IMC]    Katz, J. and Y. Lindell, "Introduction to Modern
         Cryptography, Second Edition", ISBN 978-1466570269, 6
         November 2014.
[NAN]    Bellare, M., Ng, R., and B. Tackmann, "Nonces Are Noticed:
         AEAD Revisited", DOI 10.1007/978-3-030-26948-7_9, Advances
         in Cryptology - CRYPTO 2019 pp. 235-265, 2019,
         <https://doi.org/10.1007/978-3-030-26948-7_9>.
[QUIC-HTTP]
         Bishop, M., Ed., "Hypertext Transfer Protocol Version 3
         (HTTP/3)", Work in Progress, Internet-Draft, draft-ietf-
         quic-http-27, 21 February 2020,
         <https://tools.ietf.org/html/draft-ietf-quic-http-27>.
[RFC2818] Rescorla, E., "HTTP Over TLS", RFC 2818,
         DOI 10.17487/RFC2818, May 2000,
         <https://www.rfc-editor.org/info/rfc2818>.
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
         Housley, R., and W. Polk, "Internet X.509 Public Key
         Infrastructure Certificate and Certificate Revocation List
         (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
         <https://www.rfc-editor.org/info/rfc5280>.
```

## 附录
。。。