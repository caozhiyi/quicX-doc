
# 使用TLS保护QUIC草案
## 摘要
本文描述了如何使用传输层安全性（TLS）来保护QUIC。


## 1 简介
本文档描述了如何使用TLS[TLS13]保护QUIC[QUIC-TRANSPORT]。    
TLS 1.3为以前版本的连接建立提供了关键的延迟改进。在没有数据包丢失的情况下，大多数新的连接都可以在一次往返中建立和保护；在同一客户机和服务器之间的后续连接上，客户机通常可以立即发送应用程序数据，即使用零往返设置。    
本文描述了TLS如何作为QUIC的安全组件。

## 2 符号约定

## 2.1 TLS概述
TLS为两个端点提供了一种在不受信任的介质（即Internet）上建立通信方式的方法，以确保它们交换的消息不能被观察、修改或伪造。    
在内部，TLS是一个分层协议，其结构如图1所示。
```
          +-------------+------------+--------------+---------+
Handshake |             |            |  Application |         |
Layer     |  Handshake  |   Alerts   |     Data     |   ...   |
          |             |            |              |         |
          +-------------+------------+--------------+---------+
Record    |                                                   |
Layer     |                      Records                      |
          |                                                   |
          +---------------------------------------------------+

                            Figure 1: TLS Layers
```
每个握手层消息（例如，握手、警报和应用程序数据）由记录层作为一系列类型化的TLS记录进行传输。记录被单独地加密保护，然后通过可靠的传输（通常是TCP）传输，它提供排序和有保证的传输。    
TLS认证密钥交换发生在两个端点之间：客户端和服务器。客户端启动交换，服务器响应。如果密钥交换成功完成，客户机和服务器都将同意一个密钥。TLS支持预共享密钥（PSK）和Diffie-Hellman在有限域或椭圆曲线（（EC）DHE）密钥交换上。PSK是0-RTT的基础，后者在（EC）DHE密钥被破坏时提供了完美的前向保密（PFS）。    
完成TLS握手后，客户机将识别并验证服务器的身份，并且服务器可以选择性地识别和验证客户机的身份。TLS支持服务器和客户端的基于X.509[RFC5280]证书的身份验证。    
TLS密钥交换能够抵抗攻击者的篡改，并且它产生的共享机密不能被任何一个参与的对等方控制。    
TLS提供了两种QUIC感兴趣的基本握手模式： 
+ 一种完整的1-RTT握手，在这种握手中，客户机能够在往返一次后发送应用程序数据，服务器在收到来自客户机的第一条握手消息后立即作出响应。
+ 一种0-RTT握手，在这种握手中，客户机使用它以前了解到的有关服务器的信息来立即发送应用程序数据。攻击者可以重放此应用程序数据，因此它不能携带任何非幂等操作的自包含触发器。   
 
图2显示了使用0-RTT应用程序数据的简化TLS握手。请注意，这忽略了在QUIC中没有使用的EndOfEarlyData消息（见第8.3节）。同样，QUIC不使用ChangeCipherSpec和KeyUpdate消息；ChangeCipherSpec在TLS 1.3中是冗余的，QUIC定义了自己的密钥更新机制（第6节）。
```
 Client                                             Server

 ClientHello
 (0-RTT Application Data)  -------->
                                                ServerHello
                                      {EncryptedExtensions}
                                                 {Finished}
                          <--------      [Application Data]
 {Finished}                -------->

 [Application Data]        <------->     [Application Data]

 () Indicates messages protected by Early Data (0-RTT) Keys
 {} Indicates messages protected using Handshake Keys
 [] Indicates messages protected using Application Data
    (1-RTT) Keys

            图 2: TLS 0-RTT 握手过程
```
使用多种加密级别保护数据：
+ 初始密钥
+ 早期数据（0-RTT）密钥
+ 握手密钥
+ 应用数据（1-RTT）密钥

应用程序数据可能只出现在早期数据和应用程序数据级别。握手和警报消息可以出现在任何级别。   
0-RTT握手只有在客户机和服务器之前进行过通信的情况下才可能。在1-RTT握手中，客户端在接收到服务器发送的所有握手消息之前无法发送受保护的应用程序数据。    

## 3 协议概述
QUIC[QUIC-TRANSPORT]负责数据包的机密性和完整性保护。为此，它使用从TLS握手[TLS13]中派生的密钥，但TLS握手和警报消息不是通过QUIC传输（与TCP一样），而是通过QUIC传输直接传输TLS握手和警报消息，QUIC传输接管了TLS记录层的职责，如图3所示。
```
+--------------+--------------+ +-------------+
|     TLS      |     TLS      | |    QUIC     |
|  Handshake   |    Alerts    | | Applications|
|              |              | |  (h3, etc.) |
+--------------+--------------+-+-------------+
|                                             |
|                QUIC Transport               |
|   (streams, reliability, congestion, etc.)  |
|                                             |
+---------------------------------------------+
|                                             |
|            QUIC Packet Protection           |
|                                             |
+---------------------------------------------+

             图 3: QUIC 层
```
QUIC还依赖TLS来验证和协商对安全性和性能至关重要的参数。这两个协议不是严格的分层，而是相互协作：QUIC使用TLS握手；TLS使用QUIC提供的可靠性、有序传递和记录层。   
在高层次上，TLS和QUIC组件之间有两个主要的交互作用：
+ TLS组件通过QUIC组件发送和接收消息，QUIC为TLS提供可靠的流抽象。
+ TLS组件为QUIC组件提供了一系列更新，包括（a）安装新的包保护密钥（b）状态更改，如握手完成、服务器证书等。

图4更详细地展示了这些交互，特别调用了QUIC包保护。
```
   +------------+                               +------------+
   |            |<---- Handshake Messages ----->|            |
   |            |<- Validate 0-RTT parameters ->|            |
   |            |<--------- 0-RTT Keys ---------|            |
   |    QUIC    |<------- Handshake Keys -------|    TLS     |
   |            |<--------- 1-RTT Keys ---------|            |
   |            |<------- Handshake Done -------|            |
   +------------+                               +------------+
    |         ^
    | Protect | Protected
    v         | Packet
   +------------+
   |   QUIC     |
   |  Packet    |
   | Protection |
   +------------+

                    图 4: QUIC 和 TLS 交互
```
与TCP上的TLS不同，要发送数据的QUIC应用程序不会通过TLS“application_data”记录发送数据。相反，它们将其作为QUIC**STREAM**帧或其他帧类型发送，然后在QUIC包中进行传输。

## 4 携带TLS信息
QUIC以**CRYPTO**帧的形式传输TLS握手数据，每个帧由一个由偏移量和长度标识的连续握手数据块组成。这些帧被打包成QUIC包，并在当前TLS加密级别下进行加密。与TCP上的TLS一样，一旦TLS数据被传递到QUIC，QUIC就有责任可靠地传递它。TLS生成的每个数据块都与TLS当前使用的密钥集相关联。如果QUIC需要重新传输数据，它必须使用相同的密钥，即使TLS已经更新为新的密钥。    
TLS记录（与TCP一起使用）和QUIC **CRYPTO**帧之间的一个重要区别是，在QUIC中，只要多个帧与相同的加密级别相关联，它们就可能出现在同一个QUIC包中。例如，一个实现可以将握手消息和一些握手数据的ACK绑定到同一个包中。    
有些帧在不同的加密级别被禁止，有些帧不能被发送。这里的规则概括了TLS的规则，因为与建立连接相关的帧通常可以出现在任何加密级别，而与传输数据相关的帧只能出现在0-RTT和1-RTT加密级别：
+ **PADDING**和**PING**帧**可以**出现在任何加密级别的包中。
+ QUIC层（0x1c类型）的**CRYPTO**帧和标识QUIC层错误的**CONNECTION_CLOSE**帧（类型0x1c）能出现在除0-RTT之外的任何加密级别的数据包中。
+ 标识应用程序错误的**CONNECTION_CLOSE**帧（类型0x1d）只能在1-RTT加密级别的数据包中发送。
+ **ACK**帧可以出现在0-RTT以外的任何加密级别的分组中，但是只能确认出现在该分组号空间中的分组。
+ 所有其他帧类型只能以0-RTT和1-RTT级别发送。  

请注意，由于各种原因，无法在0-RTT中发送以下帧：**ACK**、**CRYPTO**、**HANDSHAKE_DONE**、**NEW_TOKEN**、**PATH_RESPONSE**和**RETIRE_CONNECTION_ID**。    
因为数据包可以在网络上重新排序，QUIC使用数据包类型来指示给定数据包的加密级别，如表1所示。当需要发送多个不同加密级别的数据包时，Endpoint应该使用合并的数据包在同一个UDP数据报中发送它们。
```
+---------------------+------------------+-----------+
| Packet Type         | Encryption Level | PN Space  |
+=====================+==================+===========+
| Initial             | Initial secrets  | Initial   |
+---------------------+------------------+-----------+
| 0-RTT Protected     | 0-RTT            | 0/1-RTT   |
+---------------------+------------------+-----------+
| Handshake           | Handshake        | Handshake |
+---------------------+------------------+-----------+
| Retry               | N/A              | N/A       |
+---------------------+------------------+-----------+
| Version Negotiation | N/A              | N/A       |
+---------------------+------------------+-----------+
| Short Header        | 1-RTT            | 0/1-RTT   |
+---------------------+------------------+-----------+

         表 1: 按数据包类型划分的加密级别
```
[QUIC-TRANSPORT]的第17节展示了不同加密级别的数据包如何适应握手过程。

### 4.1 TLS接口
如图4所示，QUIC到TLS的接口主要有四个功能:
+ 发送和接收握手信息
+ 从恢复的会话处理存储的传输和应用程序状态，并确定接受早期数据是否有效
+ 重新键入（发送和接收）
+ 握手状态更新
配置TLS可能需要其他功能。

#### 4.1.1 握手完成
在本文中，当TLS协议栈报告握手完成时，TLS握手被认为是完成的。当TLS堆栈既发送了完成的消息，又验证了对等方的完成消息时，即任务握手完成。验证对端是否完成为端点提供了一个保证，即先前的握手消息没有被修改。请注意，握手不会在两个端点同时完成。因此，任何基于握手完成的需求都取决于所讨论端点的视角。

#### 4.1.2 握手确认
在本文中，TLS握手在握手完成时被认为是在服务器上确认的。在客户端，当接收到**HANDSHAKE_DONE**帧时，握手被认为是确认的。    
当客户端接收到对1-RTT分组的确认时，**可以**考虑确认握手。这可以通过记录用1-RTT密钥发送的最低分组号来实现，并将其与任何接收到的1-RTT ACK帧中的最大确认字段进行比较：一旦后者大于或等于前者，则确认握手。    

#### 4.1.3 发送和接收握手消息
为了驱动握手，TLS依赖于能够发送和接收握手消息。这个接口有两个基本功能：一个是QUIC请求握手消息，另一个是QUIC提供握手包。    
在开始握手之前，QUIC向TLS提供它希望携带的传输参数（见第8.2节）。QUIC客户端通过从TLS请求TLS握手字节来启动TLS。客户端在发送第一个数据包之前获取握手字节。QUIC服务器通过向TLS提供客户端的握手字节来启动握手过程。    
在任何时候，端点处的TLS堆栈都将具有当前的发送加密级别和接收加密级别。每个加密级别都与不同的字节流相关联，这些字节流以**CRYPTO**帧的形式可靠地传输给对方。当TLS提供要发送的握手字节时，它们被附加到当前流中，并且任何包含**CRYPTO**帧的包都使用来自相应加密级别的密钥进行保护。    
QUIC将TLS握手记录中未受保护的内容作为加密帧的内容。QUIC不使用TLS记录保护。QUIC将**CRYPTO**帧组装成QUIC包，利用QUIC包保护对其进行保护。    
QUIC只能在**CRYPTO**帧中传输TLS握手记录。TLS警报转为QUIC **CONNECTION_CLOSE**携带的错误码；参见第4.9节。TLS应用程序数据和其他消息类型在任何加密级别都不能由QUIC携带，如果从TLS堆栈接收它们，则是一个错误。    
当端点从网络接收到包含**CRYPTO**帧的QUIC包时，其进行如下过程：
+ 如果数据包处于TLS接收加密级别，则像往常一样将数据排序到输入流中。与**STREAM**帧一样，偏移量用于在数据序列中找到适当的位置。如果此过程的结果是新数据可用，则按顺序将其传递到TLS。
+ 如果数据包来自先前安装的加密级别，则它**不能**扩展的包含数据放到该流中先前接收到的数据末尾。实现必须将任何违反此要求的行为视为**PROTOCOL_VIOLATION**类型的连接错误。
+ 如果数据包来自新的加密级别，则会将其保存以供TLS稍后处理。一旦TLS从这个加密级别开始接收，就可以提供保存的数据。当从任何新的加密级别向TLS提供数据时，如果TLS没有使用以前的加密级别的数据，则必须将其视为**PROTOCOL_VIOLATION**类型的连接错误。    

每次向TLS提供新数据时，都会从TLS请求新的握手字节。如果TLS接收到的握手消息不完整或没有要发送的数据，则TLS可能不会提供任何字节。    
一旦TLS握手完成，这将与TLS需要发送的任何最终握手字节一起指示给QUIC。TLS还向QUIC提供对等方在握手过程中公布的传输参数。    
一旦握手完成，TLS将变为被动。TLS仍然可以从其对等方接收数据并以实物方式响应，但除非应用程序或QUIC特别要求，否则它不需要发送更多数据。发送数据的一个原因是服务器可能希望向客户端提供额外或更新的会话凭证。    
当握手完成时，QUIC只需要向TLS提供到达加密流的任何数据。与握手期间的方法相同，在提供接收到的数据后，从TLS请求新数据。

#### 4.1.4 加密级别更改
当新加密级别的密钥可用时，TLS为QUIC提供这些密钥。另外，当给定加密级别的密钥对TLS可用时，TLS向QUIC指示在该加密级别上读写密钥是可用的。这些事件不是异步的；它们总是在TLS获得新的握手字节之后或者TLS生成握手字节之后立即发生。    
TLS为QUIC提供了三项新的加密级别：
+ 密钥
+ 一个经过身份验证的关联数据加密（AEAD）函数
+ 密钥派生函数（KDF）    

这些值基于TLS协商的结果，QUIC使用这些值生成包和头保护密钥（见第5节和第5.4节）。    
如果0-RTT是可能的，那么在客户端发送TLS "ClientHello"消息或服务器接收到该消息之后，它就准备好了。在向QUIC客户机提供第一个握手字节后，TLS堆栈可能会向0-RTT密钥发出更改信号。在服务器上，在接收到包含"ClientHello"消息的握手字节后，TLS服务器可能会发出0-RTT密钥可用的信号。    
虽然TLS一次只使用一个加密级别，但QUIC可能使用多个级别。例如，在发送完消息（在握手加密级别使用**CRYPTO**帧）之后，端点可以发送流数据（在1-RTT加密中）。如果完成的消息丢失，端点将使用握手加密级别重新传输丢失的消息。数据包的重新排序或丢失意味着QUIC将需要在多个加密级别处理数据包。在握手过程中，这意味着可能以高于或低于TLS使用的当前加密级别来处理数据包。    
特别是，服务器实现需要能够在握手加密级别和0-RTT加密级别同时读取数据包。客户端可以将由握手密钥保护的ACK帧与0-RTT数据交错，服务器需要处理这些确认以检测丢失的握手包。    
QUIC还需要访问TLS实现通常不可用的密钥。例如，客户端可能需要在准备发送加密级别的**CRYPTO**帧之前确认握手包。因此，TLS需要为QUIC提供密钥，然后才能为自己的用途生成密钥。

#### 4.1.5 TLS接口摘要