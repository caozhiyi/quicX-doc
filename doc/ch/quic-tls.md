
# 使用TLS保护QUIC草案
## 摘要
本文描述了如何使用传输层安全性（TLS）来保护QUIC。


## 1 简介
本文档描述了如何使用TLS[TLS13]保护QUIC[QUIC-TRANSPORT]。    
TLS 1.3为以前版本的连接建立提供了关键的延迟改进。在没有数据包丢失的情况下，大多数新的连接都可以在一次往返中建立和保护；在同一客户机和服务器之间的后续连接上，客户机通常可以立即发送应用程序数据，即使用零往返设置。    
本文描述了TLS如何作为QUIC的安全组件。

## 2 符号约定

## 2.1 TLS概述
TLS为两个端点提供了一种在不受信任的介质（即Internet）上建立通信方式的方法，以确保它们交换的消息不能被观察、修改或伪造。    
在内部，TLS是一个分层协议，其结构如图1所示。
```
          +-------------+------------+--------------+---------+
Handshake |             |            |  Application |         |
Layer     |  Handshake  |   Alerts   |     Data     |   ...   |
          |             |            |              |         |
          +-------------+------------+--------------+---------+
Record    |                                                   |
Layer     |                      Records                      |
          |                                                   |
          +---------------------------------------------------+

                            Figure 1: TLS Layers
```
每个握手层消息（例如，握手、警报和应用程序数据）由记录层作为一系列类型化的TLS记录进行传输。记录被单独地加密保护，然后通过可靠的传输（通常是TCP）传输，它提供排序和有保证的传输。    
TLS认证密钥交换发生在两个端点之间：客户端和服务器。客户端启动交换，服务器响应。如果密钥交换成功完成，客户机和服务器都将同意一个密钥。TLS支持预共享密钥（PSK）和Diffie-Hellman在有限域或椭圆曲线（（EC）DHE）密钥交换上。PSK是0-RTT的基础，后者在（EC）DHE密钥被破坏时提供了完美的前向保密（PFS）。    
完成TLS握手后，客户机将识别并验证服务器的身份，并且服务器可以选择性地识别和验证客户机的身份。TLS支持服务器和客户端的基于X.509[RFC5280]证书的身份验证。    
TLS密钥交换能够抵抗攻击者的篡改，并且它产生的共享机密不能被任何一个参与的对等方控制。    
TLS提供了两种QUIC感兴趣的基本握手模式： 
+ 一种完整的1-RTT握手，在这种握手中，客户机能够在往返一次后发送应用程序数据，服务器在收到来自客户机的第一条握手消息后立即作出响应。
+ 一种0-RTT握手，在这种握手中，客户机使用它以前了解到的有关服务器的信息来立即发送应用程序数据。攻击者可以重放此应用程序数据，因此它不能携带任何非幂等操作的自包含触发器。   
 
图2显示了使用0-RTT应用程序数据的简化TLS握手。请注意，这忽略了在QUIC中没有使用的EndOfEarlyData消息（见第8.3节）。同样，QUIC不使用ChangeCipherSpec和KeyUpdate消息；ChangeCipherSpec在TLS 1.3中是冗余的，QUIC定义了自己的密钥更新机制（第6节）。
```
 Client                                             Server

 ClientHello
 (0-RTT Application Data)  -------->
                                                ServerHello
                                      {EncryptedExtensions}
                                                 {Finished}
                          <--------      [Application Data]
 {Finished}                -------->

 [Application Data]        <------->     [Application Data]

 () Indicates messages protected by Early Data (0-RTT) Keys
 {} Indicates messages protected using Handshake Keys
 [] Indicates messages protected using Application Data
    (1-RTT) Keys

            图 2: TLS 0-RTT 握手过程
```
使用多种加密级别保护数据：
+ 初始密钥
+ 早期数据（0-RTT）密钥
+ 握手密钥
+ 应用数据（1-RTT）密钥

应用程序数据可能只出现在早期数据和应用程序数据级别。握手和警报消息可以出现在任何级别。   
0-RTT握手只有在客户机和服务器之前进行过通信的情况下才可能。在1-RTT握手中，客户端在接收到服务器发送的所有握手消息之前无法发送受保护的应用程序数据。    

## 3 协议概述
QUIC[QUIC-TRANSPORT]负责数据包的机密性和完整性保护。为此，它使用从TLS握手[TLS13]中派生的密钥，但TLS握手和警报消息不是通过QUIC传输（与TCP一样），而是通过QUIC传输直接传输TLS握手和警报消息，QUIC传输接管了TLS记录层的职责，如图3所示。
```
+--------------+--------------+ +-------------+
|     TLS      |     TLS      | |    QUIC     |
|  Handshake   |    Alerts    | | Applications|
|              |              | |  (h3, etc.) |
+--------------+--------------+-+-------------+
|                                             |
|                QUIC Transport               |
|   (streams, reliability, congestion, etc.)  |
|                                             |
+---------------------------------------------+
|                                             |
|            QUIC Packet Protection           |
|                                             |
+---------------------------------------------+

             图 3: QUIC 层
```
QUIC还依赖TLS来验证和协商对安全性和性能至关重要的参数。这两个协议不是严格的分层，而是相互协作：QUIC使用TLS握手；TLS使用QUIC提供的可靠性、有序传递和记录层。   
在高层次上，TLS和QUIC组件之间有两个主要的交互作用：
+ TLS组件通过QUIC组件发送和接收消息，QUIC为TLS提供可靠的流抽象。
+ TLS组件为QUIC组件提供了一系列更新，包括（a）安装新的包保护密钥（b）状态更改，如握手完成、服务器证书等。

图4更详细地展示了这些交互，特别调用了QUIC包保护。
```
   +------------+                               +------------+
   |            |<---- Handshake Messages ----->|            |
   |            |<- Validate 0-RTT parameters ->|            |
   |            |<--------- 0-RTT Keys ---------|            |
   |    QUIC    |<------- Handshake Keys -------|    TLS     |
   |            |<--------- 1-RTT Keys ---------|            |
   |            |<------- Handshake Done -------|            |
   +------------+                               +------------+
    |         ^
    | Protect | Protected
    v         | Packet
   +------------+
   |   QUIC     |
   |  Packet    |
   | Protection |
   +------------+

                    图 4: QUIC 和 TLS 交互
```
与TCP上的TLS不同，要发送数据的QUIC应用程序不会通过TLS“application_data”记录发送数据。相反，它们将其作为QUIC**STREAM**帧或其他帧类型发送，然后在QUIC包中进行传输。

## 4 携带TLS信息
QUIC以**CRYPTO**帧的形式传输TLS握手数据，每个帧由一个由偏移量和长度标识的连续握手数据块组成。这些帧被打包成QUIC包，并在当前TLS加密级别下进行加密。与TCP上的TLS一样，一旦TLS数据被传递到QUIC，QUIC就有责任可靠地传递它。TLS生成的每个数据块都与TLS当前使用的密钥集相关联。如果QUIC需要重新传输数据，它必须使用相同的密钥，即使TLS已经更新为新的密钥。    
TLS记录（与TCP一起使用）和QUIC **CRYPTO**帧之间的一个重要区别是，在QUIC中，只要多个帧与相同的加密级别相关联，它们就可能出现在同一个QUIC包中。例如，一个实现可以将握手消息和一些握手数据的ACK绑定到同一个包中。    
有些帧在不同的加密级别被禁止，有些帧不能被发送。这里的规则概括了TLS的规则，因为与建立连接相关的帧通常可以出现在任何加密级别，而与传输数据相关的帧只能出现在0-RTT和1-RTT加密级别：
+ **PADDING**和**PING**帧**可以**出现在任何加密级别的包中。
+ QUIC层（0x1c类型）的**CRYPTO**帧和标识QUIC层错误的**CONNECTION_CLOSE**帧（类型0x1c）能出现在除0-RTT之外的任何加密级别的数据包中。
+ 标识应用程序错误的**CONNECTION_CLOSE**帧（类型0x1d）只能在1-RTT加密级别的数据包中发送。
+ **ACK**帧可以出现在0-RTT以外的任何加密级别的分组中，但是只能确认出现在该分组号空间中的分组。
+ 所有其他帧类型只能以0-RTT和1-RTT级别发送。  

请注意，由于各种原因，无法在0-RTT中发送以下帧：**ACK**、**CRYPTO**、**HANDSHAKE_DONE**、**NEW_TOKEN**、**PATH_RESPONSE**和**RETIRE_CONNECTION_ID**。    
因为数据包可以在网络上重新排序，QUIC使用数据包类型来指示给定数据包的加密级别，如表1所示。当需要发送多个不同加密级别的数据包时，Endpoint应该使用合并的数据包在同一个UDP数据报中发送它们。
```
+---------------------+------------------+-----------+
| Packet Type         | Encryption Level | PN Space  |
+=====================+==================+===========+
| Initial             | Initial secrets  | Initial   |
+---------------------+------------------+-----------+
| 0-RTT Protected     | 0-RTT            | 0/1-RTT   |
+---------------------+------------------+-----------+
| Handshake           | Handshake        | Handshake |
+---------------------+------------------+-----------+
| Retry               | N/A              | N/A       |
+---------------------+------------------+-----------+
| Version Negotiation | N/A              | N/A       |
+---------------------+------------------+-----------+
| Short Header        | 1-RTT            | 0/1-RTT   |
+---------------------+------------------+-----------+

         表 1: 按数据包类型划分的加密级别
```
[QUIC-TRANSPORT]的第17节展示了不同加密级别的数据包如何适应握手过程。

### 4.1 TLS接口
如图4所示，QUIC到TLS的接口主要有四个功能:
+ 发送和接收握手信息
+ 从恢复的会话处理存储的传输和应用程序状态，并确定接受早期数据是否有效
+ 重新键入（发送和接收）
+ 握手状态更新
配置TLS可能需要其他功能。

#### 4.1.1 握手完成
在本文中，当TLS协议栈报告握手完成时，TLS握手被认为是完成的。当TLS堆栈既发送了完成的消息，又验证了对等方的完成消息时，即任务握手完成。验证对端是否完成为端点提供了一个保证，即先前的握手消息没有被修改。请注意，握手不会在两个端点同时完成。因此，任何基于握手完成的需求都取决于所讨论端点的视角。

#### 4.1.2 握手确认
在本文中，TLS握手在握手完成时被认为是在服务器上确认的。在客户端，当接收到**HANDSHAKE_DONE**帧时，握手被认为是确认的。    
当客户端接收到对1-RTT分组的确认时，**可以**考虑确认握手。这可以通过记录用1-RTT密钥发送的最低分组号来实现，并将其与任何接收到的1-RTT ACK帧中的最大确认字段进行比较：一旦后者大于或等于前者，则确认握手。    

#### 4.1.3 发送和接收握手消息
为了驱动握手，TLS依赖于能够发送和接收握手消息。这个接口有两个基本功能：一个是QUIC请求握手消息，另一个是QUIC提供握手包。    
在开始握手之前，QUIC向TLS提供它希望携带的传输参数（见第8.2节）。QUIC客户端通过从TLS请求TLS握手字节来启动TLS。客户端在发送第一个数据包之前获取握手字节。QUIC服务器通过向TLS提供客户端的握手字节来启动握手过程。    
在任何时候，端点处的TLS堆栈都将具有当前的发送加密级别和接收加密级别。每个加密级别都与不同的字节流相关联，这些字节流以**CRYPTO**帧的形式可靠地传输给对方。当TLS提供要发送的握手字节时，它们被附加到当前流中，并且任何包含**CRYPTO**帧的包都使用来自相应加密级别的密钥进行保护。    
QUIC将TLS握手记录中未受保护的内容作为加密帧的内容。QUIC不使用TLS记录保护。QUIC将**CRYPTO**帧组装成QUIC包，利用QUIC包保护对其进行保护。    
QUIC只能在**CRYPTO**帧中传输TLS握手记录。TLS警报转为QUIC **CONNECTION_CLOSE**携带的错误码；参见第4.9节。TLS应用程序数据和其他消息类型在任何加密级别都不能由QUIC携带，如果从TLS堆栈接收它们，则是一个错误。    
当端点从网络接收到包含**CRYPTO**帧的QUIC包时，其进行如下过程：
+ 如果数据包处于TLS接收加密级别，则像往常一样将数据排序到输入流中。与**STREAM**帧一样，偏移量用于在数据序列中找到适当的位置。如果此过程的结果是新数据可用，则按顺序将其传递到TLS。
+ 如果数据包来自先前安装的加密级别，则它**不能**扩展的包含数据放到该流中先前接收到的数据末尾。实现必须将任何违反此要求的行为视为**PROTOCOL_VIOLATION**类型的连接错误。
+ 如果数据包来自新的加密级别，则会将其保存以供TLS稍后处理。一旦TLS从这个加密级别开始接收，就可以提供保存的数据。当从任何新的加密级别向TLS提供数据时，如果TLS没有使用以前的加密级别的数据，则必须将其视为**PROTOCOL_VIOLATION**类型的连接错误。    

每次向TLS提供新数据时，都会从TLS请求新的握手字节。如果TLS接收到的握手消息不完整或没有要发送的数据，则TLS可能不会提供任何字节。    
一旦TLS握手完成，这将与TLS需要发送的任何最终握手字节一起指示给QUIC。TLS还向QUIC提供对等方在握手过程中公布的传输参数。    
一旦握手完成，TLS将变为被动。TLS仍然可以从其对等方接收数据并以实物方式响应，但除非应用程序或QUIC特别要求，否则它不需要发送更多数据。发送数据的一个原因是服务器可能希望向客户端提供额外或更新的会话凭证。    
当握手完成时，QUIC只需要向TLS提供到达加密流的任何数据。与握手期间的方法相同，在提供接收到的数据后，从TLS请求新数据。

#### 4.1.4 加密级别更改
当新加密级别的密钥可用时，TLS为QUIC提供这些密钥。另外，当给定加密级别的密钥对TLS可用时，TLS向QUIC指示在该加密级别上读写密钥是可用的。这些事件不是异步的；它们总是在TLS获得新的握手字节之后或者TLS生成握手字节之后立即发生。    
TLS为QUIC提供了三项新的加密级别：
+ 密钥
+ 一个经过身份验证的关联数据加密（AEAD）函数
+ 密钥派生函数（KDF）    

这些值基于TLS协商的结果，QUIC使用这些值生成包和头保护密钥（见第5节和第5.4节）。    
如果0-RTT是可能的，那么在客户端发送TLS "ClientHello"消息或服务器接收到该消息之后，它就准备好了。在向QUIC客户机提供第一个握手字节后，TLS堆栈可能会向0-RTT密钥发出更改信号。在服务器上，在接收到包含"ClientHello"消息的握手字节后，TLS服务器可能会发出0-RTT密钥可用的信号。    
虽然TLS一次只使用一个加密级别，但QUIC可能使用多个级别。例如，在发送完消息（在握手加密级别使用**CRYPTO**帧）之后，端点可以发送流数据（在1-RTT加密中）。如果完成的消息丢失，端点将使用握手加密级别重新传输丢失的消息。数据包的重新排序或丢失意味着QUIC将需要在多个加密级别处理数据包。在握手过程中，这意味着可能以高于或低于TLS使用的当前加密级别来处理数据包。    
特别是，服务器实现需要能够在握手加密级别和0-RTT加密级别同时读取数据包。客户端可以将由握手密钥保护的ACK帧与0-RTT数据交错，服务器需要处理这些确认以检测丢失的握手包。    
QUIC还需要访问TLS实现通常不可用的密钥。例如，客户端可能需要在准备发送加密级别的**CRYPTO**帧之前确认握手包。因此，TLS需要为QUIC提供密钥，然后才能为自己的用途生成密钥。

#### 4.1.5 TLS接口摘要
图5总结了客户机和服务器的QUIC和TLS之间的交换。每个箭头都标记有用于该传输的加密级别。
```
   Client                                                    Server

   Get Handshake
                        Initial ------------->
                                                 Handshake Received
   Install tx 0-RTT Keys
                        0-RTT --------------->
                                                      Get Handshake
                        <------------- Initial
   Handshake Received
   Install Handshake keys
                                              Install rx 0-RTT keys
                                             Install Handshake keys
                                                      Get Handshake
                        <----------- Handshake
   Handshake Received
                                              Install tx 1-RTT keys
                        <--------------- 1-RTT
   Get Handshake
   Handshake Complete
                        Handshake ----------->
                                                 Handshake Received
                                              Install rx 1-RTT keys
                                                 Handshake Complete
   Install 1-RTT keys
                        1-RTT --------------->
                                                      Get Handshake
                        <--------------- 1-RTT
   Handshake Received

                      Figure 5: QUIC与TLS的交互
```
图5显示了构成单独处理的消息的单个“飞行”的多个包，以显示哪些传入消息触发不同的操作。在处理完所有传入数据包后，将请求新的握手消息。这个过程可能会有所不同，这取决于QUIC实现和它们接收到的包的结构。

### 4.2 TLS版本
本文档描述了TLS 1.3[TLS13]如何与QUIC一起使用。    
实际上，TLS握手将协商要使用的TLS版本。如果两个端点都支持1.3版本，这可能会导致协商一个比1.3更新的TLS版本。如果QUIC使用的tls1.3特性得到更新版本的支持，这是可以接受的。    
配置错误的TLS实现可以协商tls1.2或其他旧版本的TLS。如果协商的TLS版本早于1.3，则Endpoint**必须**终止连接。

### 4.3 ClientHello大小
来自客户端的第一个初始数据包包含其第一个加密握手消息的开始或全部，对于TLS来说是"ClientHello"。服务器可能需要解析整个"ClientHello"（例如，访问服务器名称标识（SNI）或应用层协议协商（ALPN））等扩展，以决定是否接受新的传入QUIC连接。如果"ClientHello"跨越多个初始数据包，这样服务器就需要缓冲第一个接收到的片段，如果客户端的地址还没有被验证，这可能会消耗过多的资源。为了避免这种情况，服务器可以使用重试功能（参见[QUIC-TRANSPORT]的第8.1节），只缓冲来自具有验证地址的客户端的部分"ClientHello"消息。    
QUIC包和帧为"ClientHello"消息增加了至少36字节的开销。如果客户机选择长度不为零的连接ID，则开销会增加。开销也不包括Token或长度超过8字节的连接ID，如果服务器发送重试包，则可能需要这两个字节。    
典型的TLS "ClientHello"可以很容易地放入1200字节的数据包中。然而，除了QUIC增加的管理开销外，还有几个变量可能导致超出此限制。大session 凭证、多个或大共享密钥、受支持密码的长列表、签名算法、版本、QUIC传输参数和其他可协商参数和扩展可能导致此消息增长。对于服务器，除了连接ID和Token外，TLS session凭证的大小也会影响客户端高效连接的能力。最小化这些值的大小会增加客户端可以使用它们的概率，并且仍然将"ClientHello"消息放入第一个初始包中。   
TLS实现不需要确保"ClientHello"足够大。添加QUIC **PADDING**帧就可以以根据需要增加数据包的大小。 

### 4.4 对等身份验证
身份验证的要求取决于所使用的应用程序协议。TLS提供服务器身份验证并允许服务器请求客户端身份验证。  
端户机必须验证服务器的身份。这通常涉及到验证服务器的身份是否包含在证书中，以及证书是否由受信任的实体颁发（例如请参见[RFC2818]）。在握手过程中，服务器可以请求客户端进行身份验证。如果客户端在请求时无法进行身份验证，则服务器可能会拒绝连接。客户机身份验证的要求因应用程序协议和部署而异。    
服务器不能使用握手后的客户端身份验证（如[TLS13]第4.6.2节所定义），因为QUIC提供的多路复用阻止客户端将证书请求与触发该请求的应用程序级事件相关联（参见[HTTP2-TLS13]）。更具体地说，服务器不能发送握手后的TLS "CertificateRequest"消息，客户端必须将接收到的此类消息视为**PROTOCOL_VIOLATION**类型的连接错误。

### 4.5 启用0-RTT
为了表达他们处理0-RTT数据的意愿，服务器发送一条NewSessionTicket消息，其中包含“early_data”扩展名，max_early_data_size为0xffffffff；客户端可以在0-RTT中发送的数据量由服务器提供的“initial_max_data”传输参数控制。服务器在发送“early_data”扩展时，不能将max_early_data_size设置为0xffffffff以外的任何值。客户机必须将接收到的包含“early_data”扩展名和任何其他值的"NewSessionTicket"视为**PROTOCOL_VIOLATION**类型的连接错误。   
希望发送0-RTT数据包的客户端在随后握手的"ClientHello"消息中使用“early_data”扩展（见[TLS13]的4.2.10节）。然后它以0-RTT包的形式发送应用程序数据。

### 4.6 接受和拒绝0-RTT
服务器通过发送"EncryptedExtensions"中的"early_data"扩展来接受0-RTT（参见[TLS13]的4.2.10节）。然后，服务器处理并确认它接收到的0-RTT包。服务器通过发送不带"early_data"扩展名的"EncryptedExtensions"拒绝0-RTT。如果服务器发送TLS "HelloRetryRequest"，它将始终拒绝0-RTT。拒绝0-RTT后，服务器不能处理任何0-RTT数据包，即使具备处理能力。当0-RTT被拒绝后，如果客户端能够检测到这种情况，则应将收到的0-RTT数据包确认视为**PROTOCOL_VIOLATION**类型的连接错误。   
当0-RTT被拒绝后，客户端假定的所有连接特征都可能不正确。这包括应用程序协议、传输参数和任何应用程序配置的选择。
因此，客户端必须重置所有流的状态，包括绑定到这些流的应用程序状态。   
如果客户端收到重试或版本协商包，则可能会尝试再次发送0-RTT。这些数据包并不表示拒绝0-RTT。

### 4.7 验证0-RTT配置
当服务器接收到带有“early_data”扩展的"ClientHello"时，它必须决定是接受还是拒绝来自客户端的早期数据。有些决定是由TLS协议栈做出的（例如，检查正在恢复的密码套件是否包含在ClientHello中；参见[TLS13]第4.2.10节）。即使TLS协议栈没有理由拒绝早期数据，QUIC协议或使用QUIC的应用程序协议可能会拒绝早期数据，因为与恢复会话相关联的传输或应用程序配置与服务器的当前配置不兼容。   
QUIC要求附加的传输状态与0-RTT会话凭证相关联。实现这一点的一种常见方法是使用无状态会话凭证并将此状态存储在会话凭证中。使用QUIC的应用程序协议在关联或存储状态方面可能有类似的要求。此关联状态用于决定是否必须拒绝早期数据。例如，HTTP/3（[QUIC-HTTP]）设置决定如何解释来自客户端的早期数据。使用QUIC的其他应用程序在确定是否接受或拒绝早期数据时可能有不同的要求。

### 4.8 HelloRetryRequest
在TCP上的TLS中，"HelloRetryRequest"特性（见[TLS13]的4.1.4节）可用于纠正客户机不正确的”KeyShare“扩展以及无状态的往返检查。从QUIC的角度来看，这看起来就像初始加密级别中携带的附加消息。虽然原则上可以在QUIC中使用此功能进行地址验证，但是QUIC实现应该使用重试功能（参见[QUIC-TRANSPORT]的第8.1节）。"HelloRetryRequest"仍然用于请求共享。

### 4.9 TLS错误
如果TLS遇到错误，它会生成[TLS13]第6节中定义的适当警报。   
通过将单字节警报描述转换为QUIC错误码，TLS警报将转变为QUIC连接错误。警报描述被添加到0x100中，以在为**CRYPTO_ERROR**保留的范围内生成QUIC错误代码。结果值在QUIC **CONNECTION_CLOSE**帧中发送。   
所有TLS警报的警报级别均为“fatal”；TLS堆栈不得生成“warning”级别的警报。

### 4.10 丢弃未使用的密钥
QUIC移动到新的加密级别后，以前加密级别的数据包保护密钥可以被丢弃。这种情况在握手过程中以及密钥更新时会发生多次；请参阅第6节。   
当新密钥可用时，不会立即丢弃包保护密钥。如果来自较低加密级别的数据包包含**CRYPTO**帧，则重新传输该数据的帧必须在同一加密级别发送。类似地，端点为与所确认的数据包相同的加密级别的包生成确认。因此，在新的加密级别的密钥可用后的短时间内，可能需要较低加密级别的密钥。   
端点不能丢弃给定加密级别的密钥，除非它已接收并确认该加密级别的所有**CRYPTO**帧，并且该加密级别的所有**CRYPTO**帧都已被其对端确认。但是，这并不保证在该加密级别上不再需要接收或发送更多的数据包，因为对等方可能没有收到达到相同状态所需的所有确认。   
虽然端点可能保留旧密钥，但新数据必须以当前可用的最高加密级别发送。只有**ACK**帧和**CRYPTO**帧中数据的重传在先前的加密级别被发送。这些包还可能包括**PADDING**帧。

#### 4.10.1 丢弃初始密钥
使用初始密钥（第5.2节）保护的数据包没有经过身份验证，这意味着攻击者可以伪造数据包，意图中断连接。为了限制这些攻击，可以比其他密钥更早地丢弃初始包保护密钥。   
握手包的成功使用表明不再需要交换更多的初始包，因为这些密钥只能在从初始包接收到所有**CRYPTO**帧之后产生。因此，客户端在第一次发送握手包时必须丢弃初始密钥，而服务器在首次成功处理握手包时必须丢弃初始密钥。端点在此之后**不得**发送初始数据包。   
这将导致放弃初始加密级别的丢失恢复状态，并忽略任何未完成的初始数据包。

#### 4.10.2 丢弃握手密钥
当TLS握手被确认时，端点必须丢弃它的握手密钥（第4.1.2节）。服务器**必须**在完成握手后立即发送**HANDSHAKE_DONE**帧。    

#### 4.10.3 丢弃0-RTT密钥
0-RTT和1-RTT包共享相同的包号空间，客户端在发送1-RTT包后不发送0-RTT包（第5.6节）。因此，客户端应该在安装1-RTT密钥后立即丢弃0-RTT密钥，因为在那之后它们就没有用处了。   
另外，服务器在接收到1-RTT包时可能会丢弃0-RTT密钥。然而，由于包的重新排序，0-RTT包可能在1-RTT包之后到达。服务器可以暂时保留0-RTT密钥，以允许对重新排序的包进行解密，而无需使用1-RTT密钥重新传输其内容。在接收到1-RTT数据包后，服务器必须在短时间内丢弃0-RTT密钥；建议的时间段是探测超时的三倍（PTO，请参阅[QUIC-RECOVERY]）。如果服务器确定它已经接收到所有0-RTT包，可以通过跟踪丢失的包号来提前丢弃0-RTT密钥。

## 5 包保护
与TCP上的TLS一样，QUIC使用TLS协商的AEAD算法，用TLS握手派生的密钥保护数据包。

### 5.1 数据包保护密钥
QUIC派生包保护密钥的方式与TLS导出记录保护密钥的方式相同。这些流量加密由TLS导出（见[TLS13]第7.1节），QUIC将其用于除初始加密级别之外的所有加密级别。初始加密级别的密钥根据客户端的初始目标连接ID计算，如第5.2节所述。   
用于包保护的密钥是使用TLS提供的KDF从TLS机密中计算出来的。在TLS 1.3中，使用了[TLS13]第7.1节中描述的“HKDF Expand Label”函数，使用协商密码套件中的哈希函数。   
当前的加密级别机密和标签“quic key”被输入到KDF以生成AEAD密钥；标签“quic iv”用于派生IV；参见第5.3节。包头保护钥匙使用“quic hp”标签；见第5.4节。使用这些标签可以在QUIC和TLS之间进行密钥分隔；参见第9.5节。   
用于初始机密的KDF始终是tls1.3中的“HKDF Expand Label”函数（见第5.2节）。   

### 5.2 初始加密
初始数据包使用从客户端的初始数据包的目标连接ID字段派生的机密进行保护。具体如下：
```
initial_salt = 0xc3eef712c72ebb5a11a7d2432bb46365bef9f502
   initial_secret = HKDF-Extract(initial_salt,
                                 client_dst_connection_id)

   client_initial_secret = HKDF-Expand-Label(initial_secret,
                                             "client in", "",
                                             Hash.length)
   server_initial_secret = HKDF-Expand-Label(initial_secret,
                                             "server in", "",
                                             Hash.length)
```
当派生初始机密和密钥时，HKDF的哈希函数是SHA-256[SHA]。   
与HKDF Expand Label一起使用的连接ID是客户端发送的初始数据包中的目标连接ID。这将是一个随机选择的值，除非客户端在接收到重试数据包后创建初始数据包，其中目标连接ID由服务器选择。   
initial_salt的值是图中以十六进制表示的20字节序列。未来版本的QUIC应该生成一个新的salt值，从而确保每个版本的QUIC的键都是不同的。这可以防止只识别一个QUIC版本的中间设备查看或修改将来版本的包的内容。   
TLS 1.3中定义的“HKDF Expand Label”函数必须用于初始数据包，即使提供的TLS版本不包括TLS 1.3。   
当服务器发送重试数据包以使用服务器选择的连接ID值时，用于保护初始数据包的机密会发生更改。当客户端响应来自服务器的初始数据包而更改其使用的目标连接ID时，密钥不会更改。   
注意：目标连接ID的长度是任意的，如果服务器发送的重试数据包的源连接ID字段为零，则长度可能为零。在这种情况下，初始密钥不向客户端保证服务器已收到其数据包；客户端必须依赖包含该属性的重试数据包的交换。

### 5.3 AEAD使用
用于QUIC数据包保护的身份验证加密（AEAD）[AEAD]函数是协商用于TLS连接的AEAD。例如，如果TLS使用TLS_AES_128_GCM_256，则使用AEAD_AES_128_GCM函数。   
在应用包头保护之前，数据包受到保护（第5.4节）。无保护的数据包头是相关数据（A）的一部分。当删除数据包保护时，端点首先删除包头保护。   
除版本协商和重试数据包之外的所有QUIC数据包都使用AEAD算法[AEAD]进行保护。在建立共享密钥之前，数据包由AEAD_AES_128_GCM和从客户端第一个初始数据包中的目标连接ID派生的密钥进行保护（见第5.2节）。这提供了针对非路径攻击者的保护，并针对QUIC版本不知道的中间盒提供了健壮性，但不针对路径上的攻击者。   
QUIC可以使用[TLS13]中定义的任何密码套件，TLS_AES_128_CCM_8_SHA256除外。除非为密码套件定义了标头保护方案，否则不得协商密码套件。本文件为[TLS13]中定义的除TLS_AES_128_CCM_8_SHA256之外的所有密码套件定义了一个头保护方案。这些密码集具有16字节的身份验证标记，并产生比输入大16字节的输出。   
注意：端点不能拒绝提供它不支持的密码套件的"ClientHello"，否则将无法部署新的密码套件。这也适用于TLS_AES_128_CCM_8_SHA256。   
如第5.1节所述，计算包的密钥和IV。所有的密钥由分组保护IV与分组号组合而成。以网络字节顺序重建的QUIC数据包编号的62位用0填充到IV的大小。填充包编号和IV的异或构成AEAD。   
AEAD的相关数据A是QUIC报头的内容，从短或长报头中的标志字节开始，直到并包括未受保护的数据包编号。   
AEAD的输入明文P是QUIC包的有效载荷，如[QUIC-TRANSPORT]中所述。AEAD的输出密文C代替P传输。    
一些AEAD函数对相同密钥和IV下可以加密的数据包数量有限制（例如，请参见[AEBounds]）。这可能低于包数限制。端点必须在超过为正在使用的AEAD设置的任何限制之前启动密钥更新（第6节）。

### 5.4 包头保护
QUIC包头的部分，特别是包号字段，使用独立于包保护密钥和IV的密钥来保护。使用“quic hp”标签派生的密钥用于为那些不暴露于on-path元素的字段提供机密性保护。   
此保护适用于第一个字节的最低有效位，加上数据包编号字段。第一字节的四个最小有效位为具有长包头的数据包提供保护；对于短包头的数据包，保护第一字节的五个最小有效位。对于这两种包头的形式，包括保留位和包号长度字段；“Key Phase”位也为具有短包头的数据包提供保护。   
在连接期间使用相同的头保护密钥，在密钥更新后该值不变（见第6节）。这允许头保护被用来保护关键阶段。   
此过程不适用于重试或版本协商数据包，这些数据包不包含受保护的有效负载或任何字段。

### 5.4.1 应用头保护
在应用数据包保护后应用包头保护（见第5.3节）。对数据包的密文进行采样并作为加密算法的输入。使用的算法取决于协商的AEAD。   
该算法的输出是一个5字节掩码，它使用异或应用于受保护的头字段。包的第一个字节的最低有效位被第一个掩码字节的最低有效位屏蔽，包号用剩余字节屏蔽。任何可能由较短的数据包编号编码产生的未使用的掩码字节都不使用。   
图6显示了应用头保护的示例算法。移除报头保护只在分组号长度（pn_length）的确定顺序上有所不同。
```
   mask = header_protection(hp_key, sample)

   pn_length = (packet[0] & 0x03) + 1
   if (packet[0] & 0x80) == 0x80:
      # Long header: 4 bits masked
      packet[0] ^= mask[0] & 0x0f
   else:
      # Short header: 5 bits masked
      packet[0] ^= mask[0] & 0x1f

   # pn_offset is the start of the Packet Number field.
   packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]

              图 6: 包头保护伪码
```
图7显示了用E标记的长标题和短标题的受保护字段。图7还显示了采样字段。
```
   Long Header:
   +-+-+-+-+-+-+-+-+
   |1|1|T T|E E E E|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Version -> Length Fields                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Short Header:
   +-+-+-+-+-+-+-+-+
   |0|1|S|E E E E E|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0/32..144)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Common Fields:
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E E E E E E E E E  Packet Number (8/16/24/32) E E E E E E E E...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   [Protected Payload (8/16/24)]             ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Sampled part of Protected Payload (128)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Protected Payload Remainder (*)             ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    图 7: 包头保护和密文样本
```
在TLS密码套件可以与QUIC一起使用之前，必须为与该密码套件一起使用的AEAD指定标头保护算法。本文件定义了AEAD_AES_128_GCM、AEAD_AES_128_GCM、AEAD_AES_256_GCM（所有AES AEAD定义在[AEAD]）和AEAD_CHACHA20_POLY1305[chachacha]的算法。在TLS选择密码套件之前，使用AES报头保护（第5.4.3节），匹配AEAD_AES_128_GCM包保护。

### 5.4.2 包头保护示例
报头保护算法同时使用包头保护密钥和来自包有效载荷字段的密文样本。   
对相同数量的字节进行采样，但是需要为Endpoint移除保护留出一个余量，因为Endpoint移除保护将不知道包编号字段的长度。在对包密文进行采样时，假设包编号字段为4字节长（其最大可能编码长度）。   
端点必须丢弃长度不足以包含完整样本的数据包。   
为了确保有足够的数据可用于采样，对包进行填充，使得编码的包编号和受保护的有效载荷的组合长度至少比包头保护所需的样本长4个字节。[TLS13]中定义的密码套件（TLS_AES_128_CCM_8_SHA256除外，本文档中未定义头保护方案）具有16字节扩展和16字节头保护示例。这导致在未保护的有效负载中需要至少3字节的帧（如果包编号是在单字节上编码的），或者对于2字节的分组号编码，则需要2字节的帧。
具有短包头的包的抽样密文可由以下伪码确定：  
```
sample_offset = 1 + len(connection_id) + 4
sample = packet[sample_offset..sample_offset+sample_length]
```
例如，对于具有短包头、8字节连接ID并受AEAD_AES_128_GCM保护的数据包，该示例使用字节13到28（包括字节13到28）（使用基于零的索引）。   
具有长包头的数据包以相同的方式进行采样，注意多个QUIC数据包可能包含在同一个UDP数据报中，并且每个数据包都是单独处理的。   
```
sample_offset = 7 + len(destination_connection_id) +
                       len(source_connection_id) +
                       len(payload_length) + 4
if packet_type == Initial:
       sample_offset += len(token_length) +
                        len(token)

sample = packet[sample_offset..sample_offset+sample_length]
```

### 5.4.3 基于AES的包头保护
本节定义AEAD_AES_128_GCM、AEAD_AES_128_CCM和AEAD_AES_256_GCM的数据包保护算法。AEAD_AES_128_GCM和AEAD_AES_128_CCM在电子码本（ECB）模式下使用128位AES[AES]。AEAD_AES_256_GCM在ECB模式下使用256位AES。   
该算法从包密文中抽取16个字节。该值用作AES-ECB的输入。在伪代码中：
```
mask = AES-ECB(hp_key, sample)
```

### 5.4.4 基于ChaCha20的报头保护
使用AEAD_CHACHA20_POLY1305时，头保护使用[CHACHA]第2.4节中定义的原始CHACHA20功能。这使用一个256位的密钥和从包保护输出中取样的16个字节。   
采样密文的前4个字节是块计数器。ChaCha20实现可以用32位整数代替字节序列，在这种情况下，字节序列被解释为一个“little-endian”值。   
剩下的12个字节用作”nonce“。一个ChaCha20实现可以用一个由三个32位整数组成的数组来代替一个字节序列，在这种情况下，“nonce”字节被解释为一个32位低位整数序列。   
加密掩码是通过调用ChaCha20来保护5个零字节来生成的。在伪代码中：
```
counter = sample[0..3]
nonce = sample[4..15]
mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0})
```

### 5.4.5 接收受保护的数据包
一旦一个端点成功地接收到一个具有给定包号的包，它必须丢弃在同一个包号空间中具有更高包号的所有包，如果这些包不能用同一个密钥成功地解除保护，或者-如果有密钥更新-下一个包保护密钥（见第6节）。类似地，似乎触发密钥更新但无法成功解除保护的数据包必须被丢弃。   
未能解除对数据包的保护并不一定表示对等方或攻击中存在协议错误。在QUIC中使用的截短包号编码，如果包被严重延迟，则会导致包编号被错误解码。

### 5.6 使用0-RTT密钥
如果0-RTT密钥可用（参见第4.5节），则缺少重播保护意味着必须限制其使用，以避免对协议的重播攻击。客户端必须仅使用0-RTT密钥来保护幂等数据。客户端可能希望在完成TLS握手之前对其发送的数据应用附加限制。否则，客户端将0-RTT密钥视为等同于1-RTT密钥，除非它不能用0-RTT密钥发送ack。   
接收到服务器已接受其0-RTT数据的指示的客户机可以发送0-RTT数据，直到它接收到服务器的所有握手消息。如果客户端收到0-RTT数据已被拒绝的指示，则应停止发送0-RTT数据。   
服务器不能使用0-RTT密钥来保护数据包；它使用1-RTT密钥来保护0-RTT数据包的确认。客户端不能试图解密它接收到的0-RTT数据包，而必须丢弃它们。   
一旦客户端安装了1-RTT密钥，它就不能再发送任何0-RTT包。   
注意：服务器在接收0-RTT数据时可以对其进行确认，但是在TLS握手完成之前，任何包含0-RTT数据确认的数据包都不能被客户端删除数据包保护。在客户端接收到所有服务器握手消息之前，无法导出删除数据包保护所需的1-RTT密钥。

### 5.7 无序接收受保护的帧
由于重新排序和丢失，在接收到最终的TLS握手消息之前，端点可能会接收到受保护的数据包。客户端将无法从服务器解密1-RTT包，而服务器将能够从客户端解密1-RTT包。在完成握手之前，任一角色中的Endpoint都不要解密对端的1-RTT数据包。   
即使1-RTT密钥在从客户端接收到第一次握手消息后可供服务器使用，但它缺少关于客户端状态的保证：
+ 除非服务器选择使用预共享密钥并验证了客户端的预共享密钥绑定器，否则客户端不会进行身份验证；请参见[TLS13]第4.2.11节。
+ 除非使用了重试数据包，否则客户端没有显示活动性。
+ 服务器响应的任何接收到的0-RTT数据都可能是由于重播攻击造成的。

因此，服务器对1-RTT密钥的使用必须限于在握手完成之前发送数据。在TLS握手完成之前，服务器**不得**处理传入的受1-RTT保护的数据包。因为发送确认表示一个包中的所有帧都已被处理，所以在TLS握手完成之前，服务器无法为1-RTT数据包发送确认。接收到的用1-RTT密钥保护的数据包可以被存储，并且在握手完成后解密和使用。   
注意：TLS实现可能在握手完成之前提供所有1-RTT机密。即使QUIC实现有1-RTT密钥，在完成握手之前也不能使用这些密钥。   
要求服务器等待客户端的完成消息会对所传递的消息产生依赖。客户端可以在发送1-RTT包时联合一个包含了“Finished”消息的**CRYPTO**帧副本的握手包，直到其中一个握手包被确认为止，从而避免潜在的线头阻塞。这使服务器能够立即处理这些数据包。   
在接收TLS “ClientHello”之前，服务器可以接收用0-RTT密钥保护的数据包。服务器可以保留这些分组以备以后解密，以预期接收到“ClientHello”。

### 5.8 重试数据包的完整性
重试数据包（请参阅[QUIC-TRANSPORT]的“重试数据包”部分）带有一个“Retry Integrity Tag”标记，该标记提供两个属性：允许丢弃被网络意外损坏的数据包，并削弱了非路径攻击者发送有效重试数据包的能力。    
“Retry Integrity Tag”标记是一个128位字段，计算为AEAD_AES_128_GCM[AEAD]的输出，并与以下输入一起使用：
+ 128位的密钥K，等于0x4d32ecdb2a213c841e4043df27d4430。
+ 96位的nonce N，等于0x4d1611d05513a552c587d575。
+ 明文P，空的。
+ 关联数据A是重试伪包的内容，如图8所示：密钥和nonce是通过调用HKDF Expand Label得到的值，使用0x656e61e336ae9417f7f0edd8d78d461e2aa7084aba7a14c1e9f726d55709169a作为机密，标签为“quic key”和“quic iv”（第5.1节）。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | ODCID Len (8) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Original Destination Connection ID (0..160)        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|1| 3 | Unused|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Retry Token (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                            图 8: 重试包
```
重试伪数据包不会通过线路发送。通过获取传输的重试数据包，删除重试完整性标记并在前面添加以下两个字段来计算：
+ ODCID Len: ODCID Len包含后面的原始目标连接ID字段的字节长度，编码为8位无符号整数。
+   Original Destination Connection ID:  包含此重试响应的初始数据包中的目标连接ID的值。此字段的长度以ODCID Len表示。此字段的存在减少了非路径攻击者注入重试数据包的可能。

## 6 密钥更新


